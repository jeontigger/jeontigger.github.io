# 🧠 C++ std::unique_ptr 동작 방식 면접 질문 리스트

## ✅ 기본 개념

1. std::unique_ptr란 무엇인가요?

    - 단일 소유권을 원칙으로 하는 스마트 포인터입니다.

2. unique_ptr의 핵심 설계 철학은 무엇인가요?

    - 해당 자원을 관리하는 포인터가 단 하나만 존재해야한다는 철학입니다.

## ✅ 소유권 / 복사·이동

1. unique_ptr는 왜 복사할 수 없나요?

    - 단일 소유권을 원칙으로 하기 때문입니다.

2. unique_ptr는 어떻게 소유권을 이전하나요?

    - move를 통해 소유권을 이전할 수 있습니다.

3. std::move가 unique_ptr에서 하는 역할은 무엇인가요?

    - 기존에 있던 unique_ptr에 move를 하여 우측값으로 만들어주어 이동생성자나 이동대입연산자를 호출할 수 있도록 합니다.

## ✅ 수명 관리

1. unique_ptr는 언제 관리 중인 객체를 해제하나요?

    - 소멸할 때 소멸자에서 객체를 해제합니다.

2. scope를 벗어날 때 어떤 일이 발생하나요?

    - 스택에 생성했다면 scope를 벗어날 때 소멸합니다.

## ✅ delete / 커스텀 삭제자

1. unique_ptr는 내부적으로 어떻게 delete를 호출하나요?

    - 일반 포인터라면 관리하는 data*에 대해 delete를 호출합니다.

## ✅ API 동작 이해

1. get(), release(), reset()의 차이는 무엇인가요?

    - get은 해당 포인터를 가져옵니다. release는 가리키고 있는 자원을 해제합니다. reset은 잘 모르겠습니다.

2. unique_ptr를 raw pointer로 변환해도 안전한가요?

    - RAII를 사용하는 목적에 위배됩니다. 권장하지 않습니다.

## ✅ 배열 / 특수 형태

1. unique_ptr<T[]>는 어떤 점이 다른가요?

    - 배열의 형태로 자원을 관리합니다.

2. delete[]는 언제 호출되나요?

    - unique_ptr<T[]>가 소멸할 때 호출됩니다.

## ✅ 컨테이너 / 실무 사용

1. unique_ptr를 STL 컨테이너에 저장할 수 있나요?

    - 저장할 수 있습니다.

2. 어떤 상황에서 unique_ptr를 사용하는 것이 가장 적절한가요?

    - 단 하나의 포인터만 해당 자원을 관리해야할 때 사용하는 것이 가장 적절합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 단일 객체의 소유권을 독점적으로 관리하는 스마트 포인터입니다.
2. 하나의 자원은 하나의 소유자만 가진다는 원칙입니다.

3. 소유권 중복을 막기 위해 복사 생성자가 삭제되어 있습니다.
4. 이동 생성자나 이동 대입을 통해 소유권을 이전합니다.
5. lvalue를 rvalue로 캐스팅해 소유권 이전을 가능하게 합니다.

6. unique_ptr가 파괴될 때 관리 중인 객체를 delete합니다.
7. 소멸자가 호출되며 자동으로 자원이 해제됩니다.

8. 내부에 저장된 deleter를 통해 delete를 호출합니다.
9. 파일 핸들, 커스텀 메모리 등 특수 해제 로직을 위해 필요합니다.

10. get은 관찰, release는 소유권 포기, reset은 교체/해제입니다.
11. 관찰 용도로는 가능하지만 소유권 이전은 아닙니다.

12. 배열 전용 특수화로 delete[]를 사용합니다.
13. unique_ptr<T[]>가 소멸될 때입니다.

14. 네, 이동 가능하기 때문에 저장할 수 있습니다.
15. 명확한 단일 소유권과 자동 해제가 필요할 때입니다.

16. unique_ptr는 “복사 불가·이동 가능 단일 소유 스마트 포인터”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ delete / 커스텀 삭제자

**질문 1: unique_ptr는 내부적으로 어떻게 delete를 호출하나요?**
- **현재 답변**: "일반 포인터라면 관리하는 data*에 대해 delete를 호출합니다."
- **피드백**:
  - ⚠️ **부정확**: 내부 메커니즘 설명이 부정확합니다
  - ✅ **정확한 답변**: "내부에 저장된 deleter를 통해 delete를 호출합니다"
  - unique_ptr는 템플릿 매개변수로 deleter를 받아 저장하고, 소멸 시 이 deleter를 호출하여 객체를 해제합니다. 기본 deleter는 std::default_delete<T>입니다

### ✅ API 동작 이해

**질문 1: get(), release(), reset()의 차이는 무엇인가요?**
- **현재 답변**: "get은 해당 포인터를 가져옵니다. release는 가리키고 있는 자원을 해제합니다. reset은 잘 모르겠습니다."
- **피드백**:
  - ❌ **오개념**: release()는 자원을 해제하는 것이 아닙니다
  - ✅ **정확한 답변**: "get은 관찰, release는 소유권 포기, reset은 교체/해제입니다"
  - release()는 unique_ptr의 소유권을 포기하고 raw pointer를 반환합니다. 메모리를 해제하지 않으며, 호출한 후 unique_ptr는 nullptr가 됩니다
  - reset()은 현재 관리 중인 객체를 해제하고 새로운 객체(또는 nullptr)로 교체합니다. reset() 또는 reset(nullptr) 호출 시 현재 객체가 해제됩니다
  - ❌ **답변 누락**: reset()에 대한 답변이 필요합니다

### 📊 전체 평가

**강점:**
- unique_ptr의 기본 개념과 설계 철학 이해
- 소유권 이전 메커니즘 이해
- 수명 관리 원리 파악
- 배열 형태 사용법 이해

**개선 필요:**
- ❌ **높음**: release()와 reset()의 정확한 동작을 이해해야 합니다 (release는 해제가 아니라 소유권 포기)
- ⚠️ **중간**: unique_ptr의 내부 deleter 메커니즘을 정확히 이해해야 합니다
- ❌ **중간**: reset()에 대한 답변이 누락되었습니다

**우선순위:**
1. **높음**: release()는 메모리를 해제하는 것이 아니라 소유권을 포기하고 raw pointer를 반환한다는 점을 정확히 이해해야 합니다
2. **중간**: reset()의 동작(현재 객체 해제 및 교체)을 이해해야 합니다
3. **중간**: unique_ptr의 내부 deleter 메커니즘을 정확히 이해해야 합니다

**특별 주의사항:**
- get(), release(), reset()의 차이는 면접에서 자주 나오는 질문입니다. 특히 release()는 해제가 아니라 소유권 포기라는 점을 명확히 해야 합니다
- release() 호출 후에는 unique_ptr가 nullptr가 되며, 반환된 raw pointer를 직접 관리해야 합니다

