# 🧠 C++ new / delete 내부 동작 면접 질문 리스트

## ✅ 기본 개념

1. C++의 new와 delete는 각각 어떤 역할을 하나요?

    - new는 공간할당을 하고, 해당 타입의 생성자를 호출합니다. delete는 소멸자를 호출하며 해당 공간을 해제합니다.

2. malloc/free와 new/delete의 차이는 무엇인가요?

    - malloc과 free는 메모리 할당과 해제만 수행합니다. 또 리턴을 할 때 void*로 공간을 할당하여 반환하기 때문에 타입 변환이 필요하고 메모리 할당중에 예외가 발생하면 null을 반환합니다. 그러나 new와 delete는 메모리 할당과 해제를 수행하며 생성자 소멸자를 호출하고, 해당 타입 포인터로 캐스팅하며 할당중에 예외가 발생하면 catch로 대응할 수 있습니다.

## ✅ new 동작 과정

1. new 연산자는 내부적으로 어떤 단계를 거치나요?

    - 메모리를 할당합니다. 객체의 생성자를 호출하며 초기화 합니다. 해당 주소를 반환합니다.

2. 객체 생성 시 생성자는 언제 호출되나요?

    - 메모리가 할당된 후 호출됩니다.

3. new가 실패하면 어떤 일이 발생하나요?

    - 예외가 발생합니다.

## ✅ delete 동작 과정

1. delete 연산자는 내부적으로 어떤 단계를 거치나요?

    - 객체의 소멸자를 호출한 후 메모리를 해제합니다.

2. 객체 소멸 시 소멸자는 언제 호출되나요?

    - 즉시 호출됩니다.

3. delete 이후 메모리는 즉시 OS에 반환되나요?

    - 즉시 os에 반환되지는 않고, c++ 내부적으로 메모리 풀에 반납하는 것으로 알고있습니다.

## ✅ 배열 new/delete

1. new와 new[]의 차이는 무엇인가요?

    - new는 하나의 객체 공간을 할당하고, new[]는 객체 배열을 할당합니다.

2. delete와 delete[]를 잘못 짝지으면 어떤 문제가 생기나요?

    - 정의되지 않은 동작을 수행합니다.

## ✅ 연산자 오버로딩

1. operator new와 operator delete는 무엇인가요?

    - 공간을 할당하고, 공간을 해제합니다.

2. operator new를 오버로딩하는 목적은 무엇인가요?

    - new를 하면서 필요한 기능들이 존재할 때 오버로딩 합니다.

## ✅ 예외 / 안전성

1. 생성자에서 예외가 발생하면 메모리는 어떻게 되나요?

    - 모두 반환됩니다.

2. delete nullptr는 안전한가요?

    - 안전합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. new는 메모리 할당과 객체 생성을, delete는 객체 소멸과 메모리 해제를 수행합니다.
2. new/delete는 생성자·소멸자를 호출하지만 malloc/free는 그렇지 않습니다.

3. 메모리 할당 → 생성자 호출 순서로 동작합니다.
4. 메모리 할당이 성공한 후 호출됩니다.
5. 기본 new는 std::bad_alloc 예외를 던집니다.

6. 소멸자 호출 → 메모리 해제 순서로 동작합니다.
7. delete가 호출될 때 가장 먼저 실행됩니다.
8. 보통 런타임 힙 관리자로 반환되고 OS로 즉시 반환되지는 않습니다.

9. new[]는 배열 전체를, new는 단일 객체를 생성합니다.
10. 소멸자 호출 횟수 불일치로 정의되지 않은 동작이 발생합니다.

11. 메모리 할당/해제 동작을 정의하는 함수입니다.
12. 커스텀 메모리 풀이나 추적을 구현하기 위해서입니다.

13. 이미 할당된 메모리는 자동으로 해제됩니다.
14. 네, 아무 동작도 하지 않습니다.

15. 메모리 누수와 예외 안전성 문제가 생기기 쉽기 때문입니다.
16. new는 “할당+생성”, delete는 “소멸+해제”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 2: malloc/free와 new/delete의 차이는 무엇인가요?**
- **현재 답변**: "malloc과 free는 메모리 할당과 해제만 수행합니다. 또 리턴을 할 때 void*로 공간을 할당하여 반환하기 때문에 타입 변환이 필요하고 메모리 할당중에 예외가 발생하면 null을 반환합니다."
- **피드백**:
  - ⚠️ **부정확**: "메모리 할당중에 예외가 발생하면 null을 반환합니다"는 표현이 부정확합니다
  - ✅ **정확한 설명**: malloc은 예외를 던지지 않습니다. 메모리 할당 실패 시 null 포인터를 반환합니다 (예외가 아니라 반환값으로 처리)
  - new는 할당 실패 시 std::bad_alloc 예외를 던지지만, malloc은 예외를 사용하지 않고 null 포인터를 반환합니다

### ✅ delete 동작 과정

**질문 3: delete 이후 메모리는 즉시 OS에 반환되나요?**
- **현재 답변**: "즉시 os에 반환되지는 않고, c++ 내부적으로 메모리 풀에 반납하는 것으로 알고있습니다."
- **피드백**:
  - ⚠️ **용어 정확성**: "메모리 풀"보다는 "런타임 힙 관리자" 또는 "힙 관리자"가 더 정확한 표현입니다
  - ✅ **정확한 설명**: "보통 런타임 힙 관리자로 반환되고, OS로 즉시 반환되지는 않습니다. 힙 관리자가 필요에 따라 OS에 반환합니다"

### ✅ 연산자 오버로딩

**질문 1: operator new와 operator delete는 무엇인가요?**
- **현재 답변**: "공간을 할당하고, 공간을 해제합니다."
- **피드백**:
  - ⚠️ **부정확**: new/delete 연산자와 operator new/delete를 구분하지 못했습니다
  - ✅ **정확한 답변**: "메모리 할당/해제 동작을 정의하는 함수입니다. new/delete 연산자가 내부적으로 호출하는 함수입니다"
  - operator new는 메모리만 할당하고, new 연산자는 operator new를 호출한 후 생성자를 호출합니다
  - operator delete는 메모리만 해제하고, delete 연산자는 소멸자를 호출한 후 operator delete를 호출합니다

**질문 2: operator new를 오버로딩하는 목적은 무엇인가요?**
- **현재 답변**: "new를 하면서 필요한 기능들이 존재할 때 오버로딩 합니다."
- **피드백**:
  - ⚠️ **부정확**: 목적이 너무 모호하게 설명되었습니다
  - ✅ **정확한 답변**: "커스텀 메모리 풀이나 추적, 디버깅, 성능 최적화 등을 구현하기 위해서입니다"
  - 구체적인 예: 메모리 사용량 추적, 특정 메모리 풀 사용, 메모리 정렬 요구사항 충족 등

### 📊 전체 평가

**강점:**
- new/delete의 기본 동작 과정 이해
- 생성자/소멸자 호출 시점 파악
- malloc/free와 new/delete의 주요 차이점 이해
- delete nullptr 안전성 인지

**개선 필요:**
- ❌ **높음**: operator new/delete와 new/delete 연산자의 차이를 명확히 구분해야 합니다
- ⚠️ **중간**: malloc의 예외 처리 방식 설명이 부정확합니다 (예외가 아니라 null 반환)
- ⚠️ **중간**: delete 이후 메모리 반환 과정 설명 시 용어를 더 정확하게 사용해야 합니다 ("메모리 풀" → "런타임 힙 관리자")

**우선순위:**
1. **높음**: operator new/delete의 개념을 정확히 이해하고 new/delete 연산자와 구분해야 합니다
2. **중간**: malloc의 실패 처리 방식 (예외 vs null 반환)을 정확히 이해해야 합니다
3. **중간**: 메모리 반환 과정 설명 시 정확한 용어 사용이 필요합니다

**특별 주의사항:**
- operator new/delete는 면접에서 자주 나오는 주제이며, new/delete 연산자와의 차이를 명확히 구분할 수 있어야 합니다
- malloc/free와 new/delete의 차이는 생성자/소멸자 호출뿐만 아니라 예외 처리 방식도 다르다는 점을 명확히 해야 합니다

