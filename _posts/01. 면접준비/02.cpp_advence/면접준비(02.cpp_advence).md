---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비]
published: true
tags:
    [면접준비]
---

# cpp_advence

## 🧠 01. 복사 생성자

### ✅ 기본 개념

1. 복사 생성자란 무엇인가요?

    - 복사 생성자란 같은 타입의 변수를 인자로 받는 생성자입니다. 복사 생성자를 별도로 만들지 않는다면 컴파일러가 기본 복사 생성자를 생성해냅니다.

2. 복사 생성자와 복사 대입 연산자의 차이는 무엇인가요?

    - 복사 생성자는 새로 만드는 변수에 사용되는 함수이고, 복사 대입 연산자는 이미 사용중인 변수에 대입하는 연산자입니다.

### ✅ 컨테이너 / 문맥별 동작

1. STL 컨테이너에 객체를 push할 때 복사 생성자는 언제 호출되나요?

    - size가 capacity보다 작다고 가정했을 때, 가장 마지막 위치에 push하려는 객체로 복사 생성자가 호출됩니다.

2. 컨테이너 재할당(reallocation) 시 복사 생성자는 언제 호출되나요?

    - 컨테이너가 재할당되면서 이동 생성자가 없는 타입의 경우에 모든 요소에 대해 복사 생성자가 호출됩니다.

### ✅ 최적화 / 예외 상황

1. RVO(Return Value Optimization)란 무엇인가요?

    - 임시객체 최적화입니다. 임시 객체를 반환하기 위해 복사 생성자가 호출되어야 하지만, 반환하는 자리에 객체를 생성하는 것으로 복사 생성자의 호출을 줄입니다.

2. RVO가 적용되면 복사 생성자는 호출되나요?

    - 호출되지 않습니다.

### ✅ const / 참조 연계

1. const 객체를 복사할 때도 복사 생성자가 호출되나요?

    - 호출됩니다.

2. 참조로 객체를 전달하면 복사 생성자가 호출되나요?

    - 호출되지 않습니다.

### ✅ 설계 / 판단

1. 복사 생성자 호출이 잦으면 어떤 문제가 생기나요?

    - 깊은 복사가 존재한다면 메모리 할당이 자꾸 발생하는 문제가 생깁니다.

2. 복사 생성자 호출을 줄이기 위한 방법에는 무엇이 있나요?

    - 이동 생성자와 이동 대입 연산자를 선언하여 이동을 사용하는 방법이 있습니다.

---

### GPT 피드백

1. 복사 생성자의 정의가 약했음. 기존 객체를 이용해 새 객체를 만드는 생성자.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 기존 객체를 사용해 새 객체를 생성할 때 호출되는 생성자입니다.
2. 복사 생성자는 새 객체 생성 시, 복사 대입 연산자는 기존 객체에 대입할 때 호출됩니다.

3. 컨테이너 내부에 새 요소를 복사해 저장할 때 호출됩니다.
4. 기존 요소들을 새 메모리로 옮길 때 호출됩니다.

5. 반환 객체 생성을 최적화해 복사를 생략하는 컴파일러 최적화입니다.
6. 아니요, RVO가 적용되면 복사 생성자는 호출되지 않습니다.

7. 네, const 여부와 무관하게 복사 생성자는 호출됩니다.
8. 아니요, 참조 전달은 객체를 새로 생성하지 않습니다.

9. 불필요한 메모리 복사로 성능 저하가 발생합니다.
10. 참조 전달, 이동语 지원, RVO 활용이 있습니다.

</div>
</details>

## 🧠 02. 이동 생성자(move constructor)

### ✅ 기본 개념

1. 이동 생성자란 무엇인가요?

    - 이동 생성자란 기존 객체의 소유권을 포기하고 새로 생기는 객체에게 해당 소유권을 모두 넘기는 생성자입니다.

2. 이동 생성자와 복사 생성자의 차이는 무엇인가요?

    - 복사 생성자는 같은 객체가 2개 생기는 것이지만, 이동 생성자는 인자로 받았던 객체는 모두 초기화된 상태로 변경됩니다.

### ✅ 등장 배경 / 필요성

1. 이동 생성자는 왜 등장했나요?

    - 임시객체처럼 생성을 위해 사용되고 난 후엔 사용하지 않는 객체를 인자로 새 객체를 생성할 때, 불필요한 공간할당 비용을 줄이기 위해 등장했습니다.

### ✅ 언어 규칙 / 제약

1. 이동 생성자를 `noexcept`로 선언하는 이유는 무엇인가요?

    - 이동 생성자를 수행하는 도중에 예외가 발생했을 때 남은 멤버에 대한 소유권을 컴파일러가 결정할 수 없기 때문입니다.

### ✅ 컨테이너 / 실무 관점

1. STL 컨테이너에서 이동 생성자는 언제 중요한가요?

    - reallocate가 될 때 불필요한 복사 비용을 줄입니다.

---

### GPT 피드백

1. 이동생성되고 남은 객체는 초기화된 상태보다는 미정 상태라고 하는것이 맞음

2. noexcept는 STL 사용에 대한 이야기가 필수적이라고 보임. STL이 강한 예외 안정성을 보이기 때문에 noexcept 키워드가 없다면 일반 copy 진행

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 임시 객체나 자원의 소유권을 다른 객체로 이전하는 생성자입니다.
2. 복사는 데이터를 복제하고, 이동은 자원 소유권만 이전합니다.

3. 불필요한 깊은 복사로 인한 성능 저하를 해결하기 위해 등장했습니다.

4. 컨테이너가 예외 안전을 보장하기 위해 이동을 선택할 수 있게 하기 위함입니다.

5. 재할당(reallocation)이나 요소 이동이 잦을 때 중요합니다.

</div>
</details>

## 🧠 03. std::move

### ✅ 기본 개념

1. std::move란 무엇인가요?

    - lvalue를 rvalue로 캐스팅해줍니다.

2. std::move는 실제로 객체를 이동시키나요?

    - rvalue로 캐스팅 할 뿐, 이동시키지 않습니다. 실제로 이동시키기 위해서는 move를 통해 rvalue가 된 객체를 이동 생성자나, 이동 대입 연산자를 이용해야 합니다.

3. std::move를 호출하면 객체에는 어떤 변화가 생기나요?

    - 객체에는 변화가 없습니다. 파라미터에 따라 함수를 결정할 때 rvalue로 판정됩니다.

### ✅ 타입 / 캐스팅 관점

1. std::move의 반환 타입은 무엇인가요?

    - T&& 입니다.

2. std::move와 static_cast<T&&>의 관계는 무엇인가요?

    - 같은 동작을 합니다.

--- 

### GPT 피드백

1. move와 static_cast<T&&>와 같은 동작을 하긴 하지만, move는 정확한 rvalue_reference를 수행하는 차이가 존재함. 엄밀히 말하면 static_cast<T&&>와는 다름

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 객체를 rvalue로 캐스팅해 이동 가능함을 표현하는 함수입니다.
2. 아니요, 실제 이동은 생성자나 대입 연산자가 수행합니다.
3. std::move 자체로는 객체 상태를 바꾸지 않습니다.

4. 전달된 객체를 rvalue reference(T&&)로 반환합니다.
5. std::move는 내부적으로 static_cast<T&&>와 동일한 동작을 합니다.

</div>
</details>

## 🧠 04. 임시 객체(temporary object)

### ✅ 기본 개념

1. 임시 객체란 무엇인가요?

    - 함수의 반환할 때 전달되기 위한 객체로 해당 명령이 끝난 직후 사라지게 되는 무명객체입니다.

2. 임시 객체는 언제 생성되나요?

    - 함수에 의해 객체가 반환될 때 생성됩니다.

### ✅ 수명 규칙

1. 일반적으로 임시 객체의 수명은 언제까지인가요?

    - 해당 라인까지입니다.

2. 임시 객체의 수명은 왜 짧게 설계되어 있나요?

    - 그 라인까지만 쓰이고, 바로 사라져야 메모리 관리가 가능하기 때문입니다.

### ✅ 참조와 수명 연장

1. const lvalue reference에 임시 객체를 바인딩하면 어떤 일이 발생하나요?

    - 복사 생성자가 호출됩니다.

2. rvalue reference에 임시 객체를 바인딩하면 수명은 어떻게 되나요?

    - 임시 객체는 소멸되며 유효하지 않은 영역을 가리키게 됩니다.

3. 참조에 바인딩되지 않은 임시 객체는 언제 소멸되나요?

    - 그 라인이 끝난 직후 즉시 소멸됩니다.

### ✅ 함수 호출 / 반환 관점

1. 함수 인자로 전달된 임시 객체의 수명은 언제까지인가요?

    - 함수가 소멸될 때 까지입니다.

2. 함수 반환값으로 생성된 임시 객체의 수명은 어떻게 관리되나요?

    - 다른 변수가 받지 않는 이상 즉시 소멸됩니다.

### ✅ std::move / rvalue 연계

1. std::move로 만들어진 임시 객체의 수명은 어떻게 되나요?

    - rvalue로 캐스팅 되는 것이고, 임시 객체가 되는 것은 아닙니다.

2. 이동 생성자와 임시 객체 수명은 어떤 관계가 있나요?

    - 임시객체를 인자로 받으면 이동 생성자가 호출되는 것입니다.

### ✅ 오류 / 설계 판단

1. 임시 객체의 수명과 관련해 자주 발생하는 버그는 무엇인가요?

    - 해제된 메모리 영역을 접근하는 것입니다.

2. 임시 객체 수명 문제를 방지하는 방법은 무엇인가요?

    - 다른 객체가 임시 객체를 이어 받으면 됩니다.

### ✅ 요약 질문

1. 임시 객체 수명을 한 문장으로 요약해보세요.

    - 그 즉시 사라지지만, 다른 변수가 받으면 이어집니다.

---

### GPT 피드백

1. 해당 라인까지라는 말은 굉장히 모호함. 전체 표현식까지 유효함

2. lvalue reference도, rvalue reference도 임시객체의 생명주기를 연장함

3. 값에 저장하거나, 참조에 바인딩해야 연장됨

> 전체표현식: `;`이 끝나는 지점
{: .prompt-info }

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 표현식 평가 과정에서 잠시 생성되는 이름 없는 객체입니다.
2. 연산 결과, 함수 반환값, 타입 변환 과정에서 생성됩니다.

3. 해당 임시 객체가 포함된 전체 표현식이 끝날 때까지입니다.
4. 불필요한 자원 점유를 최소화하기 위해서입니다.

5. 참조가 유효한 동안 임시 객체의 수명이 연장됩니다.
6. rvalue reference에 바인딩되어도 수명은 참조의 스코프까지 연장됩니다.
7. 해당 표현식이 끝나는 시점에 즉시 소멸됩니다.

8. 함수 호출이 끝날 때까지 유효합니다.
9. 복사 생략(RVO) 또는 반환 객체의 수명 규칙에 따라 관리됩니다.

10. std::move는 수명에 영향을 주지 않습니다.
11. 임시 객체는 이동 생성자의 주요 대상입니다.

12. 임시 객체에 대한 참조나 포인터를 오래 사용하려는 경우입니다.
13. 필요 시 값을 저장하거나 참조 수명 연장을 명확히 합니다.

14. 임시 객체는 표현식 종료 시 소멸되며, 참조에 바인딩되면 수명이 연장됩니다.

</div>
</details>

## 🧠 05. virtual / vtable / override / final

### ✅ virtual 기본 개념

1. C++에서 virtual 키워드는 무엇을 의미하나요?

    - 해당 함수를 가상함수로 지정하겠다는 키워드입니다. 가상함수가 되면 기반클래스 포인터로 관리하고 있어도 가상함수를 호출하면 가장 마지막으로 override 된 함수가 호출됩니다.

2. virtual 함수가 필요한 이유는 무엇인가요?

    - 함수의 동적 바인딩, 다형성을 사용하기 위해 필요합니다.

### ✅ virtual 동적 바인딩 / 다형성

1. virtual 함수가 없으면 어떤 문제가 발생하나요?

    - virtual 함수가 없으면 다형성을 사용하지 못합니다. 기반클래스 포인터로 관리하는 객체들의 함수가 전부 기반 클래스의 함수로 호출되게 됩니다.

2. 정적 바인딩과 동적 바인딩의 차이는 무엇인가요?

    - 정적 바인딩은 컴파일 시간에 함수 호출부와 구현부를 연결시킬 수 있는 함수들을 뜻합니다. 함수 오버로드나 템플릿 함수등이 정적 바인딩에 속합니다. 동적바인딩은 런타임에 해당 함수를 실행하는 주체에 따라 연결점이 달라지는것을 동적바인딩이라고 합니다. 가상함수가 이에 해당합니다.

3. 어떤 기준으로 호출될 함수가 결정되나요?

    - 동적바인딩은 원래 클래스 기준으로 가장 마지막에 재정의된 함수가 호출됩니다.

### ✅ virtual 상속 관계에서의 동작

1. 부모 클래스 포인터로 자식 객체를 가리킬 때 virtual 함수는 어떻게 동작하나요?

    - vptr을 통해 vtable에 접근하고, vtable에 맞는 함수로 연결됩니다.

2. override 키워드는 어떤 역할을 하나요?

    - override 키워드는 virtual 키워드가 붙은 함수를 재정의 할 때 사용하는 키워드입니다. 재정의 한다는 것을 명시적으로 나타냅니다.

3. virtual 키워드를 자식 클래스에도 다시 써야 하나요?

    - 써도 잘못된 동작을 하지는 않습니다. 그러나 의미상 virtual 키워드는 없애고, override 키워드만 두는 것이 바람직 합니다.

### ✅ virtual 소멸자와 virtual

1. 소멸자를 virtual로 만들어야 하는 이유는 무엇인가요?

    - virtual 키워드가 붙은 함수가 하나라도 존재하는 클래스라면 다형성을 이용하기 위함입니다. 기반클래스 포인터로 객체들을 관리하고 있을 때 객체들에 대한 소멸을 호출하면 기반클래스의 소멸자가 호출되게 되어 자식 클래스의 소멸자가 호출되지 않아 메모리 누수가 발생할 수 있습니다. 따라서 파생클래스의 소멸자가 호출되도록, 하나 이상의 virtual 함수가 존재한다면 소멸자에도 반드시 virtual 키워드를 붙이는 것을 권장합니다.

### ✅ virtual 구현 / 비용 관점

1. virtual 함수 호출에는 어떤 비용이 있나요?

    - vtable을 거쳐야 하는 포인터 연산이 중간에 필요합니다.

### ✅ virtual 설계 판단

1. 모든 함수에 virtual을 붙이면 안 되는 이유는 무엇인가요?

    - vtable을 구성해야하는 불필요한 메모리가 소요되고, 함수 호출에 연산이 추가로 필요해 성능이 떨어집니다.

2. 언제 virtual 함수를 사용하는 것이 적절한가요?

    - 동적 바인딩이 필요한 함수에만 사용하는 것이 적절할 수 있습니다.

### ✅ virtual 요약 질문

1. virtual 키워드의 역할을 한 문장으로 요약해보세요.

    - 동적 바인딩을 하는 함수로 만들어주는 키워드입니다.

### ✅ vtable 기본 개념

1. vtable이란 무엇인가요?

    - virtual 함수 호출부가 어떤 함수 구현부로 바인딩 되어야할지 정보를 갖고있는 테이블 입니다.

2. vtable은 왜 필요한가요?

    - 동적 바인딩이 발생했을 때 필요합니다.

### ✅ vtable 메모리 구조

1. vtable은 어디에 저장되나요?

    - 힙 영역에 저장됩니다.

### ✅ vtable 함수 호출 흐름

1. virtual 함수 호출 시 실제 호출 대상은 어떻게 결정되나요?

    - vptr을 통해 vtable에 접근하고, 연결된 함수가 호출됩니다.

2. 정적 바인딩과 vtable 기반 동적 바인딩의 차이는 무엇인가요?

    - 정적 바인딩은 함수의 구현부가 컴파일타임에 결정되고, 동적 바인딩은 런타임에 결정됩니다.

### ✅ vtable 상속 / 오버라이딩

1. 자식 클래스가 virtual 함수를 오버라이드하면 vtable은 어떻게 되나요?

    - vtable이 해당 함수를 자식 클래스에서 오버라이드 한 함수를 가리키게 됩니다.

### ✅ vtable 생성자 / 소멸자 연계

1. 생성자와 소멸자에서 virtual 호출이 위험한 이유는 무엇인가요?

    - vtable이 완성되지 않았을 수 있기 때문에 동적 바인딩이 정상적으로 이뤄지지 않을 수 있습니다.

### ✅ vtable 비용 / 설계 판단

1. vtable 기반 호출의 비용은 무엇인가요?

    - 포인터 역참조 연산이 필요합니다.

2. vtable 구조가 인라이닝에 불리한 이유는 무엇인가요?

    - 어떤 함수의 구현부가 바인딩 될 지 모르기 때문에 인라이닝이 불가능합니다.

### ✅ override / final 기본 개념

1. override 키워드는 무엇을 의미하나요?

    - virtaul로 선언된 함수를 현재 클래스에서 재정의 한다는 것을 명시하는 키워드입니다.

2. final 키워드는 무엇을 의미하나요?

    - 현재 클래스에서 해당 함수의 override를 더이상 하지 않겠다고 선언하는 키워드. 현재 클래스를 상속한 파생클래스들은 해당 함수를 재정의 할 수 없습니다.

### ✅ override 이해

1. override를 사용하면 어떤 문제가 방지되나요?

    - override 키워드 없이 재정의 한다면 재정의 한 함수가 사라졌을 때 단독 함수로 판정되면서 의도하지 않은 동작이 발생할 수 있습니다. 따라서 override 키워드를 붙여 원본 함수가 사라졌을 때 재정의에 실패했음을 컴파일러의 도움을 통해 알 수 있습니다.

### GPT 피드백

1. 실제 타입이라는 표현보다는 동적 타입이라는 표현이 좋음

2. 부모 타입의 함수를 호출하는 것이 아니라 정적 타입의 함수를 호출한다고 봐야 함

3. virtual 키워드는 동적 타입 기준으로 함수 바인딩을 하라는 키워드라고 생각하면 됨

4. vtable은 데이터 영역에 존재!!!

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

### ✅ virtual

1. 함수 호출을 객체의 실제 타입 기준으로 결정하도록 만드는 키워드입니다.
2. 상속 관계에서 다형성을 구현하기 위해 필요합니다.

3. 부모 타입 기준으로 함수가 호출되어 자식 동작이 무시될 수 있습니다.
4. 정적 바인딩은 컴파일 타임 결정, 동적 바인딩은 런타임 결정입니다.
5. 객체의 실제 타입과 vtable을 기준으로 결정됩니다.

6. 포인터 타입이 아니라 실제 객체 타입의 함수가 호출됩니다.
7. 의도한 오버라이딩을 컴파일 타임에 검증해줍니다.
8. 아니요, 부모에 virtual이 있으면 자식에서도 자동으로 virtual입니다.

9. 부모 포인터로 자식 객체를 삭제할 때 전체 소멸을 보장하기 위해서입니다.

10. vtable을 통해 함수 포인터를 간접 호출합니다.
11. 간접 호출로 인한 약간의 런타임 오버헤드가 있습니다.

12. 불필요한 간접 호출 비용과 설계 복잡도가 증가하기 때문입니다.
13. 기반 클래스 인터페이스로 다형적 사용이 필요할 때입니다.

14. virtual은 “호출을 타입이 아닌 객체 기준으로 하라”는 지시입니다.

### ✅ vtable

1. virtual 함수 주소들을 모아둔 테이블입니다.
2. 런타임에 실제 객체 타입 기준으로 함수를 호출하기 위해 필요합니다.

3. 일반적으로 프로그램의 정적 영역에 저장됩니다.
4. 객체는 자신의 클래스에 해당하는 vtable을 가리키는 포인터를 가집니다.
5. 객체 내부에 숨겨진 vtable을 가리키는 포인터입니다.

6. 객체의 vptr이 가리키는 vtable에서 함수 주소를 찾아 호출합니다.

7. 오버라이드된 함수 주소가 자식 클래스의 vtable에 들어갑니다.
8. 포인터 타입과 무관하게 vptr을 통해 자식 vtable이 사용됩니다.

9. 해당 시점에는 vptr이 완전히 설정되지 않았거나 변경 중이기 때문입니다.

10. 간접 호출로 인한 분기 예측 실패 가능성과 약간의 오버헤드입니다.
11. 호출 대상이 컴파일 타임에 확정되지 않기 때문입니다.

### ✅ override / final

1. 기반 클래스의 virtual 함수를 재정의한다는 의도를 명시하는 키워드입니다.
2. 더 이상 재정의하거나 상속할 수 없음을 명시하는 키워드입니다.

3. 함수 시그니처 불일치로 인한 의도치 않은 오버로딩을 방지합니다.

</div>
</details>

## 🧠 06. 템플릿 기본

### ✅ 기본 개념

1. C++ 템플릿이란 무엇인가요?

    - 타입에 따라 코드를 해당 타입에 맞춰 생성해주는 시스템입니다.

2. 템플릿을 사용하는 이유는 무엇인가요?

    - 타입이 다르지만 하는 동작은 동일할 때 코드 타이핑의 중복을 제거하고 유지보수성을 높입니다.

### ✅ 함수 템플릿

1. 함수 템플릿의 기본 문법은 어떻게 되나요?

    - typename 후 T같은 키워드로 변경될 타입에 대해 명명하고, 변경될 타입에 해당하는 지점에 T로 사용하면 됩니다.

2. 함수 템플릿은 언제 실제 함수로 생성되나요?

    - 함수 템플릿은 실제로 함수 사용을 한다고 판정되는 컴파일 타임에 해당 타입의 함수가 없으면 생성됩니다.

3. 템플릿 인자 타입 추론은 어떻게 이루어지나요?

    - <>안에 전달된 타입으로 추론이 이뤄집니다.

### ✅ 클래스 템플릿

1. 클래스 템플릿은 언제 인스턴스화되나요?

    - 컴파일 타임에 클래스를 사용하는 객체가 존재하는 순간 해당 클래스가 존재하지 않는다면 인스턴스화 됩니다.

### ✅ 템플릿 인자 종류

1. 템플릿 인자에는 어떤 종류가 있나요?

    - 타입과 비타입이 존재합니다.

2. 비타입(non-type) 템플릿 인자는 무엇인가요?

    - 특정한 상수나 값이 될 수 있습니다.

### ✅ 특수화 개념

1. 템플릿 특수화란 무엇인가요?

    - 특정 타입에 대해 구현부가 달라질 때 사용하게 됩니다.

### ✅ 컴파일 타임 관점

1. 템플릿이 컴파일 타임 다형성을 제공한다는 의미는 무엇인가요?

    - 타입에 따라 컴파일타임에 구현부가 달라지는 것을 의미합니다. 정적 다형성으로 분류할 수 있습니다.

### ✅ 설계 판단 / 요약

1. 템플릿 사용 시 단점은 무엇인가요?

    - 바이너리 파일이 비대해질 수 있습니다. 컴파일 에러가 사람이 알아보기 어려워집니다.

2. 템플릿 기본 개념을 한 문장으로 요약해보세요.

    - 타입에 따라 코드를 작성해주는 시스템입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 타입이나 값을 일반화해 코드 재사용성을 높이는 기능입니다.
2. 타입에 독립적인 코드를 작성해 중복을 줄이기 위해서입니다.

3. `template<typename T>` 형태로 정의합니다.
4. 실제 타입이 사용되는 시점에 인스턴스화됩니다.
5. 함수 호출 시 전달된 인자 타입으로 추론됩니다.

6. 해당 타입으로 객체를 생성할 때입니다.

7. 타입 인자와 비타입 인자가 있습니다.
8. 정수, 포인터 등 컴파일타임 상수 값을 받는 템플릿 인자입니다.

9. 특정 타입에 대해 다른 구현을 제공하는 것입니다.

10. 타입에 따라 다른 코드가 컴파일 타임에 선택된다는 의미입니다.

11. 컴파일 시간 증가와 에러 메시지 복잡성이 있습니다.
12. 템플릿은 타입을 일반화해 컴파일 타임에 코드를 생성하는 기능입니다.

</div>
</details>

## 🧠 07. 템플릿 특수화(template specialization)

### ✅ 기본 개념

1. 템플릿 특수화란 무엇인가요?

    - 특정 타입에 대해서만 다른 동작을 수행하고 싶을 때 사용하는 개념


### ✅ 종류 구분

1. 전체 특수화(full specialization)란 무엇인가요?

    - 모든 매개변수에 대해 특수화를 지정하는 것

2. 부분 특수화(partial specialization)란 무엇인가요?

    - 전체 특수화는 아니지만 최소 하나의 특수화를 지정하는 것

3. 함수 템플릿과 클래스 템플릿 중 부분 특수화가 가능한 것은 무엇인가요?

    - 둘 다 가능합니다.

### ✅ 동작 원리 / 선택 규칙

1. 컴파일러는 일반 템플릿과 특수화 중 무엇을 선택하나요?

    - 특수화가 가능하다면 특수화를 우선 선택합니다.

2. 여러 특수화가 있을 때 선택 기준은 무엇인가요?

    - 가장 구체적인 특수화를 선택합니다.

### ✅ 함수 템플릿 관련

1. 함수 템플릿에서 부분 특수화가 불가능한 이유는 무엇인가요?

    - 모르겠습니다.

2. 함수 템플릿에서 특수화 대신 주로 사용하는 방법은 무엇인가요?

    - 아예 구현을 할 수 있을 것 같습니다.

### ✅ 실무 / 설계 판단

1. 템플릿 특수화를 남용하면 어떤 문제가 생기나요?

    - 템플릿을 안쓰는 것과 같은 상태가 됩니다. 템플릿의 단점만 갖게되고 장점은 모두 잃게되는 문제가 발생합니다.

### ✅ 요약 질문

1. 템플릿 특수화를 한 문장으로 요약해보세요.

    - 많은 타입에 대해 같은 코드를 작성하려고 템플릿을 사용하지만, 소수의 특정 타입일 때에만 다른 동작을 하면 특수화를 사용할 수 있습니다.

---

### GPT 피드백

1. 함수는 부분 특수화를 사용할 수 없음. 클래스만 부분 특수화가 가능하고 함수는 부분 특수화할 수 없음. 함수가 부분 특수화가 된다고 가정하고 생각해보자. 함수의 오버로드 시스템을 구현할 때 함수 포인터가 다른 타입이 됨. 이걸 부분 특수화로 받아드리게 됨. 오버로드 시스템을 사용하기 위해 부분 특수화를 사용하지 않음. 부분 특수화 같은 기능을 사용하기 위해 SFINAE나 c++20에서 concepts라는 개념이 등장함

2. 가장 구체적인 템플릿이 우선 선택되며, 템플릿 인자가 더 많이 고정된 쪽을 선택함

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 특정 타입이나 조건에 대해 템플릿의 다른 구현을 제공하는 기능입니다.

2. 모든 템플릿 인자를 고정해 특정 타입에 대해 구현하는 것입니다.
3. 일부 템플릿 인자만 고정해 조건부 구현을 제공하는 것입니다.
4. 클래스 템플릿만 부분 특수화가 가능합니다.

5. 가장 구체적인(특수한) 템플릿이 우선 선택됩니다.
6. 템플릿 인자가 더 많이 고정된 쪽이 선택됩니다.

7. 함수 오버로딩 규칙과 충돌하기 때문입니다.
8. 함수 오버로딩이나 SFINAE, concepts를 사용합니다.

9. 코드 복잡도 증가와 가독성 저하가 발생합니다.

10. 템플릿 특수화는 “특정 타입에 대한 예외 규칙”입니다.

</div>
</details>

