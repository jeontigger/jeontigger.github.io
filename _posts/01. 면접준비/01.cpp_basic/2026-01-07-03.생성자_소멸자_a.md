---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: true
tags:
    [면접준비]
---

# 🧠 C++ 생성자 / 소멸자 호출 순서 1줄 모범답변

1. 생성자는 객체 생성 시, 소멸자는 객체가 파괴될 때(스코프 종료/삭제 시) 호출됩니다.
2. 올바른 초기화·자원 관리(RAII)와 예외 안전성을 보장하기 위해 순서가 중요합니다.
3. 같은 스코프의 자동 객체는 생성의 역순(LIFO)으로 소멸됩니다.

4. 지역 객체는 선언 지점에서 생성되고 해당 스코프를 벗어날 때 소멸됩니다.
5. 블록 안에서 나중에 생성된 객체부터 먼저 소멸됩니다.

6. 생성 시에는 (부모 →) 멤버(선언 순서) → 본문 순으로 초기화/실행됩니다.
7. 소멸 시에는 본문 → 멤버(선언 역순) → (부모) 순으로 파괴됩니다.
8. 실제 멤버 초기화 순서는 “멤버 선언 순서”이며 초기화 리스트에 적은 순서와 무관합니다.

9. 상속에서 생성은 부모 생성자 → 자식 생성자 순으로 호출됩니다.
10. 상속에서 소멸은 자식 소멸자 → 부모 소멸자 순으로 호출됩니다.
11. 부모 부분이 먼저 초기화되어야 자식이 그 상태에 의존해 안전하게 생성될 수 있습니다.
12. 자식이 보유한 자원을 먼저 정리한 뒤 부모 자원을 정리해야 안전하기 때문입니다.

13. 전역/네임스페이스 스코프 객체는 일반적으로 `main()` 시작 전에 초기화됩니다.
14. 전역/네임스페이스 스코프 객체는 프로그램 종료 과정에서 소멸됩니다.
15. 정적 지역 변수는 “최초로 제어 흐름이 도달할 때” 1회 초기화됩니다.
16. 서로 다른 번역 단위 간 정적 객체의 초기화 순서가 보장되지 않아 의존성이 깨질 수 있는 문제입니다.

17. 기반 클래스 포인터로 삭제할 때도 파생 클래스 소멸자가 호출되도록 하는 소멸자입니다.
18. `Base* p = new Derived; delete p;` 상황에서 전체 소멸(파생→기반)을 보장하기 위해 필요합니다.
19. 파생 소멸자가 호출되지 않아 자원 누수/정리 누락(UB 위험)이 발생할 수 있습니다.

20. 안전하지 않습니다(아직 파생 타입으로 완성되기 전이라 동적 디스패치 기대가 깨질 수 있습니다).
21. 소멸 중에는 파생 부분이 이미 파괴되어 가상 호출이 기대와 다르게 동작할 수 있습니다.
22. “생성은 의존성 순(부모→멤버→자식), 소멸은 그 역순”입니다.
