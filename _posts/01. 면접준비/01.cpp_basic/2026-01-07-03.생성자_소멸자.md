---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: true
tags:
    [면접준비]
---

# 🧠 C++ 생성자 / 소멸자 호출 순서 면접 질문 리스트

## ✅ 기본 개념

1. C++에서 생성자와 소멸자는 언제 호출되나요?

    - 객체가 생성될 때 생성자가 호출되고, 객체가 소멸할 때 소멸자가 호출됩니다. 스택변수는 해당 스택이 할당될 때,생성되고, 스택이 해제될 때 소멸됩니다. 힙 객체라면 new키워드로 할당될 때 생성자가 호출되고, delete 키워드로 해제될 때 소멸자가 호출됩니다.

2. 객체의 생성자와 소멸자 호출 순서는 왜 중요한가요?

    - 다른 객체가 생성되지 않은 객체를 참조한다거나, 해제된 객체를 참조할 수 있기 때문에 순서가 중요합니다.

3. 스코프 종료 시 어떤 순서로 소멸자가 호출되나요?

    - 생성된 순서 반대로 소멸자가 호출됩니다. 생성되는 순서는 선언된 순서에 맞춰 순차적으로 생성됩니다.

## ✅ 단일 객체 / 지역 객체

1. 지역 객체의 생성자와 소멸자 호출 시점을 설명해보세요.

    - 함수 스코프가 할당될 때 생성자가 호출되고, 함수 스코프가 해제될 때 소멸자가 호출됩니다.

2. 블록 스코프 안에서 여러 객체가 선언되었을 때 소멸 순서는 어떻게 되나요?

    - 생성 순서의 역순으로 소멸됩니다. 생성순서는 선언된 순서에 순차적으로 생성됩니다.

## ✅ 클래스 멤버 관련

1. 클래스에 멤버 객체가 있을 때 생성자 호출 순서는 어떻게 되나요?

    - 먼저 선언된 클래스 맴버 객체가 먼저 생성되면서 생성자가 먼저 호출됩니다.

2. 클래스에 멤버 객체가 있을 때 소멸자 호출 순서는 어떻게 되나요?

    - 생성된 순서 역순으로 해제되기 때문에 마지막에 선언된 멤버 객체부터 처음 선언된 멤버 객체 순서로 소멸자가 호출됩니다.

3. 멤버 초기화 리스트의 작성 순서와 실제 초기화 순서의 관계는 무엇인가요?

    - 초기화 리스트의 작성 순서를 실제 초기화 순서대로 작성하는 것이 바람직합니다.

## ✅ 상속 관계

1. 상속 관계에서 생성자 호출 순서는 어떻게 되나요?

    - 상속관계에서는 최상위 기반 클래스부터 생성자가 호출되어 가장 마지막에 파생한 클래스의 생성자 순으로 호출됩니다.

2. 상속 관계에서 소멸자 호출 순서는 어떻게 되나요?

    - 소멸자의 호출 순서는 생성자의 호출 순서와 반대로 이루어지며, 가장 마지막에 파생한 클래스의 소멸자부터 호출되고, 최상위 기반 클래스 순서대로 호출됩니다.

3. 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가요?

    - 객체의 메모리 구조상 기반 클래스의 크기만큼 할당되어야 파생클래스 메모리의 시작지점을 결정지을 수 있기 때문입니다.
    
4. 소멸자는 왜 자식 클래스부터 호출되나요?

    - 기반클래스부터 호출된다면, 파생클래스의 소멸자를 호출할 수 없기 때문에 자식클래스부터 호출됩니다.

## ✅ 정적(static) 객체

1. 전역 객체의 생성자 호출 시점은 언제인가요?

    - 전역 객체는 프로그램이 로드되면서 생성되고 생성자가 호출됩니다. 전역객체끼리는 파일이 다르다면 생성시점을 결정지을 수 없습니다.

2. 전역 객체의 소멸자 호출 시점은 언제인가요?

    - 프로그램이 종료되면서 소멸자가 호출됩니다.

3. 정적 지역 변수의 생성자 호출 시점은 언제인가요?

    - 해당 정적 지역 변수가 존재하는 함수가 처음 호출되는 시점에 생성자가 호출되고, 이후에 다시 호출될 때에는 호출되지 않습니다.

4. 정적 객체 초기화 순서 문제가 무엇인가요?

    - 정적 객체끼리는 파일이 달라지면 생성 시점을 제어할 수 없습니다. 따라서 정적 객체끼리 의존적인 형태를 사용한다면 문제가 발생할 수 있습니다.

## ✅ 가상 소멸자

1. 가상 소멸자란 무엇인가요?

    - virtual 키워드를 소멸자에 붙이는 것입니다. 

2. 상속 관계에서 소멸자를 가상으로 만들어야 하는 이유는 무엇인가요?

    - 가상 소멸자는 기반 클래스 포인터로 객체를 관리하고 있을 때 소멸하면 파생클래스의 소멸자부터 호출되어 정상적인 소멸이 이루어지도록 합니다. 

3. 가상 소멸자가 없을 때 발생할 수 있는 문제는 무엇인가요?

    - 기반클래스로 관리하고 있을 때 소멸하며 소멸자가 호출되면 기반클래스의 소멸자가 호출됩니다. 기반클래스의 소멸자로 기반 클래스의 힙 할당 객체들은 정상적으로 해제되겠지만, 파생 클래스에서 갖고있는 힙 할당 객체들은 파생클래스의 소멸자가 호출되지 않아 해제되지 않는 메모리 누수 문제가 발생할 수 있습니다.

## ✅ 실무 / 함정 질문

1. 생성자에서 가상 함수 호출은 안전한가요?

    - 의도한 동작이 이뤄지지 않습니다. vtable이 완성되지 않은 상태이며, 언어적 차원에서 virtual로 동작하지 않도록 막습니다.

2. 소멸자에서 가상 함수 호출은 어떤 문제가 있나요?

    - 소멸자도 마찬가지라 vtable이 사라지는 상태이기 때문에 언어적 차원에서 가상함수가 아닌 함수로 호출되게 됩니다.

3. 생성자/소멸자 호출 순서를 한 문장으로 요약해보세요.

    - 상속 관계에서 생성자 호출 순서는 기반->파생, 소멸자 호출 순서는 파생->기반 순서로 이루어집니다.

---

## GPT 피드백

1. 부모 생성자가 먼저 호출되어야 하는 이유는 기반 클래스의 불변식을 먼저 보장해야 하기 때문

2. 파생클래스 소멸자가 먼저 호출되어야 하는 이유는 파생클래스의 자원이 기반 클래스의 상태에 의존적일 수 있기 때문

---

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 🧠 1줄 모범 답변

1. 생성자는 객체 생성 시, 소멸자는 객체가 파괴될 때(스코프 종료/삭제 시) 호출됩니다.
2. 올바른 초기화·자원 관리(RAII)와 예외 안전성을 보장하기 위해 순서가 중요합니다.
3. 같은 스코프의 자동 객체는 생성의 역순(LIFO)으로 소멸됩니다.

4. 지역 객체는 선언 지점에서 생성되고 해당 스코프를 벗어날 때 소멸됩니다.
5. 블록 안에서 나중에 생성된 객체부터 먼저 소멸됩니다.

6. 생성 시에는 (부모 →) 멤버(선언 순서) → 본문 순으로 초기화/실행됩니다.
7. 소멸 시에는 본문 → 멤버(선언 역순) → (부모) 순으로 파괴됩니다.
8. 실제 멤버 초기화 순서는 “멤버 선언 순서”이며 초기화 리스트에 적은 순서와 무관합니다.

9. 상속에서 생성은 부모 생성자 → 자식 생성자 순으로 호출됩니다.
10. 상속에서 소멸은 자식 소멸자 → 부모 소멸자 순으로 호출됩니다.
11. 부모 부분이 먼저 초기화되어야 자식이 그 상태에 의존해 안전하게 생성될 수 있습니다.
12. 자식이 보유한 자원을 먼저 정리한 뒤 부모 자원을 정리해야 안전하기 때문입니다.

13. 전역/네임스페이스 스코프 객체는 일반적으로 `main()` 시작 전에 초기화됩니다.
14. 전역/네임스페이스 스코프 객체는 프로그램 종료 과정에서 소멸됩니다.
15. 정적 지역 변수는 “최초로 제어 흐름이 도달할 때” 1회 초기화됩니다.
16. 서로 다른 번역 단위 간 정적 객체의 초기화 순서가 보장되지 않아 의존성이 깨질 수 있는 문제입니다.

17. 기반 클래스 포인터로 삭제할 때도 파생 클래스 소멸자가 호출되도록 하는 소멸자입니다.
18. `Base* p = new Derived; delete p;` 상황에서 전체 소멸(파생→기반)을 보장하기 위해 필요합니다.
19. 파생 소멸자가 호출되지 않아 자원 누수/정리 누락(UB 위험)이 발생할 수 있습니다.

20. 안전하지 않습니다(아직 파생 타입으로 완성되기 전이라 동적 디스패치 기대가 깨질 수 있습니다).
21. 소멸 중에는 파생 부분이 이미 파괴되어 가상 호출이 기대와 다르게 동작할 수 있습니다.
22. “생성은 의존성 순(부모→멤버→자식), 소멸은 그 역순”입니다.

</div>
</details>