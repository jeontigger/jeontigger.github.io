---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: true
tags:
    [면접준비]
---

# 🧠 C++ 얕은 복사 vs 깊은 복사 면접 질문 리스트

## ✅ 기본 개념

1. 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이는 무엇인가요?

    - 얕은복사는 그냥 값을 그대로 복사하는 것입니다. 깊은 복사는 포인터가 가리키고 있는 지점의 힙할당 된 영역만큼 별도로 할당하며 새로 할당된 영역에 값 복사를 진행합니다.

2. 얕은 복사는 객체의 어떤 부분을 복사하나요?

    - 얕은복사는 변수가 담고있는 값을 그대로 복사합니다. 비트를 그대로 복사하기 때문에 비트복사라고도 합니다.

3. 깊은 복사는 객체의 어떤 부분을 복사하나요?

    - 객체가 갖고있는 힙 영역의 공간까지 복사합니다. 새롭게 공간을 할당하고, 해당영역과 동일한 새로운 공간이 생기도록 복사합니다.

4. 얕은 복사와 깊은 복사는 메모리 관점에서 어떻게 다른가요?

    - 얕은 복사는 새로운 공간이 필요하지 않지만, 깊은 복사는 새로운 메모리 영역이 할당됩니다.

## ✅ 문제 상황 이해

1. 얕은 복사에서 어떤 문제가 발생할 수 있나요?

    - 포인터를 얕은 복사할 때 의도하지 않은 동작이 발생할 수 있습니다. 포인터를 얕은 복사 하게 된다면 포인터에 담겨있는 즉, 가리키고 있는 변수의 주소가 복사되게 됩니다. 따라서 두 포인터 모두 같은 주소의 변수를 가리키게 됩니다. 한 포인터가 메모리를 수정, 삭제 하게 된다면 다른 포인터에서도 영향을 받는 의도하지 않은 동작이 발생할 수 있습니다.

2. 이중 해제(double free)는 왜 발생하나요?

    - 얕은 복사 또는, safe_delete를 하지 않았을 때 발생합니다. 해제하려는 자원을 가리키는 포인터가 자원이 해제됐는지 알지 못한채로 다시 한 번 해제를 시도할 때 발생합니다.

3. 댕글링 포인터(dangling pointer)는 어떤 경우에 발생하나요?

    - 댕글링 포인터도 마찬가지인 이유로 발생하게 됩니다. 해제된 포인터가 아직 유효한 포인터로 생각하고 접근하게 될 때 발생합니다.

4. 얕은 복사가 항상 잘못된 선택인가요?

    - 의도적으로 힙 영역에 있는 메모리를 동시에 가리키는 얕은복사가 필요할 때에도 있습니다. 예를들면 shared_ptr의 카운트를 관리하는 제어블록과 자원도 별도로 생성되어서는 안되기 때문에 의도적으로 얕은복사가 발생합니다.

## ✅ C++ 언어 관점

1. C++에서 기본 복사 생성자는 얕은 복사인가요?

    - 컴파일러가 생성하는 기본 복사 생성자는 얕은 복사를 진행합니다.

2. 포인터 멤버를 가진 클래스에서 기본 복사 생성자를 사용하면 어떤 문제가 생기나요?

    - 얕은 복사가 발생하여 메모리 관리 문제가 발생할 수 있습니다.

3. 깊은 복사를 구현하려면 어떤 함수들을 정의해야 하나요?

    - 복사생성자, 대입연산자, 소멸자를 정의해야 합니다.

4. 복사 생성자와 복사 대입 연산자의 역할 차이는 무엇인가요?

    - 복사 생성자는 새롭게 할당되는 객체에 사용되는 역할이고, 복사 대입 연산자는 이미 생성된 객체를 재사용하기 위해 사용되는 역할입니다. 메모리 할당이 발생하고, 메모리 할당이 발생하지 않는다는 특징이 있습니다.

## ✅ Rule of 3 / 5 / 0 연계

1. Rule of 3이란 무엇인가요?

    - 복사 생성자, 소멸자, 대입 연산자 중 하나라도 재정의가 필요하다면 세 가지 함수 모두 재정의를 해야한다는 법칙입니다.

2. Rule of 3은 얕은 복사/깊은 복사와 어떤 관련이 있나요?

    - 얕은복사로는 의도하지 않은 동작이 발생하여 깊은 복사가 필요할 때 복사 생성자나 대입 연산자를 사용하게 됩니다. 깊은 복사가 필요한 것은 힙 할당 영역에 대한 핸들링이 존재하기 때문에 소멸자에서 해제 요청이 반드시 필요합니다. 따라서 깊은 복사가 필요하다면 Rule of 3가 필요합니다.

3. Rule of 5가 등장한 이유는 무엇인가요?

    - 이동에 대한 재정의가 필요할 때 복사 생성자, 이동 생성자, 대입 연산자, 이동 연산자, 소멸자를 모두 재정의 해야한다는 법칙입니다. 이동에 대한 개념이 등장하면서 등장했습니다.

4. Rule of 0은 어떤 상황에서 권장되나요?

    RAII가 등장하면서 모든 책임을 관리 객체에 맡기는 것입니다.

## ✅ STL / 스마트 포인터

1. `std::vector`의 복사는 얕은 복사인가요, 깊은 복사인가요?

    - 깊은복사가 진행됩니다. 메모리가 별도로 할당됩니다.

2. `std::string`은 내부적으로 얕은 복사를 하나요?

    - string은 vector<char>라고 생각할 수 있습니다. vector는 내부적으로 깊은 복사를 진행합니다.

3. `std::unique_ptr`는 복사 시 어떻게 동작하나요?

    - unique_ptr은 복사가 delete되어있습니다. movem로 이동만 허용됩니다.

4. `std::shared_ptr`는 얕은 복사인가요, 깊은 복사인가요?

    - shared_ptr은 얕은 복사가 이루어져 같은 컨트롤 블록과 같은 자원을 가리키며 메모리를 아끼게됩니다.

## ✅ 실무 / 설계 판단

1. 언제 얕은 복사를 선택할 수 있나요?

    - 큰 메모리로 새로운 영역을 할당하기에 부담이 되면서, 수정이 발생하지 않는 자원인 경우에 얕은 복사로 관리할 수 있습니다.

2. 언제 깊은 복사가 반드시 필요한가요?

    - 수정이 발생하는 힙 자원의 경우에 깊은 복사가 필요합니다.

3. 성능 관점에서 얕은 복사와 깊은 복사의 차이는 무엇인가요?

    - 얕은 복사는 값 복사만 이루어지기 때문에 상당히 빠른 시간내에 이뤄집니다. 깊은 복사는 해당 포인터가 가리키는 자원의 모든 변수를 복사해야하고, 메모리 영역도 새롭게 할당해야 하므로 얕은 복사에 비하면 매우 느립니다.

4. 게임/엔진 개발에서 얕은 복사로 문제가 되는 사례를 예로 들어보세요.

    - 관리하고 있는 스프라이트가 의도하지 않은 얕은 복사된다면 다른 포인터가 해제할 때 같이 가리키고 있는 영역에서 스프라이트가 사라져 마젠타만 나온다거나 하는 문제가 발생할 수 있습니다.

## ✅ 함정 질문

1. memcpy로 객체를 복사하면 깊은 복사가 되나요?

    - memcpy는 비트 복사로 얕은 복사가 진행됩니다.

2. 얕은 복사와 참조(reference)는 같은 개념인가요?

    - 같은 개념이라고 볼 수 있습니다.

3. 복사 금지(delete copy)를 선택하는 이유는 무엇인가요?

    - unique_ptr같은 경우에 단일 소유권을 원칙으로 하는 객체이기 때문입니다.

4. 얕은 복사와 깊은 복사를 한 문장으로 요약해보세요.

    - 얕은 복사는 값을 그대로 복사하고, 깊은 복사는 메모리 영역을 새롭게 할당하여 복사합니다.

---

## GPT 피드백

1. 얕은복사 != 참조이다. 얕은복사는 말그대로 복사이고, 참조는 별칭으로 서로 다른개념임


<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 🧠 1줄 모범 답변

1. 얕은 복사는 포인터 값만 복사하고, 깊은 복사는 실제 데이터를 새로 복사합니다.
2. 얕은 복사는 멤버 변수의 값(주소)을 그대로 복사합니다.
3. 깊은 복사는 포인터가 가리키는 대상까지 새로 할당해 복사합니다.
4. 얕은 복사는 메모리를 공유하고, 깊은 복사는 메모리를 분리합니다.

5. 하나의 자원을 여러 객체가 공유해 이중 해제 문제가 발생할 수 있습니다.
6. 같은 메모리를 두 번 해제하려 할 때 발생합니다.
7. 이미 해제된 메모리를 참조할 때 발생합니다.
8. 읽기 전용 공유 등 의도가 명확하다면 사용할 수 있습니다.

9. 기본 복사 생성자는 멤버 단위 복사로 인해 얕은 복사입니다.
10. 여러 객체가 동일한 동적 메모리를 소유하게 됩니다.
11. 복사 생성자와 복사 대입 연산자를 직접 정의해야 합니다.
12. 복사 생성자는 새 객체 생성 시, 대입 연산자는 기존 객체에 복사할 때 호출됩니다.

13. 소멸자, 복사 생성자, 복사 대입 연산자를 함께 정의해야 한다는 규칙입니다.
14. 깊은 복사를 안전하게 구현하기 위해 필요합니다.
15. 이동语语语(이동 생성자/이동 대입)로 불필요한 깊은 복사를 줄이기 위해서입니다.
16. 자원 관리를 STL과 RAII에 맡길 수 있을 때 권장됩니다.

17. 내부 버퍼를 새로 할당하므로 깊은 복사입니다.
18. 현대 C++에서는 일반적으로 깊은 복사 또는 COW 제거 방식입니다.
19. 복사가 금지되며 소유권은 이동으로만 전달됩니다.
20. 포인터 값은 복사되지만 참조 카운트를 공유합니다.

21. 참조 의미의 공유가 의도된 경우입니다.
22. 객체 간 독립적인 소유권이 필요할 때입니다.
23. 얕은 복사는 빠르지만 안전성 문제가 있고, 깊은 복사는 비용이 큽니다.
24. 리소스 핸들을 얕게 복사해 수명 관리가 꼬이는 경우입니다.

25. 아닙니다, 단순 메모리 복사일 뿐 객체 의미의 깊은 복사가 아닙니다.
26. 아닙니다, 얕은 복사는 복사이고 참조는 별도의 개념입니다.
27. 자원의 단일 소유권을 강제하기 위해서입니다.
28. 얕은 복사는 주소만 공유하고, 깊은 복사는 데이터까지 복제합니다.

</div>
</details>