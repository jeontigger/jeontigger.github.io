---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비]
published: true
tags:
    [면접준비]
---

# cpp_basic

## 🧠 01. C++ Stack vs Heap

### ✅ 기본 개념

1. 스택(Stack) 메모리와 힙(Heap) 메모리의 차이를 설명해보세요.

    - 스택은 LIFO 구조의 메모리 영역으로 함수가 진행되면서 cpu에 의해 늘었다 줄었다 하고, 힙 영역은 프로그래머가 할당과 해제를 관리해야하는 메모리 영역으로 관리를 잘 하지 못했을 경우엔 메모리 문제가 발생할 수 있습니다.

2. 스택과 힙은 각각 어떤 용도로 사용되나요?

    - 스택은 컴파일시간에 계산될 수 있는 크기 이면서, 상대적으로 작은 크기들이 필요할 때 사용됩니다. 힙은 크기가 런타임에 동적으로 변경되어 컴파일 타임에 예측할 수 없거나, 스택의 최대 크기를 넘길 가능성이 있는 상대적으로 큰 크기들의 메모리를 할당하기 위해 사용합니다.

3. 함수 호출 시 스택에는 어떤 정보들이 저장되나요?

    - 함수 내의 지역변수들, 파라미터, 리턴 주소, 스택 프레임 크기 등이 저장됩니다.

4. 힙 메모리는 언제 사용해야 하나요?

    - 동적인 크기가 필요할 때, 그리고 큰 크기들의 메모리가 필요할 때 사용해야 합니다.

5. 스택 메모리는 왜 크기가 제한적인가요?

    - 멀티스레드 환경에서 스레드마다 스택 메모리를 별도로 갖게 되는데, 스레드마다 제한없는 크기를 갖는다면, 스레드에게 할당해주어야 하는 스택 주소 지점 결정이 어렵기 때문입니다.

6. 스택은 왜 LIFO 구조를 가지나요?

    - 함수 스택에 사용될 때 이전 스택의 메모리를 참고하지 못하도록 하는 등의 안정성과 함수 콜스택의 구조와 일치하기 때문에 LIFO구조를 선택했다고 생각합니다.

---

### ✅ 메모리 할당 / 해제

1. 스택 메모리의 할당과 해제는 누가 수행하나요?

    - cpu가 함수를 호출할 때 스택 메모리를 할당하고, 함수가 해제될 때 스택 메모리를 해제합니다.

2. 힙 메모리의 할당과 해제는 누가 책임지나요?

    - 힙 메모리는 프로그래머가 할당과 해제를 책임집니다.

3. C++에서 `new/delete`와 스택 변수의 차이는 무엇인가요?

    - new/delete는 스택 변수와 다르게 힙 영역에 메모리를 할당하는 연산자입니다.

4. 스택 변수와 힙 변수의 생명 주기 차이를 설명해보세요.

    - 스택변수는 함수가 호출될 때 생성되고 함수가 해제될 때 소멸됩니다. 힙 변수는 프로그래머가 할당할 때 생성되고, 프로그래머가 해제하기 전까지 소멸되지 않습니다. 프로그램 종료시 해제되지 않은 힙 메모리 변수들은 전부 해제됩니다.

5. 힙 메모리 사용 시 발생할 수 있는 문제에는 무엇이 있나요?

    - 메모리 누수, 더블 프리, 댕글링 포인터 등이 있습니다.

---

### ✅ 성능 및 구조

1. 스택 메모리가 힙보다 빠른 이유는 무엇인가요?

    - 스택 메모리는 연속된 메모리 구조를 가지고 있기 때문에 할당 가능한 영역을 찾아야하는 힙 메모리 영역보다는 과정이 하나 적고, 캐시 친화적이기 때문에 빠르게 됩니다.

2. 캐시 관점에서 스택과 힙의 차이를 설명해보세요.

    - 스택은 연속된 메모리 구조이고, 힙은 연속하지 않은 덩어리 방식의 메모리 할당 구조이기 때문에 캐시의 공간지역성적으로 스택이 유리합니다.

3. 스택 프레임(Stack Frame)이란 무엇인가요?

    - 스택 프레임이란 함수가 호출되면서 스택 메모리가 할당되는 하나의 덩어리를 이야기합니다. 스택 프레임에는 파라미터, 리턴 주소, 함수 스택 변수 등이 저장됩니다.

4. 함수 호출이 깊어질수록 스택에는 어떤 변화가 생기나요?

    - 스택이 점점 쌓이면서 스택의 제한에 도달한다면 스택 오버플로우 문제가 발생할 수 있습니다.

---

### ✅ 오류 및 문제 상황

1. 스택 오버플로우(Stack Overflow)는 언제 발생하나요?

    - 스택 프레임이 계속해서 쌓이다가 제한된 스택 메모리의 크기보다 많은 양의 메모리를 사용하려고 할 때 스택 오버플로우가 발생합니다.

2. 힙 오버플로우와 스택 오버플로우의 차이는 무엇인가요?

    - 스택 오버플로우는 주로 스택 변수에 큰 크기를 할당 했다거나, 재귀 함수가 계속 호출되는 문제로 발생합니다. 그러나 힙 오버플로우는 가상메모리에서 할당 가능한 메모리를 모두 사용했을 때 발생하게 됩니다.

3. 댕글링 포인터(Dangling Pointer)는 언제 발생하나요?

    - 댕글링 포인터는 포인터가 가리키고 있는 자원이 해제되었지만, 해제된지 모른채 가리키고 있는 포인터를 뜻합니다. 포인터가 가리키고 있는 자원이 해제될 때 nullptr로 초기화를 하지 않았을 때와 또, 같은 자원을 가리키고 있는 또다른 포인터가 해제된 사실을 알지 못할 때 발생합니다.

4. 메모리 누수는 왜 힙에서 주로 발생하나요?

    - 스택 메모리에서는 함수 호출 흐름에 따라서 cpu가 할당과 해제를 하기 때문에 메모리 누수가 발생하지 않습니다. 프로그래머가 할당과 해제를 책임져야하는 힙 메모리 영역에서 해제하지 않았을 경우에 발생합니다.

---

### ✅ C++ 언어 관점

1. 지역 변수는 항상 스택에 할당되나요?

    - 함수 내의 static 변수는 지역변수처럼 생겼지만, data영역에 할당됩니다.

2. 전역 변수와 static 변수는 어디에 할당되나요?

    - data 영역에 할당됩니다. default값이나 초기화되지 않은 전역과 static 변수들은 bss 영역에 할당됩니다.

3. 스마트 포인터는 스택과 힙 중 어디를 사용하나요?

    - 스택을 사용합니다. 스택 변수의 라이프 사이클에 의존하여 자원을 관리하는 기법입니다.

4. RAII 패턴은 스택과 어떤 관련이 있나요?

    - 스택 변수들은 함수가 해제될 때 변수의 생명 주기가 해제됩니다. 이 때 자원의 생명 주기를 스택 변수에게 맡기는 것입니다.

---

### ✅ 멀티스레드 관점

1. 멀티스레드 환경에서 스택과 힙은 어떻게 관리되나요?

    - 멀티스레드에서 스택은 스레드 마다 할당되게 됩니다. 따라서 스레드별 스택은 독립적으로 관리됩니다. 그러나 힙은 모든 스레드가 공유되기 때문에 레이스 컨디션에 유의해야 합니다.

2. 스택 메모리는 스레드 안전한가요?

    - 네

---

### ✅ 실무 판단

1. 객체를 스택에 둘지 힙에 둘지 어떻게 판단하나요?

    - 저는 현재 스택 메모리가 해제되어도 필요하거나, 크기를 예측할 수 없을 때 힙에 두고, 스택 메모리와 함께 생명주기가 일치하다면 스택에 둡니다.

2. 대용량 배열은 왜 힙에 할당해야 하나요?

    - 스택 메모리의 제한이 크지 않기 때문에 대용량 배열은 힙에 할당해야 합니다.

3. 게임/엔진 개발에서 스택과 힙 선택이 중요한 이유는 무엇인가요?

    - 스택은 캐시 친화적이라 빠르고 좋지만 적은 양의 메모리를 사용할 수 있고, 힙은 큰 용량을 사용할 수 있지만 스택에 비해 느리고, 관리에 유의해야하기 때문입니다.

---

### ✅ 함정 질문

1. `std::vector`는 스택에 있나요, 힙에 있나요?

    - vector 자체는 스택에 있습니다. vector가 관리하는 자원은 힙에 있습니다.

2. 스택에 할당된 객체의 주소를 반환하면 어떤 문제가 발생하나요?

    - 주소는 정상적으로 반환되지만, 댕글링 포인터가 됩니다.


<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 스택은 자동 관리되는 고정 크기 메모리이고, 힙은 런타임에 동적 할당되는 메모리입니다.
2. 스택은 짧은 생명 주기의 지역 변수에, 힙은 긴 생명 주기의 동적 객체에 사용됩니다.
3. 함수 인자, 지역 변수, 반환 주소, 이전 스택 프레임 정보가 저장됩니다.
4. 객체의 생명 주기가 함수 범위를 넘거나 크기를 런타임에 결정해야 할 때 사용합니다.
5. 스택은 스레드 생성 시 고정 크기로 할당되기 때문입니다.
6. 함수 호출과 반환이 중첩 구조이기 때문에 LIFO 구조를 가집니다.

7. 컴파일러가 함수 진입과 종료 시 자동으로 수행합니다.
8. 프로그래머가 직접 관리하며 C++에서는 `new/delete`로 처리합니다.
9. 스택 변수는 자동 소멸되고, `new`로 생성한 객체는 명시적으로 해제해야 합니다.
10. 스택 변수는 스코프 기반이고, 힙 변수는 해제 시점까지 유지됩니다.
11. 메모리 누수, 댕글링 포인터, 이중 해제, 단편화 문제가 발생할 수 있습니다.

12. 포인터 이동만으로 할당과 해제가 가능해 오버헤드가 적기 때문입니다.
13. 스택은 연속 메모리로 캐시 효율이 높고, 힙은 분산될 수 있습니다.
14. 함수 호출 시 생성되는 실행 단위 메모리 구조입니다.
15. 스택 프레임이 누적되며 과도하면 스택 오버플로우가 발생합니다.

16. 재귀가 깊거나 스택에 큰 객체를 반복 할당할 때 발생합니다.
17. 스택은 스택 크기 초과, 힙은 가용 메모리 부족 상황입니다.
18. 해제된 메모리를 계속 참조할 때 발생합니다.
19. 자동 해제가 되지 않아 해제를 놓치기 쉽기 때문입니다.

20. 대부분 스택이지만 컴파일러 최적화로 달라질 수 있습니다.
21. 데이터 영역(Data Segment)에 할당됩니다.
22. 스마트 포인터 객체는 스택에, 관리 대상은 힙에 있습니다.
23. 스택 객체 소멸 시점에 자원을 자동 해제하도록 합니다.

24. 각 스레드는 독립적인 스택을 가지고 힙은 공유합니다.
25. 스레드별로 분리되어 있어 기본적으로 안전합니다.

26. 생명 주기, 크기, 공유 여부, 성능 요구사항을 기준으로 판단합니다.
27. 스택 크기 제한으로 인한 오버플로우를 방지하기 위함입니다.
28. 프레임 성능과 메모리 안정성에 직접적인 영향을 주기 때문입니다.

29. 컨테이너 객체는 스택에, 내부 데이터는 힙에 존재합니다.
30. 함수 종료 후 메모리가 해제되어 댕글링 포인터가 됩니다.

</div>
</details>

## 🧠 02. RAII (Resource Acquisition Is Initialization)

---

### ✅ RAII 기본 개념

1. RAII란 무엇인가요?

    - RAII란 자원의 관리를 객체의 생명주기에 맡기는 것입니다.

2. RAII가 해결하려는 문제는 무엇인가요?

    - 생성 후 초기화나, 해제 전 호출해야 하는 함수들을 실수나 예외에 의해 호출되지 않는 상황을 방지하기 위함입니다.

3. RAII는 C++의 어떤 특징을 기반으로 동작하나요?

    - 객체의 생성자에서 초기화를, 소멸자에서 해제를 하게 됩니다. 

5. RAII는 왜 C++에서 중요한 개념인가요?

    - raw pointer나 mutex등을 자유롭게 제어할 수 있기 때문에 문제들이 발생할 수 있습니다. 이를 방지하기 위한 기법으로 C++에서 중요합니다.

---

### ✅ 생성자 / 소멸자 관점

1. RAII에서 생성자의 역할은 무엇인가요?

    - 자원 획득 및 초기화입니다.

2. RAII에서 소멸자의 역할은 무엇인가요?

    - 해제입니다.

3. 생성자와 소멸자가 호출되는 시점은 언제인가요?

    - 생성자는 RAII로 자원을 관리하는 객체가 생성될 때 호출되고, 관리 객체가 해제될 때 소멸자가 호출됩니다.

4. RAII에서 예외(Exception)는 어떻게 처리되나요?

    - 스택에 생성한 RAII 객체라면 스택 언와인딩이 발생해도 스택이 해제되며 동시에 메모리에서 해제되며 소멸자가 호출됩니다.

---

### ✅ 스택 / 힙과의 관계

1. RAII는 스택과 어떤 관계가 있나요?

    - 스택에 생성하여 스택 객체의 생명주기에 자원을 묶을 수 있습니다.

2. RAII는 힙 메모리와도 함께 사용할 수 있나요?

    - RAII는 힙 메모리에 있는 자원을 관리할수도, RAII 객체 자체가 힙 메모리에 있을수도 있습니다.

3. RAII가 스택 기반 관리라고 불리는 이유는 무엇인가요?

    - RAII를 힙에 할당하는것은 가능은하지만, RAII 객체를 관리하는 또 다른 객체가 필요해지기 때문에 RAII 목적과 다르게 사용되는 것입니다. 따라서 RAII는 보통 스택에 생성하고, 스택 객체의 생명주기에 자원을 바인딩하기 때문에 스택기반관리라고 불리게 됩니다.

---

### ✅ 실무 예제 이해

1. 파일 핸들을 RAII로 관리한다는 것은 무엇을 의미하나요?

    - 파일 오픈 후 파일 포인터의 사용을 마치면 파일을 닫아주어야 하는데, 이를 RAII에 맡겨 소멸자에서 파일을 닫아주는 것을 의미합니다.

2. 뮤텍스(mutex)를 RAII로 관리하면 어떤 장점이 있나요?

    - 대표적으론 lock_gard나 unique_lock이 있습니다. lock을 호출하면 반드시 unlock을 해야 데드락이 발생하지 않는데, unlock을 객체 생명주기의 소멸자에 맞춰 반드시 unlock이 호출되게 됩니다.

3. 스마트 포인터는 RAII 개념을 어떻게 활용하나요?

    - raw pointer의 해제를 소멸자에서 관리합니다. shared_ptr같은 경우 여러 RAII가 가리킬 수 있는데, 내부적으로 카운트를 관리하여 카운트가 0이 될 때 메모리를 해제하는 방식을 사용합니다.

---

### ✅ 복사 / 이동과 RAII

1. RAII 객체를 복사하면 어떤 문제가 발생할 수 있나요?

    - 일반적인 RAII를 복사한다면 가리키고 있는 자원을 관리하는 객체가 2가지가 됩니다. 한 객체가 소멸하며 자원을 해제했을 때 다른 객체는 자원의 해제여부를 모르기때문에 잘못된 접근이 발생할 수 있습니다.

2. 이동 생성자(move constructor)는 RAII에서 왜 중요한가요?

    - 복사가 불가능하기 때문에 자원에 대한 소유권을 이전하는 방식을 사용하게 됩니다. 소유권 이전을 위해 우측값을 받아 넘겨주어야하기 때문에 이동생성자가 필요합니다.

---

### ✅ 오류 및 설계 판단

1. RAII를 사용하지 않으면 어떤 문제가 발생할 수 있나요?

    - 자원에 대한 해제가 안될수도, 해제가 됐는데 접근을 하게될 수도 있습니다.

2. RAII와 `try-catch` 기반 자원 해제 방식의 차이는 무엇인가요?

    - try-catch는 느리고 모든 자원에 대한 대응이 안될 수 있기때문에 RAII를 사용하는 것이 권장됩니다.

3. RAII를 적용할 때 주의해야 할 점은 무엇인가요?

    - 복사 정책에서 메모리 관리를 주의해야 합니다.

---

### ✅ 면접 단골 함정 질문

1. RAII는 GC와 어떤 차이가 있나요?

    - RAII는 하나의 자원에 대해서 관리하는 객체이고, GC는 모든 객체를 추적하며 사용하지 않는다고 생각했을 때 자원을 해제하는 관리객체입니다.

2. RAII 객체를 전역 변수로 두는 것은 괜찮을까요?

    - 관리만 잘 한다면 괜찮겠지만, 관리를 잘 한다는 이상적인 환경에선 RAII조차 필요 없기 때문에, RAII를 사용한다면 전역변수로 두기보다는 스택에 두는 것을 권장합니다.

3. RAII 패턴과 스마트 포인터의 차이는 무엇인가요?

    - 스마트 포인터는 RAII 패턴 중 대표적인 예 라고 할 수 있습니다.

4. RAII는 메모리 관리 기법인가요?

    - 메모리를 자원으로써 관리한다면 메모리 관리 기법이라고 볼 수 있습니다. 그러나 메모리 관리 뿐만 아니라 mutex나 file 포인터를 관리하기도 합니다.

5. RAII를 한 문장으로 요약해보세요.

    - RAII는 자원의 관리를 객체의 생명주기와 연결시키는 패러다임입니다.


### GPT 피드백

1. RAII가 힙에도 있을 수 있다는 사실은 크게 중요하지 않음

2. RAII는 결정적 소멸, GC는 비결정적 소멸임.

> 결정적 소멸: 해제지점이 확실함
{: .prompt-info }

> 비결정적 소멸: 해제가 언제 이뤄지는지 알 수 없음
{: .prompt-info }

3. 전역 RAII는 전역 객체라 초기화 순서 문제가 발생할 수 있음

---

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. RAII는 자원의 획득과 해제를 객체의 생명 주기에 묶는 C++ 자원 관리 기법입니다.
2. 자원 누수와 예외 상황에서의 해제 누락 문제를 해결하기 위해 사용됩니다.
3. 객체가 생성될 때 자원을 획득하고 소멸될 때 자원을 해제한다는 의미입니다.
4. 객체의 생성자와 소멸자가 자동 호출되는 C++의 스코프 기반 생명 주기를 활용합니다.
5. 예외 안전성과 코드 안정성을 크게 향상시키기 때문입니다.

---

1. 생성자는 자원을 안전하게 획득하고 초기화하는 역할을 합니다.
2. 소멸자는 객체가 스코프를 벗어날 때 자원을 반드시 해제합니다.
3. 생성자는 객체 생성 시, 소멸자는 스코프 종료 시 자동으로 호출됩니다.
4. 예외가 발생해도 스택 언와인딩 과정에서 소멸자가 호출되어 자원이 해제됩니다.

---

1. RAII는 스택 객체의 자동 소멸 특성을 기반으로 동작합니다.
2. 힙 자원도 RAII 객체로 감싸면 안전하게 관리할 수 있습니다.
3. 스코프 종료 시 자동으로 소멸자가 호출되기 때문입니다.

---

1. 파일 열기와 닫기를 객체 생성과 소멸에 묶어 관리하는 것입니다.
2. 락과 언락이 자동으로 보장되어 데드락과 누락을 방지할 수 있습니다.
3. 스마트 포인터는 소멸자에서 `delete`를 호출해 동적 메모리를 관리합니다.

---

1. 자원이 중복 해제되는 문제가 발생할 수 있습니다.
2. 소유권을 안전하게 이전하기 위해 이동 생성자가 필요합니다.

---

1. 예외 상황에서 자원 누수와 해제 누락이 발생할 수 있습니다.
2. RAII는 스코프 종료만으로 자원 해제를 보장하지만 try-catch는 누락 위험이 있습니다.
3. 복사/이동 정책과 소유권을 명확히 설계해야 합니다.

---

1. RAII는 결정적 소멸을 제공하지만 GC는 비결정적입니다.
2. 전역 RAII 객체는 초기화/종료 순서 문제를 일으킬 수 있습니다.
3. RAII는 개념이고 스마트 포인터는 이를 구현한 도구 중 하나입니다.
4. 메모리뿐 아니라 모든 종류의 자원 관리 기법입니다.
5. 자원을 객체 생명 주기에 묶어 자동으로 관리하는 패턴입니다.

</div>
</details>

## 🧠 03. 생성자 / 소멸자 호출 순서

### ✅ 기본 개념

1. C++에서 생성자와 소멸자는 언제 호출되나요?

    - 객체가 생성될 때 생성자가 호출되고, 객체가 소멸할 때 소멸자가 호출됩니다. 스택변수는 해당 스택이 할당될 때,생성되고, 스택이 해제될 때 소멸됩니다. 힙 객체라면 new키워드로 할당될 때 생성자가 호출되고, delete 키워드로 해제될 때 소멸자가 호출됩니다.

2. 객체의 생성자와 소멸자 호출 순서는 왜 중요한가요?

    - 다른 객체가 생성되지 않은 객체를 참조한다거나, 해제된 객체를 참조할 수 있기 때문에 순서가 중요합니다.

3. 스코프 종료 시 어떤 순서로 소멸자가 호출되나요?

    - 생성된 순서 반대로 소멸자가 호출됩니다. 생성되는 순서는 선언된 순서에 맞춰 순차적으로 생성됩니다.

### ✅ 단일 객체 / 지역 객체

1. 지역 객체의 생성자와 소멸자 호출 시점을 설명해보세요.

    - 함수 스코프가 할당될 때 생성자가 호출되고, 함수 스코프가 해제될 때 소멸자가 호출됩니다.

2. 블록 스코프 안에서 여러 객체가 선언되었을 때 소멸 순서는 어떻게 되나요?

    - 생성 순서의 역순으로 소멸됩니다. 생성순서는 선언된 순서에 순차적으로 생성됩니다.

### ✅ 클래스 멤버 관련

1. 클래스에 멤버 객체가 있을 때 생성자 호출 순서는 어떻게 되나요?

    - 먼저 선언된 클래스 맴버 객체가 먼저 생성되면서 생성자가 먼저 호출됩니다.

2. 클래스에 멤버 객체가 있을 때 소멸자 호출 순서는 어떻게 되나요?

    - 생성된 순서 역순으로 해제되기 때문에 마지막에 선언된 멤버 객체부터 처음 선언된 멤버 객체 순서로 소멸자가 호출됩니다.

3. 멤버 초기화 리스트의 작성 순서와 실제 초기화 순서의 관계는 무엇인가요?

    - 초기화 리스트의 작성 순서를 실제 초기화 순서대로 작성하는 것이 바람직합니다.

### ✅ 상속 관계

1. 상속 관계에서 생성자 호출 순서는 어떻게 되나요?

    - 상속관계에서는 최상위 기반 클래스부터 생성자가 호출되어 가장 마지막에 파생한 클래스의 생성자 순으로 호출됩니다.

2. 상속 관계에서 소멸자 호출 순서는 어떻게 되나요?

    - 소멸자의 호출 순서는 생성자의 호출 순서와 반대로 이루어지며, 가장 마지막에 파생한 클래스의 소멸자부터 호출되고, 최상위 기반 클래스 순서대로 호출됩니다.

3. 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가요?

    - 객체의 메모리 구조상 기반 클래스의 크기만큼 할당되어야 파생클래스 메모리의 시작지점을 결정지을 수 있기 때문입니다.
    
4. 소멸자는 왜 자식 클래스부터 호출되나요?

    - 기반클래스부터 호출된다면, 파생클래스의 소멸자를 호출할 수 없기 때문에 자식클래스부터 호출됩니다.

### ✅ 정적(static) 객체

1. 전역 객체의 생성자 호출 시점은 언제인가요?

    - 전역 객체는 프로그램이 로드되면서 생성되고 생성자가 호출됩니다. 전역객체끼리는 파일이 다르다면 생성시점을 결정지을 수 없습니다.

2. 전역 객체의 소멸자 호출 시점은 언제인가요?

    - 프로그램이 종료되면서 소멸자가 호출됩니다.

3. 정적 지역 변수의 생성자 호출 시점은 언제인가요?

    - 해당 정적 지역 변수가 존재하는 함수가 처음 호출되는 시점에 생성자가 호출되고, 이후에 다시 호출될 때에는 호출되지 않습니다.

4. 정적 객체 초기화 순서 문제가 무엇인가요?

    - 정적 객체끼리는 파일이 달라지면 생성 시점을 제어할 수 없습니다. 따라서 정적 객체끼리 의존적인 형태를 사용한다면 문제가 발생할 수 있습니다.

### ✅ 가상 소멸자

1. 가상 소멸자란 무엇인가요?

    - virtual 키워드를 소멸자에 붙이는 것입니다. 

2. 상속 관계에서 소멸자를 가상으로 만들어야 하는 이유는 무엇인가요?

    - 가상 소멸자는 기반 클래스 포인터로 객체를 관리하고 있을 때 소멸하면 파생클래스의 소멸자부터 호출되어 정상적인 소멸이 이루어지도록 합니다. 

3. 가상 소멸자가 없을 때 발생할 수 있는 문제는 무엇인가요?

    - 기반클래스로 관리하고 있을 때 소멸하며 소멸자가 호출되면 기반클래스의 소멸자가 호출됩니다. 기반클래스의 소멸자로 기반 클래스의 힙 할당 객체들은 정상적으로 해제되겠지만, 파생 클래스에서 갖고있는 힙 할당 객체들은 파생클래스의 소멸자가 호출되지 않아 해제되지 않는 메모리 누수 문제가 발생할 수 있습니다.

### ✅ 실무 / 함정 질문

1. 생성자에서 가상 함수 호출은 안전한가요?

    - 의도한 동작이 이뤄지지 않습니다. vtable이 완성되지 않은 상태이며, 언어적 차원에서 virtual로 동작하지 않도록 막습니다.

2. 소멸자에서 가상 함수 호출은 어떤 문제가 있나요?

    - 소멸자도 마찬가지라 vtable이 사라지는 상태이기 때문에 언어적 차원에서 가상함수가 아닌 함수로 호출되게 됩니다.

3. 생성자/소멸자 호출 순서를 한 문장으로 요약해보세요.

    - 상속 관계에서 생성자 호출 순서는 기반->파생, 소멸자 호출 순서는 파생->기반 순서로 이루어집니다.

---

### GPT 피드백

1. 부모 생성자가 먼저 호출되어야 하는 이유는 기반 클래스의 불변식을 먼저 보장해야 하기 때문

2. 파생클래스 소멸자가 먼저 호출되어야 하는 이유는 파생클래스의 자원이 기반 클래스의 상태에 의존적일 수 있기 때문

---

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 생성자는 객체 생성 시, 소멸자는 객체가 파괴될 때(스코프 종료/삭제 시) 호출됩니다.
2. 올바른 초기화·자원 관리(RAII)와 예외 안전성을 보장하기 위해 순서가 중요합니다.
3. 같은 스코프의 자동 객체는 생성의 역순(LIFO)으로 소멸됩니다.

4. 지역 객체는 선언 지점에서 생성되고 해당 스코프를 벗어날 때 소멸됩니다.
5. 블록 안에서 나중에 생성된 객체부터 먼저 소멸됩니다.

6. 생성 시에는 (부모 →) 멤버(선언 순서) → 본문 순으로 초기화/실행됩니다.
7. 소멸 시에는 본문 → 멤버(선언 역순) → (부모) 순으로 파괴됩니다.
8. 실제 멤버 초기화 순서는 “멤버 선언 순서”이며 초기화 리스트에 적은 순서와 무관합니다.

9. 상속에서 생성은 부모 생성자 → 자식 생성자 순으로 호출됩니다.
10. 상속에서 소멸은 자식 소멸자 → 부모 소멸자 순으로 호출됩니다.
11. 부모 부분이 먼저 초기화되어야 자식이 그 상태에 의존해 안전하게 생성될 수 있습니다.
12. 자식이 보유한 자원을 먼저 정리한 뒤 부모 자원을 정리해야 안전하기 때문입니다.

13. 전역/네임스페이스 스코프 객체는 일반적으로 `main()` 시작 전에 초기화됩니다.
14. 전역/네임스페이스 스코프 객체는 프로그램 종료 과정에서 소멸됩니다.
15. 정적 지역 변수는 “최초로 제어 흐름이 도달할 때” 1회 초기화됩니다.
16. 서로 다른 번역 단위 간 정적 객체의 초기화 순서가 보장되지 않아 의존성이 깨질 수 있는 문제입니다.

17. 기반 클래스 포인터로 삭제할 때도 파생 클래스 소멸자가 호출되도록 하는 소멸자입니다.
18. `Base* p = new Derived; delete p;` 상황에서 전체 소멸(파생→기반)을 보장하기 위해 필요합니다.
19. 파생 소멸자가 호출되지 않아 자원 누수/정리 누락(UB 위험)이 발생할 수 있습니다.

20. 안전하지 않습니다(아직 파생 타입으로 완성되기 전이라 동적 디스패치 기대가 깨질 수 있습니다).
21. 소멸 중에는 파생 부분이 이미 파괴되어 가상 호출이 기대와 다르게 동작할 수 있습니다.
22. “생성은 의존성 순(부모→멤버→자식), 소멸은 그 역순”입니다.

</div>
</details>

## 🧠 04. 얕은 복사 vs 깊은 복사

### ✅ 기본 개념

1. 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이는 무엇인가요?

    - 얕은복사는 그냥 값을 그대로 복사하는 것입니다. 깊은 복사는 포인터가 가리키고 있는 지점의 힙할당 된 영역만큼 별도로 할당하며 새로 할당된 영역에 값 복사를 진행합니다.

2. 얕은 복사는 객체의 어떤 부분을 복사하나요?

    - 얕은복사는 변수가 담고있는 값을 그대로 복사합니다. 비트를 그대로 복사하기 때문에 비트복사라고도 합니다.

3. 깊은 복사는 객체의 어떤 부분을 복사하나요?

    - 객체가 갖고있는 힙 영역의 공간까지 복사합니다. 새롭게 공간을 할당하고, 해당영역과 동일한 새로운 공간이 생기도록 복사합니다.

4. 얕은 복사와 깊은 복사는 메모리 관점에서 어떻게 다른가요?

    - 얕은 복사는 새로운 공간이 필요하지 않지만, 깊은 복사는 새로운 메모리 영역이 할당됩니다.

### ✅ 문제 상황 이해

1. 얕은 복사에서 어떤 문제가 발생할 수 있나요?

    - 포인터를 얕은 복사할 때 의도하지 않은 동작이 발생할 수 있습니다. 포인터를 얕은 복사 하게 된다면 포인터에 담겨있는 즉, 가리키고 있는 변수의 주소가 복사되게 됩니다. 따라서 두 포인터 모두 같은 주소의 변수를 가리키게 됩니다. 한 포인터가 메모리를 수정, 삭제 하게 된다면 다른 포인터에서도 영향을 받는 의도하지 않은 동작이 발생할 수 있습니다.

2. 이중 해제(double free)는 왜 발생하나요?

    - 얕은 복사 또는, safe_delete를 하지 않았을 때 발생합니다. 해제하려는 자원을 가리키는 포인터가 자원이 해제됐는지 알지 못한채로 다시 한 번 해제를 시도할 때 발생합니다.

3. 댕글링 포인터(dangling pointer)는 어떤 경우에 발생하나요?

    - 댕글링 포인터도 마찬가지인 이유로 발생하게 됩니다. 해제된 포인터가 아직 유효한 포인터로 생각하고 접근하게 될 때 발생합니다.

4. 얕은 복사가 항상 잘못된 선택인가요?

    - 의도적으로 힙 영역에 있는 메모리를 동시에 가리키는 얕은복사가 필요할 때에도 있습니다. 예를들면 shared_ptr의 카운트를 관리하는 제어블록과 자원도 별도로 생성되어서는 안되기 때문에 의도적으로 얕은복사가 발생합니다.

### ✅ C++ 언어 관점

1. C++에서 기본 복사 생성자는 얕은 복사인가요?

    - 컴파일러가 생성하는 기본 복사 생성자는 얕은 복사를 진행합니다.

2. 포인터 멤버를 가진 클래스에서 기본 복사 생성자를 사용하면 어떤 문제가 생기나요?

    - 얕은 복사가 발생하여 메모리 관리 문제가 발생할 수 있습니다.

3. 깊은 복사를 구현하려면 어떤 함수들을 정의해야 하나요?

    - 복사생성자, 대입연산자, 소멸자를 정의해야 합니다.

4. 복사 생성자와 복사 대입 연산자의 역할 차이는 무엇인가요?

    - 복사 생성자는 새롭게 할당되는 객체에 사용되는 역할이고, 복사 대입 연산자는 이미 생성된 객체를 재사용하기 위해 사용되는 역할입니다. 메모리 할당이 발생하고, 메모리 할당이 발생하지 않는다는 특징이 있습니다.

### ✅ Rule of 3 / 5 / 0 연계

1. Rule of 3이란 무엇인가요?

    - 복사 생성자, 소멸자, 대입 연산자 중 하나라도 재정의가 필요하다면 세 가지 함수 모두 재정의를 해야한다는 법칙입니다.

2. Rule of 3은 얕은 복사/깊은 복사와 어떤 관련이 있나요?

    - 얕은복사로는 의도하지 않은 동작이 발생하여 깊은 복사가 필요할 때 복사 생성자나 대입 연산자를 사용하게 됩니다. 깊은 복사가 필요한 것은 힙 할당 영역에 대한 핸들링이 존재하기 때문에 소멸자에서 해제 요청이 반드시 필요합니다. 따라서 깊은 복사가 필요하다면 Rule of 3가 필요합니다.

3. Rule of 5가 등장한 이유는 무엇인가요?

    - 이동에 대한 재정의가 필요할 때 복사 생성자, 이동 생성자, 대입 연산자, 이동 연산자, 소멸자를 모두 재정의 해야한다는 법칙입니다. 이동에 대한 개념이 등장하면서 등장했습니다.

4. Rule of 0은 어떤 상황에서 권장되나요?

    RAII가 등장하면서 모든 책임을 관리 객체에 맡기는 것입니다.

### ✅ STL / 스마트 포인터

1. `std::vector`의 복사는 얕은 복사인가요, 깊은 복사인가요?

    - 깊은복사가 진행됩니다. 메모리가 별도로 할당됩니다.

2. `std::string`은 내부적으로 얕은 복사를 하나요?

    - string은 vector<char>라고 생각할 수 있습니다. vector는 내부적으로 깊은 복사를 진행합니다.

3. `std::unique_ptr`는 복사 시 어떻게 동작하나요?

    - unique_ptr은 복사가 delete되어있습니다. movem로 이동만 허용됩니다.

4. `std::shared_ptr`는 얕은 복사인가요, 깊은 복사인가요?

    - shared_ptr은 얕은 복사가 이루어져 같은 컨트롤 블록과 같은 자원을 가리키며 메모리를 아끼게됩니다.

### ✅ 실무 / 설계 판단

1. 언제 얕은 복사를 선택할 수 있나요?

    - 큰 메모리로 새로운 영역을 할당하기에 부담이 되면서, 수정이 발생하지 않는 자원인 경우에 얕은 복사로 관리할 수 있습니다.

2. 언제 깊은 복사가 반드시 필요한가요?

    - 수정이 발생하는 힙 자원의 경우에 깊은 복사가 필요합니다.

3. 성능 관점에서 얕은 복사와 깊은 복사의 차이는 무엇인가요?

    - 얕은 복사는 값 복사만 이루어지기 때문에 상당히 빠른 시간내에 이뤄집니다. 깊은 복사는 해당 포인터가 가리키는 자원의 모든 변수를 복사해야하고, 메모리 영역도 새롭게 할당해야 하므로 얕은 복사에 비하면 매우 느립니다.

4. 게임/엔진 개발에서 얕은 복사로 문제가 되는 사례를 예로 들어보세요.

    - 관리하고 있는 스프라이트가 의도하지 않은 얕은 복사된다면 다른 포인터가 해제할 때 같이 가리키고 있는 영역에서 스프라이트가 사라져 마젠타만 나온다거나 하는 문제가 발생할 수 있습니다.

### ✅ 함정 질문

1. memcpy로 객체를 복사하면 깊은 복사가 되나요?

    - memcpy는 비트 복사로 얕은 복사가 진행됩니다.

2. 얕은 복사와 참조(reference)는 같은 개념인가요?

    - 같은 개념이라고 볼 수 있습니다.

3. 복사 금지(delete copy)를 선택하는 이유는 무엇인가요?

    - unique_ptr같은 경우에 단일 소유권을 원칙으로 하는 객체이기 때문입니다.

4. 얕은 복사와 깊은 복사를 한 문장으로 요약해보세요.

    - 얕은 복사는 값을 그대로 복사하고, 깊은 복사는 메모리 영역을 새롭게 할당하여 복사합니다.

---

### GPT 피드백

1. 얕은복사 != 참조이다. 얕은복사는 말그대로 복사이고, 참조는 별칭으로 서로 다른개념임


<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 얕은 복사는 포인터 값만 복사하고, 깊은 복사는 실제 데이터를 새로 복사합니다.
2. 얕은 복사는 멤버 변수의 값(주소)을 그대로 복사합니다.
3. 깊은 복사는 포인터가 가리키는 대상까지 새로 할당해 복사합니다.
4. 얕은 복사는 메모리를 공유하고, 깊은 복사는 메모리를 분리합니다.

5. 하나의 자원을 여러 객체가 공유해 이중 해제 문제가 발생할 수 있습니다.
6. 같은 메모리를 두 번 해제하려 할 때 발생합니다.
7. 이미 해제된 메모리를 참조할 때 발생합니다.
8. 읽기 전용 공유 등 의도가 명확하다면 사용할 수 있습니다.

9. 기본 복사 생성자는 멤버 단위 복사로 인해 얕은 복사입니다.
10. 여러 객체가 동일한 동적 메모리를 소유하게 됩니다.
11. 복사 생성자와 복사 대입 연산자를 직접 정의해야 합니다.
12. 복사 생성자는 새 객체 생성 시, 대입 연산자는 기존 객체에 복사할 때 호출됩니다.

13. 소멸자, 복사 생성자, 복사 대입 연산자를 함께 정의해야 한다는 규칙입니다.
14. 깊은 복사를 안전하게 구현하기 위해 필요합니다.
15. 이동语语语(이동 생성자/이동 대입)로 불필요한 깊은 복사를 줄이기 위해서입니다.
16. 자원 관리를 STL과 RAII에 맡길 수 있을 때 권장됩니다.

17. 내부 버퍼를 새로 할당하므로 깊은 복사입니다.
18. 현대 C++에서는 일반적으로 깊은 복사 또는 COW 제거 방식입니다.
19. 복사가 금지되며 소유권은 이동으로만 전달됩니다.
20. 포인터 값은 복사되지만 참조 카운트를 공유합니다.

21. 참조 의미의 공유가 의도된 경우입니다.
22. 객체 간 독립적인 소유권이 필요할 때입니다.
23. 얕은 복사는 빠르지만 안전성 문제가 있고, 깊은 복사는 비용이 큽니다.
24. 리소스 핸들을 얕게 복사해 수명 관리가 꼬이는 경우입니다.

25. 아닙니다, 단순 메모리 복사일 뿐 객체 의미의 깊은 복사가 아닙니다.
26. 아닙니다, 얕은 복사는 복사이고 참조는 별도의 개념입니다.
27. 자원의 단일 소유권을 강제하기 위해서입니다.
28. 얕은 복사는 주소만 공유하고, 깊은 복사는 데이터까지 복제합니다.

</div>
</details>

## 🧠 05. 포인터(pointer) vs 참조(reference)

### ✅ 기본 개념

1. 포인터와 참조의 가장 큰 차이는 무엇인가요?

    - 포인터 변수는 가리키는 지점이 달라질 수 있지만, 참조는 별칭으로써 값 변경만 가능하고 가리키는 변수의 변경은 불가능합니다.

2. 포인터와 참조는 각각 무엇을 표현하나요?

    - 포인터는 주소를 가리키는 변수이고, 참조는 변수의 또다른 지칭입니다.

### ✅ 초기화 및 재지정

1. 포인터는 초기화하지 않고 사용할 수 있나요?

    - 초기화 하지 않는다면 임의의 값이 들어있고, 사용하면 임의의 주소에 접근하기 때문에 사용해서는 안됩니다.

2. 참조는 반드시 초기화해야 하나요?

    - 참조는 한 번 결정되면 변경되지 않기 때문에 반드시 생성시점에 초기화되어야 합니다.

3. 포인터와 참조는 다른 대상을 다시 가리킬 수 있나요?

    - 포인터는 가능하고 참조는 불가능합니다.

### ✅ null / 안전성

1. 포인터는 null 상태를 가질 수 있나요?

    - 네 가질 수 있습니다. nullptr을 가리키게 됩니다.

2. 참조는 null이 될 수 있나요?

    - 문법적으로 될 수 없습니다. 

3. 안전성 측면에서 포인터와 참조의 차이는 무엇인가요?

    포인터는 null을 가리키고 있을수도 있고, 참조는 반드시 객체가 존재합니다.

### ✅ 사용 방식과 표현력

1. 포인터는 왜 간접 접근 연산자(`*`, `->`)가 필요한가요?

    - 포인터에 간접 접근을 하지 않는다면 포인터에 할당된 주소를 변경하는 동작이 발생합니다. 따라서 핸들링 할 변수에 접근하기 위해서는 간접 접근 연산자가 별도로 필요합니다.

2. 참조는 왜 일반 변수처럼 사용할 수 있나요?

    - 포인터 연산이 필요없고, 일반 변수의 별칭이기 때문에 일반 변수처럼 사용할 수 있습니다.

3. 함수 인자로 전달할 때 포인터와 참조의 차이는 무엇인가요?

    - 포인터로 전달할 때는 주소가 얕은복사된 또다른 포인터가 전달되고 함수 내부에서 가리키고 있는 주소를 변경한다고 해서 함수로 전달했던 포인터가 가리키는 주소가 변경되지는 않습니다. 참조 또한 포인터로 전달되기는 하지만 문법적으로 일반 변수처럼 사용할 수 있습니다.

### ✅ 메모리 관점

1. 포인터와 참조는 메모리를 어떻게 사용하나요?

    - 포인터는 레지스터 크기만큼의 변수를 할당하여 주소를 담고, 변수를 가리키게 됩니다. 참조는 같은 영역에 존재한다면 메모리 할당이 발생하지 않고, 함수 파라미터로 전달될 때는 내부적으로 포인터와 같게 동작합니다.

2. 참조는 내부적으로 포인터로 구현되나요?

    - 함수 파라미터로 전달될 때에만 포인터로 구현됩니다.

3. sizeof(pointer)와 sizeof(reference)는 어떻게 되나요?

    - sizeof(pointer)는 레지스터 크기와 같을 것이고, sizeof(reference)는 객체의 전체 크기가 나올것입니다.

### ✅ const와의 관계

1. `const int*`, `int* const`, `const int&`의 차이를 설명해보세요.

    - const int *는 상수 int를 가리키는 포인터이며 가리키는 변수의 값이 변경될 수 없고, int* const는  상수 int를 가리키는 상수 포인터이고 포인터가 가리키는 주소가 변경될 수 없습니다. const int&는 상수화된 참조로써 동작은 const int *와 같습니다.

2. 참조에 const를 붙이는 이유는 무엇인가요?

    - 객체의 크기가 커서 복사 비용을 줄이기 위해 참조를 붙이지만, 수정이 발생하지 않는것을 문법적으로 명시하기 위해 참조에 const를 붙입니다.

3. 포인터와 const 조합이 복잡한 이유는 무엇인가요?

    - 상수화 하고 싶은 대상이 달라질 수 있기 때문에 복잡해 보인다고 생각합니다.

### ✅ 실무 / 설계 판단

1. 언제 포인터를 사용하는 것이 적절한가요?

    - 힙 영역 데이터를 다룰 때 포인터가 필요합니다.

2. 언제 참조를 사용하는 것이 적절한가요?

    - 함수 파라미터로 전달할 때, 복사 비용은 발생시키지 않고 싶고, 포인터 연산자를 사용하지 않는 일반 변수처럼 함수 내부에서 사용하고 싶을 때 참조를 사용하는 것이 적절합니다.

3. API 설계 시 포인터와 참조 중 어떤 기준으로 선택하나요?

    - 참조는 값이 변경되는 것을 암시하고 싶을 때와, 함수형 프로그래밍을 지원하고 싶을 때에도 리턴에서 참조를 사용합니다. 포인터는 그외에 힙 메모리를 다룬다면 사용합니다.

4. 출력 파라미터(out parameter)는 포인터와 참조 중 무엇이 더 적절한가요?

    - 수정이 발생하기 때문에 참조가 더 적절합니다.

### ✅ 함정 질문

1. 참조는 포인터의 문법적 설탕(syntax sugar)에 불과한가요?

    - 프로그래머에게 편의를 제공하기 때문에 설탕이라고 생각할 수 있지만, 편의를 제공함으로써 실수를 줄일 수 있기 때문에 설탕에 불과하다고 볼 수는 없습니다.

2. 포인터 vs 참조를 한 문장으로 요약해보세요.

    - 포인터는 주소정보를 가리키기 위해 사용되고, 참조는 포인터와 유사하게 사용되지만, 포인터 연산자를 사용하지 않아 가독성과 편의성을 제공합니다.

---

### GPT 피드백

1. 참조는 함수 파라미터일 때만 포인터 -> 언어 표준에서 규정하지 않았기 때문에 컴파일러마다 다를 수 있음. 참조는 그냥 언어적 별칭이라고 봐야함

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변


1. 포인터는 주소를 저장하고, 참조는 기존 객체의 별명(alias)입니다.
2. 포인터는 메모리 주소를, 참조는 대상 객체 자체를 표현합니다.

3. 가능하지만 초기화되지 않은 포인터는 위험합니다.
4. 네, 참조는 선언과 동시에 반드시 초기화되어야 합니다.
5. 포인터는 가능하지만 참조는 불가능합니다.

6. 네, `nullptr`를 가질 수 있습니다.
7. 아니요, 유효한 객체만 참조해야 합니다.
8. 참조는 null이 없어 기본적으로 더 안전합니다.

9. 포인터는 주소를 통해 간접 접근하기 때문입니다.
10. 참조는 대상 객체의 또 다른 이름이기 때문입니다.
11. 포인터는 null 체크가 필요하고, 참조는 항상 유효함을 전제로 합니다.

12. 포인터는 주소 저장 공간이 필요하고, 참조는 보통 별도 공간이 드러나지 않습니다.
13. 구현상 포인터로 처리될 수 있지만 언어적 의미는 다릅니다.
14. 포인터는 주소 크기이고, 참조는 보통 참조 대상 크기로 취급됩니다.

15. 포인터는 대상/자신의 const를 구분하고, 참조는 대상만 const로 제한합니다.
16. 읽기 전용 접근을 강제해 의도를 명확히 하기 위함입니다.
17. 포인터는 대상과 포인터 자체의 변경 가능성을 모두 표현하기 때문입니다.

18. null 표현, 선택적 객체, 재지정이 필요한 경우입니다.
19. 항상 유효한 객체를 다룰 때입니다.
20. null 가능 여부와 소유권 표현이 필요한지로 판단합니다.
21. 참조가 의도를 더 명확히 표현하는 경우가 많습니다.

22. 아니요, 언어 차원에서 제약과 의미가 다릅니다.
23. 포인터는 선택적 주소이고, 참조는 반드시 유효한 별명입니다.


</div>
</details>

## 🧠 06. const 위치별 의미

### ✅ 기본 개념

1. C++에서 `const`는 무엇을 제한하나요?

    - 상수화 한다는 의미로써 변경을 제한합니다.

2. `const`의 위치가 의미에 영향을 주는 이유는 무엇인가요?

    - 포인터에 대한 const가 위치에 영향을 줍니다. int* const는 int*에 대한 상수화이고 const int *는 const int에 대한 포인터라는 의미기 때문에 위치에 따라 의미가 달라진다고 할 수 있습니다.

### ✅ 포인터와 const

1. `const int* p`의 의미를 설명해보세요.

    - const int 자료형에 대한 포인터라는 의미입니다. 포인터가 가리키고 있는 변수의 값이 불변입니다.

2. `int* const p`의 의미를 설명해보세요.

    - int형에 대한 상수형 포인터라는 의미입니다. 포인터가 상수라서 가리키는 주소값의 변경이 불가능합니다.

3. `const int* const p`의 의미를 설명해보세요.

    - const int에 대한 const 포인터라는 의미입니다. 포인터가 가리키는 주소도 변경될 수 없으며, 포인터가 가리키는 변수의 값도 변경될 수 없습니다.

### ✅ 참조와 const

1. `const int& r`의 의미는 무엇인가요?

    - 함수 파라미터로 넘기기 위해 주로 사용되는데, 복사 비용은 줄이되, 변경은 안한다는 의미를 가집니다.

2. `int& const r`는 가능한 선언인가요?

    - 불가능합니다.

### ✅ 함수 인자 / 반환값 관점

1. 반환 타입에 `const`를 붙이는 것은 어떤 의미를 가지나요?

    - 변경할 수 없는 값을 반환한다는 의미를 가집니다. 따라서 해당 함수의 리턴은 초기화에만 가능합니다.

### ✅ 읽는 법 / 실무 판단

1. API 설계에서 `const`를 적극적으로 사용하는 이유는 무엇인가요?

    - 사용자에게 함수 파라미터로 전달되어도 변경되지 않는다는 것을 전달해줍니다.

---

### GPT 피드백

1. 반환 타입이 const인 경우에 함수 리턴이 초기화에만 가능한것은 x. 반환된 임시 객체를 수정하지 못하도록 함

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. `const`는 값의 변경을 금지해 읽기 전용을 보장합니다.
2. `const`는 바로 오른쪽 대상(없으면 왼쪽)을 제한하기 때문입니다.

3. 포인터가 가리키는 값은 수정할 수 없지만 포인터는 변경 가능합니다.
4. 포인터 자체는 변경할 수 없지만 가리키는 값은 수정 가능합니다.
5. 포인터와 포인터가 가리키는 값 모두 수정할 수 없습니다.

6. 참조를 통해 대상 객체를 읽기 전용으로 접근한다는 의미입니다.
7. 아니요, 참조 자체는 재지정이 불가능하므로 const를 붙일 수 없습니다.

8. 호출자가 반환값을 수정하지 못하게 하거나 의도를 명확히 합니다.

9. 인터페이스 안정성과 의도 표현을 명확히 하기 위함입니다.

</div>
</details>

## 🧠 07. constexpr

### ✅ 기본 개념

1. constexpr란 무엇인가요?

    - 컴파일타임에 상수임을 보장하는 키워드입니다.

2. constexpr는 왜 등장했나요?

    - 프로그래밍시 변수의 이점은 사용하지만 컴파일타임에 상수임을 보장해 상수만 할 수 있는 기능들도 사용하기 위해 등장했습니다.

3. const와 constexpr의 차이는 무엇인가요?

    - const는 그냥 변수가 불변성을 갖도록 하는 키워드이고, constexpr은 컴파일타임에 상수임을 보장해서 상수가 들어가야하는 배열의 크기 할당 등에 사용될 수 있습니다.

### ✅ 컴파일 타임 개념

1. 컴파일 타임 계산이란 무엇인가요?

    - 프로그램은 크게 봤을 때 컴파일타임과 런타임으로 나뉠 수 있는데 프로그램으로 만드는 컴파일을 하는 시간을 컴파일타임, 프로그램이 동작하는 시간을 런타임이라고 합니다. 프로그램이 만들어지는 시간동안 계산과정이 들어갈 수 있는 것을 컴파일 타임 계산이라고 합니다.

2. constexpr 함수는 언제 컴파일 타임에 평가되나요?

    - 모든 인자가 컴파일 타임 상수일 때 가능합니다

### ✅ 변수 / 함수 관점

1. constexpr 변수의 특징은 무엇인가요?

    - 컴파일 타임에 값이 결정됩니다.

2. constexpr 함수에는 어떤 제약이 있나요?

    - 상수임을 보장하는 변수들만 사용해야 컴파일타임에 계산됩니다.

3. 일반 함수 대신 constexpr 함수를 사용하는 이유는 무엇인가요?

    - 미리 계산된 값만 필요하다고 판단되는 함수들은 런타임에 계산하지 않고 컴파일 타임에 미리 계산해 두는 것이 유저 경험을 개선하기 때문입니다.

---

### GPT 피드백

1. constexpr은 컴파일 타임 평가 가능성 명시라고 함. inline처럼 되면 하고 아님 말고 식인가? -> 여기서 말한 가능성은 probabilty가 아니라 possiblity기 때문에 inline처럼 쓰면 안되고, 컴파일 제약이 생기는 것이라고 함


<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

### 👉 1줄 모범 답변

1. 컴파일 타임에 평가될 수 있는 값이나 함수를 명시하는 키워드입니다.
2. 상수 표현을 컴파일 타임에 강제해 더 안전하고 효율적인 코드를 만들기 위해 등장했습니다.
3. const는 변경 불가, constexpr는 컴파일 타임 평가 가능을 의미합니다.

4. 실행 전에 값이 확정되어 코드에 상수로 반영되는 계산입니다.
5. 인자가 모두 컴파일 타임 상수일 때 평가됩니다.

6. 반드시 컴파일 타임 상수로 초기화되어야 합니다.
7. 컴파일 타임에 평가 가능한 코드만 포함해야 합니다.
8. 런타임 비용 없이 계산 결과를 사용할 수 있기 때문입니다.

</div>
</details>
