---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: true
tags:
    [면접준비]
---
# 🧠 C++ Stack vs Heap 1줄 모범 답변

---

1. 스택은 자동 관리되는 고정 크기 메모리이고, 힙은 런타임에 동적 할당되는 메모리입니다.
2. 스택은 짧은 생명 주기의 지역 변수에, 힙은 긴 생명 주기의 동적 객체에 사용됩니다.
3. 함수 인자, 지역 변수, 반환 주소, 이전 스택 프레임 정보가 저장됩니다.
4. 객체의 생명 주기가 함수 범위를 넘거나 크기를 런타임에 결정해야 할 때 사용합니다.
5. 스택은 스레드 생성 시 고정 크기로 할당되기 때문입니다.
6. 함수 호출과 반환이 중첩 구조이기 때문에 LIFO 구조를 가집니다.

7. 컴파일러가 함수 진입과 종료 시 자동으로 수행합니다.
8. 프로그래머가 직접 관리하며 C++에서는 `new/delete`로 처리합니다.
9. 스택 변수는 자동 소멸되고, `new`로 생성한 객체는 명시적으로 해제해야 합니다.
10. 스택 변수는 스코프 기반이고, 힙 변수는 해제 시점까지 유지됩니다.
11. 메모리 누수, 댕글링 포인터, 이중 해제, 단편화 문제가 발생할 수 있습니다.

12. 포인터 이동만으로 할당과 해제가 가능해 오버헤드가 적기 때문입니다.
13. 스택은 연속 메모리로 캐시 효율이 높고, 힙은 분산될 수 있습니다.
14. 함수 호출 시 생성되는 실행 단위 메모리 구조입니다.
15. 스택 프레임이 누적되며 과도하면 스택 오버플로우가 발생합니다.

16. 재귀가 깊거나 스택에 큰 객체를 반복 할당할 때 발생합니다.
17. 스택은 스택 크기 초과, 힙은 가용 메모리 부족 상황입니다.
18. 해제된 메모리를 계속 참조할 때 발생합니다.
19. 자동 해제가 되지 않아 해제를 놓치기 쉽기 때문입니다.

20. 대부분 스택이지만 컴파일러 최적화로 달라질 수 있습니다.
21. 데이터 영역(Data Segment)에 할당됩니다.
22. 스마트 포인터 객체는 스택에, 관리 대상은 힙에 있습니다.
23. 스택 객체 소멸 시점에 자원을 자동 해제하도록 합니다.

24. 각 스레드는 독립적인 스택을 가지고 힙은 공유합니다.
25. 스레드별로 분리되어 있어 기본적으로 안전합니다.

26. 생명 주기, 크기, 공유 여부, 성능 요구사항을 기준으로 판단합니다.
27. 스택 크기 제한으로 인한 오버플로우를 방지하기 위함입니다.
28. 프레임 성능과 메모리 안정성에 직접적인 영향을 주기 때문입니다.

29. 컨테이너 객체는 스택에, 내부 데이터는 힙에 존재합니다.
30. 함수 종료 후 메모리가 해제되어 댕글링 포인터가 됩니다.
