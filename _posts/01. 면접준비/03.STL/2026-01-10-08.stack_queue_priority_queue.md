---
title: 
date: 2026-01-10 21:33:01 +09:00
categories: [면접준비, STL]
published: false
tags:
    [면접준비]
---

# 🧠 C++ 컨테이너 어댑터 (stack / queue / priority_queue) 면접 질문 리스트

## ✅ 기본 개념

1. 컨테이너 어댑터란 무엇인가요?

    - 기존에 존재하는 컨테이너를 래핑해서 새로운 컨테이너를 만든 것을 컨테이너 어댑터라고 합니다.

2. stack, queue, priority_queue의 공통점은 무엇인가요?

    - 셋 다 컨테이너 어댑터입니다.

3. 컨테이너 어댑터와 일반 컨테이너의 차이는 무엇인가요?

    - 컨테이너 어댑터는 일반 컨테이너를 한 번 감싸고 있기 때문에 사용이 조금 느립니다.

## ✅ 내부 컨테이너

1. stack의 기본 내부 컨테이너는 무엇인가요?

    - stack은 vector로 이루어져있습니다. push_back과 pop_back을 주로 사용하기에 유용합니다.

2. queue의 기본 내부 컨테이너는 무엇인가요?

    - deque를 사용합니다. push_back()과 pop_front()를 주로 사용하기 때문입니다.

3. priority_queue의 기본 내부 컨테이너는 무엇인가요?

    - vector를 주로 사용합니다. heap을 구현하기에 vector가 가장 효율적입니다.

4. 내부 컨테이너를 변경할 수 있나요?

    - 변경 가능합니다. 2번째 템플릿 인자로 넣으면 됩니다.

## ✅ stack

1. stack의 주요 연산과 시간 복잡도는 어떻게 되나요?

    - pop과 push는 모두 O(1)로 이루어집니다.

2. stack의 사용 사례는 무엇인가요?

    - 함수 콜스택이 있습니다.

3. stack을 직접 구현한다면 어떤 컨테이너를 사용하나요?

    - vector를 사용할 것 같습니다.

## ✅ queue

1. queue의 주요 연산과 시간 복잡도는 어떻게 되나요?

    - push와 pop이 모두 O(1)에 이뤄집니다.

2. queue의 사용 사례는 무엇인가요?

    - task를 pending시키고 얻어서 사용하는데 사용합니다.

3. queue를 직접 구현한다면 어떤 컨테이너를 사용하나요?

    - deque를 사용할 것 같습니다.

## ✅ priority_queue

1. priority_queue의 동작 방식은 어떻게 되나요?

    - push와 pop을 할 때마다 내부 정렬이 필요합니다.

2. priority_queue의 주요 연산과 시간 복잡도는 어떻게 되나요?

    - pop과 push는 O(logN), top은 O(1)로 이뤄집니다.

3. priority_queue의 내부 구조는 무엇인가요?

    - vector로 heap을 구현합니다.

4. 커스텀 비교자를 사용하는 방법은 무엇인가요?

    - operator()를 구현한 struct를 사용합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. 기존 컨테이너를 기반으로 특정 인터페이스만 제공하는 래퍼 클래스입니다.
2. 특정 자료구조의 인터페이스만 제공하고, 내부적으로 다른 컨테이너를 사용합니다.
3. 어댑터는 제한된 인터페이스만 제공하고, 일반 컨테이너는 전체 기능을 제공합니다.

### ✅ 내부 컨테이너

1. 기본적으로 deque를 사용합니다.
2. 기본적으로 deque를 사용합니다.
3. 기본적으로 vector를 사용합니다.
4. 네, 템플릿 매개변수로 내부 컨테이너를 지정할 수 있습니다.

### ✅ stack

1. push/pop/top 모두 O(1), size/empty도 O(1)입니다.
2. 함수 호출 스택, 괄호 매칭, 역폴란드 표기법 계산, DFS 구현 등에 사용합니다.
3. vector나 deque를 사용할 수 있으며, deque가 기본값입니다.

### ✅ queue

1. push/pop/front/back 모두 O(1), size/empty도 O(1)입니다.
2. BFS 구현, 작업 큐, 메시지 큐, 프린터 대기열 등에 사용합니다.
3. deque나 list를 사용할 수 있으며, deque가 기본값입니다.

### ✅ priority_queue

1. 최대 힙(또는 최소 힙)으로 동작하여 항상 우선순위가 높은 원소가 top에 위치합니다.
2. push는 O(log N), pop은 O(log N), top은 O(1)입니다.
3. 힙 구조로, 기본적으로 vector를 사용해 구현됩니다.
4. 비교자 템플릿 매개변수로 함수 객체나 함수 포인터를 전달합니다.


</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 컨테이너 어댑터란 무엇인가요?**
- **현재 답변**: "기존에 존재하는 컨테이너를 래핑해서 새로운 컨테이너를 만든 것을 컨테이너 어댑터라고 합니다"
- **피드백**:
  - ✅ **정확함**: 핵심을 잘 파악했습니다
  - 💡 **보완**: "기존 컨테이너를 기반으로 특정 인터페이스만 제공하는 래퍼 클래스입니다"
  - 어댑터의 핵심은 특정 자료구조의 인터페이스만 제공한다는 점입니다

**질문 2: stack, queue, priority_queue의 공통점**
- **현재 답변**: "셋 다 컨테이너 어댑터입니다"
- **피드백**:
  - ✅ **정확함**: 맞습니다
  - 💡 **보완**: "특정 자료구조의 인터페이스만 제공하고, 내부적으로 다른 컨테이너를 사용합니다"
  - 공통점을 더 구체적으로 설명하면 좋습니다

**질문 3: 컨테이너 어댑터와 일반 컨테이너의 차이**
- **현재 답변**: "컨테이너 어댑터는 일반 컨테이너를 한 번 감싸고 있기 때문에 사용이 조금 느립니다"
- **피드백**:
  - ❌ **오개념**: 성능 차이가 아니라 인터페이스 차이입니다
  - ✅ **정확한 답변**: "어댑터는 제한된 인터페이스만 제공하고, 일반 컨테이너는 전체 기능을 제공합니다"
  - 어댑터는 성능 문제가 아니라, 특정 자료구조의 인터페이스만 노출하여 실수를 방지하는 것이 목적입니다

### ✅ 내부 컨테이너

**질문 1: stack의 기본 내부 컨테이너**
- **현재 답변**: "stack은 vector로 이루어져있습니다. push_back과 pop_back을 주로 사용하기에 유용합니다"
- **피드백**:
  - ❌ **오개념**: stack의 기본 내부 컨테이너는 **deque**입니다
  - ✅ **정확한 답변**: "기본적으로 deque를 사용합니다"
  - vector도 사용 가능하지만, 기본값은 deque입니다
  - deque를 사용하는 이유: 앞뒤 삽입/삭제가 모두 O(1)이기 때문입니다

**질문 2: queue의 기본 내부 컨테이너**
- **현재 답변**: "deque를 사용합니다. push_back()과 pop_front()를 주로 사용하기 때문입니다"
- **피드백**:
  - ✅ **정확함**: 완벽한 답변입니다
  - deque를 사용하는 이유를 정확히 설명했습니다

**질문 3: priority_queue의 기본 내부 컨테이너**
- **현재 답변**: "vector를 주로 사용합니다. heap을 구현하기에 vector가 가장 효율적입니다"
- **피드백**:
  - ✅ **정확함**: 정확한 답변입니다
  - vector를 사용하는 이유: 힙 구조를 배열로 구현할 때 연속 메모리가 효율적이기 때문입니다

**질문 4: 내부 컨테이너를 변경할 수 있나요?**
- **현재 답변**: "변경 가능합니다. 2번째 템플릿 인자로 넣으면 됩니다"
- **피드백**:
  - ✅ **정확함**: 맞습니다
  - 💡 **보완**: "네, 템플릿 매개변수로 내부 컨테이너를 지정할 수 있습니다"
  - 예: `std::stack<int, std::vector<int>>` - vector를 내부 컨테이너로 사용

### ✅ stack

**질문 1: stack의 주요 연산과 시간 복잡도**
- **현재 답변**: "pop과 push는 모두 O(1)로 이루어집니다"
- **피드백**:
  - ✅ **정확함**: 핵심 연산은 맞습니다
  - 💡 **보완**: "push/pop/top 모두 O(1), size/empty도 O(1)입니다"
  - top 연산도 O(1)이며, 주요 연산에 포함됩니다

**질문 2: stack의 사용 사례**
- **현재 답변**: "함수 콜스택이 있습니다"
- **피드백**:
  - ✅ **정확함**: 맞습니다
  - 💡 **보완**: "함수 호출 스택, 괄호 매칭, 역폴란드 표기법 계산, DFS 구현 등에 사용합니다"
  - 더 많은 사용 사례를 알고 있으면 좋습니다

**질문 3: stack을 직접 구현한다면 어떤 컨테이너를 사용하나요?**
- **현재 답변**: "vector를 사용할 것 같습니다"
- **피드백**:
  - ⚠️ **부분적 정확**: vector도 가능하지만, 기본값은 deque입니다
  - ✅ **정확한 답변**: "vector나 deque를 사용할 수 있으며, deque가 기본값입니다"
  - deque가 기본값인 이유: 앞뒤 삽입/삭제가 모두 O(1)이기 때문입니다

### ✅ queue

**질문 1: queue의 주요 연산과 시간 복잡도**
- **현재 답변**: "push와 pop이 모두 O(1)에 이뤄집니다"
- **피드백**:
  - ✅ **정확함**: 핵심 연산은 맞습니다
  - 💡 **보완**: "push/pop/front/back 모두 O(1), size/empty도 O(1)입니다"
  - front, back 연산도 O(1)이며, 주요 연산에 포함됩니다

**질문 2: queue의 사용 사례**
- **현재 답변**: "task를 pending시키고 얻어서 사용하는데 사용합니다"
- **피드백**:
  - ✅ **정확함**: 작업 큐 개념을 잘 이해했습니다
  - 💡 **보완**: "BFS 구현, 작업 큐, 메시지 큐, 프린터 대기열 등에 사용합니다"
  - BFS 알고리즘에서 queue가 핵심 자료구조입니다

**질문 3: queue를 직접 구현한다면 어떤 컨테이너를 사용하나요?**
- **현재 답변**: "deque를 사용할 것 같습니다"
- **피드백**:
  - ✅ **정확함**: 완벽한 답변입니다
  - 💡 **보완**: "deque나 list를 사용할 수 있으며, deque가 기본값입니다"
  - deque가 기본값인 이유: 앞뒤 삽입/삭제가 모두 O(1)이기 때문입니다

### ✅ priority_queue

**질문 1: priority_queue의 동작 방식**
- **현재 답변**: "push와 pop을 할 때마다 내부 정렬이 필요합니다"
- **피드백**:
  - ⚠️ **부정확**: "정렬"이 아니라 "힙 구조 유지"가 정확합니다
  - ✅ **정확한 답변**: "최대 힙(또는 최소 힙)으로 동작하여 항상 우선순위가 높은 원소가 top에 위치합니다"
  - priority_queue는 완전 정렬이 아니라 힙 구조를 유지합니다

**질문 2: priority_queue의 주요 연산과 시간 복잡도**
- **현재 답변**: "pop과 push는 O(logN), top은 O(1)로 이뤄집니다"
- **피드백**:
  - ✅ **정확함**: 완벽한 답변입니다
  - 힙 구조의 특성상 push/pop은 O(log N), top은 O(1)입니다

**질문 3: priority_queue의 내부 구조**
- **현재 답변**: "vector로 heap을 구현합니다"
- **피드백**:
  - ✅ **정확함**: 정확한 답변입니다
  - 💡 **보완**: "힙 구조로, 기본적으로 vector를 사용해 구현됩니다"
  - 힙은 완전 이진 트리를 배열로 표현한 구조입니다

**질문 4: 커스텀 비교자를 사용하는 방법**
- **현재 답변**: "operator()를 구현한 struct를 사용합니다"
- **피드백**:
  - ✅ **정확함**: 함수 객체를 사용하는 방법을 알고 있습니다
  - 💡 **보완**: "비교자 템플릿 매개변수로 함수 객체나 함수 포인터를 전달합니다"
  - 예: `std::priority_queue<int, std::vector<int>, std::greater<int>>` - 최소 힙
  - 람다도 사용 가능하지만, decltype이 필요합니다

### 📊 전체 평가

**강점:**
- ✅ 컨테이너 어댑터의 기본 개념을 잘 이해하고 있습니다
- ✅ queue와 priority_queue의 내부 컨테이너를 정확히 알고 있습니다
- ✅ 시간 복잡도에 대한 이해가 정확합니다
- ✅ 커스텀 비교자 사용법을 알고 있습니다

**개선 필요:**
- ❌ stack의 기본 내부 컨테이너가 deque라는 것을 모르고 있음 (중요한 오개념)
- ❌ 컨테이너 어댑터가 "느리다"는 오개념
- ❌ priority_queue의 동작을 "정렬"로 설명 (힙 구조 유지가 정확)
- ⚠️ 사용 사례를 더 구체적으로 학습 필요

**우선순위:**
1. **높음**: stack의 기본 내부 컨테이너가 deque라는 점 정확히 이해
2. **높음**: 컨테이너 어댑터와 일반 컨테이너의 차이 정확히 이해 (성능 vs 인터페이스)
3. **중간**: priority_queue의 동작을 "힙 구조 유지"로 정확히 표현
4. **낮음**: 사용 사례를 더 구체적으로 학습

**특별 주의사항:**
- stack의 기본 내부 컨테이너는 **deque**입니다 (vector가 아님)
- 컨테이너 어댑터는 성능 문제가 아니라, 제한된 인터페이스를 제공하여 실수를 방지하는 것이 목적입니다
- priority_queue는 "정렬"이 아니라 "힙 구조 유지"로 동작합니다
