---
title: 
date: 2026-01-10 21:33:01 +09:00
categories: [면접준비, STL]
published: false
tags:
    [면접준비]
---

# 🧠 C++ iterator 무효화 규칙 면접 질문 리스트

## ✅ 기본 개념

1. iterator invalidation이란 무엇인가요?

2. iterator가 무효화되면 어떤 문제가 발생하나요?

3. iterator 무효화를 방지하는 방법은 무엇인가요?

## ✅ 컨테이너별 무효화 규칙

1. vector에서 iterator가 무효화되는 경우는 언제인가요?

2. deque에서 iterator가 무효화되는 경우는 언제인가요?

3. list와 forward_list에서 iterator가 무효화되는 경우는 언제인가요?

4. map과 set에서 iterator가 무효화되는 경우는 언제인가요?

5. unordered_map과 unordered_set에서 iterator가 무효화되는 경우는 언제인가요?

## ✅ 무효화 규칙 정리표

1. 삽입 연산 시 iterator 무효화 규칙을 정리해보세요.

2. 삭제 연산 시 iterator 무효화 규칙을 정리해보세요.

3. 재할당/rehash 시 iterator 무효화 규칙을 정리해보세요.

## ✅ 안전한 순회 방법

1. 삽입/삭제를 하면서 순회하는 안전한 방법은 무엇인가요?

2. erase 반환값을 활용하는 방법은 무엇인가요?

3. 반복문에서 컨테이너를 수정할 때 주의해야 할 점은 무엇인가요?

## ✅ 실무 버그 패턴

1. iterator 무효화로 인한 대표적인 버그 패턴은 무엇인가요?

2. 재할당 후 iterator를 사용하는 버그를 어떻게 방지하나요?

3. erase 후 iterator를 사용하는 버그를 어떻게 방지하나요?

4. 범위 기반 for문에서 컨테이너를 수정할 때 주의할 점은 무엇인가요?

## ✅ erase 반환값 활용

1. erase가 iterator를 반환하는 이유는 무엇인가요?

2. erase 반환값을 활용한 안전한 삭제 패턴을 설명해보세요.

3. C++11 이전과 이후의 erase 동작 차이는 무엇인가요?

## ✅ 실무 / 설계 판단

1. iterator 안정성이 중요한 경우 어떤 컨테이너를 선택해야 하나요?

2. iterator 무효화를 고려한 안전한 코드 작성 원칙은 무엇인가요?

3. iterator 무효화 규칙을 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. 컨테이너의 구조 변경(삽입, 삭제, 재할당)으로 인해 iterator가 더 이상 유효하지 않게 되는 현상입니다.
2. 무효화된 iterator를 사용하면 정의되지 않은 동작(undefined behavior)이 발생합니다.
3. 컨테이너 변경 후 iterator를 갱신하거나, iterator 안정성이 보장되는 컨테이너를 사용합니다.

### ✅ 컨테이너별 무효화 규칙

1. 재할당 시 모든 iterator가 무효화되고, 중간 삽입/삭제 시 해당 위치 이후의 iterator가 무효화됩니다.
2. 중간 삽입/삭제 시 해당 위치 이후의 iterator가 무효화되고, 앞뒤 삽입은 무효화되지 않습니다.
3. erase된 노드의 iterator만 무효화되고, 다른 iterator는 유효합니다.
4. erase된 요소의 iterator만 무효화되고, 다른 iterator는 유효합니다.
5. rehash 시 모든 iterator가 무효화되고, erase된 요소의 iterator만 무효화됩니다.

### ✅ 무효화 규칙 정리표

1. vector: 재할당 시 모두 무효화, 중간 삽입 시 이후 무효화 / deque: 중간 삽입 시 이후 무효화 / list/set/map: 무효화 없음 / unordered: rehash 시 모두 무효화
2. vector: 재할당 시 모두 무효화, 중간 삭제 시 이후 무효화 / deque: 중간 삭제 시 이후 무효화 / list/set/map: 삭제된 것만 무효화 / unordered: 삭제된 것만 무효화
3. vector/deque: 재할당 시 모두 무효화 / unordered: rehash 시 모두 무효화 / list/set/map: 재할당 없음

### ✅ 안전한 순회 방법

1. erase 반환값을 사용하거나, 역방향 순회, 또는 삭제할 요소를 먼저 수집한 후 일괄 삭제합니다.
2. `it = vec.erase(it);` 형식으로 erase 반환값(다음 유효한 iterator)을 받아 사용합니다.
3. 반복문 내에서 컨테이너를 수정할 때는 iterator 무효화 규칙을 고려해 iterator를 적절히 갱신해야 합니다.

### ✅ 실무 버그 패턴

1. 재할당 후 iterator 사용, erase 후 iterator 사용, 범위 기반 for문에서 컨테이너 수정 등이 있습니다.
2. 재할당 후에는 iterator를 다시 얻거나, 재할당이 발생하지 않도록 reserve를 사용합니다.
3. erase 반환값을 사용하거나, 역방향 순회를 사용해 삭제 후 iterator를 안전하게 처리합니다.
4. 범위 기반 for문에서는 컨테이너 구조를 변경하면 안 되며, 요소 값만 수정해야 합니다.

### ✅ erase 반환값 활용

1. 안전한 순회를 위해 다음 유효한 iterator를 반환하기 위해서입니다.
2. `for (auto it = vec.begin(); it != vec.end(); ) { if (조건) it = vec.erase(it); else ++it; }` 패턴을 사용합니다.
3. C++11 이후부터는 erase가 다음 iterator를 반환하지만, 이전에는 void였습니다.

### ✅ 실무 / 설계 판단

1. iterator 안정성이 중요하면 list, forward_list, map, set 등을 선택합니다.
2. 컨테이너 변경 후 iterator 갱신, erase 반환값 활용, 재할당 고려, 범위 기반 for문 주의 등의 원칙을 따릅니다.
3. iterator 무효화 규칙은 "컨테이너 구조 변경 시 영향받는 iterator 범위가 컨테이너마다 다르다"는 것입니다.

</div>
</details>
