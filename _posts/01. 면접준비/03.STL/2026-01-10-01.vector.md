---
title: 
date: 2026-01-10 21:33:01 +09:00
categories: [면접준비, STL]
published: false
tags:
    [면접준비]
---

# 🧠 C++ std::vector 내부 구조 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. std::vector의 내부 구조는 어떻게 되어 있나요?

    - 벡터는 연속된 메모리구조를 가집니다.

2. std::vector가 연속(contiguous) 메모리를 사용한다는 것은 무슨 의미인가요?

    - 포인터 연산만으로 임의접근이 가능하다는 의미입니다.

## ✅ 핵심 멤버 요소

1. std::vector는 내부적으로 어떤 포인터(또는 개념적 요소)를 가지고 있나요?

    - 내부적으로 연속된 메모리로 할당한 힙이 존재하고, 해당 힙을 가리키는 포인터도 있습니다.

2. size와 capacity의 차이는 무엇인가요?

    - size는 벡터에 요소가 들어간 개수이고, capacity는 내부에 할당된 힙 메모리에 요소가 들어갈 수 있는 총 개수입니다.

## ✅ 메모리 할당 / 재할당

1. vector의 capacity가 부족해지면 내부적으로 어떤 일이 발생하나요?

    - 내부적으로 재할당이 발생합니다. 기존에 갖고 있던 메모리에 추가적인 공간을 할당해야할 때, 기존 공간보다 2배 증가한 크기를 새롭게 할당합니다. 새롭게 할당한 영역에 기존 영역요소들을 새로운 위치로 복사 또는 이동합니다. 복사 대신 이동을 구현했다면 불필요한 복사 비용을 절약할 수 있습니다. 

2. 재할당(reallocation)이 발생하면 기존 원소들은 어떻게 되나요?

    - 재할당이 발생하면 기존 원소들은 새로 할당된 영역으로 복사 또는 이동이 발생합니다.

3. 재할당 시 iterator, pointer, reference는 어떻게 되나요?

    - 유효하지 않은 접근이 되므로, 갱신해야 합니다.

## ✅ 성능 특성

1. push_back의 평균 시간 복잡도가 O(1)인 이유는 무엇인가요?

    - capacity가 size보다 클 때는 지정된 위치에 값을 기입만 하면 되기 때문에 O(1)이라고 할 수 있습니다. 평균 시간 복잡도라고 하는 이유는 capacity와 size가 같을 때 추가하려고 하면 새로운 공간을 할당하고, N만큼 복사 또는 이동이 수행되기 때문에 종종 O(N)이 발생합니다. 따라서 주로 발생하는 O(1)로 평균 시간 복잡도를 O(1)이라고 합니다.

2. 중간 삽입/삭제가 느린 이유는 무엇인가요?

    - 중간 삽입 삭제 경우에서 수행 된 지점 이후에 있는 요소들을 연속된 메모리를 유지해주어야 하기 때문에 앞쪽으로 당기거나, 뒤쪽으로 N만큼 밀어야하기 때문에 느리다고 표현할 수 있습니다.

## ✅ 이동 / 복사 연계

1. 재할당 시 복사 생성자와 이동 생성자 중 무엇이 사용되나요?

    - 기본적으로 복사 생성자가 사용되고, noexcept로 선언된 이동 생성자가 존재한다면 이동 생성자가 사용됩니다.

2. 이동 생성자가 noexcept일 때 중요한 이유는 무엇인가요?

    - 재할당으로 발생하는 이동 중 예외가 발생하면 어떤 처리를 해야할지 STL이 모르기때문에, 예외가 없다는 것을 보장하는 키워드가 필요합니다.

## ✅ 메모리 관리 API

1. reserve와 resize의 차이는 무엇인가요?

    - reserve는 capacity를 증가시키고, resize는 size를 증가시켜 요소가 초기화됩니다.

2. shrink_to_fit은 내부적으로 무엇을 보장하나요?

    - 모르겠습니다.

## ✅ 설계 판단 / 요약

1. std::vector가 캐시 친화적인 이유는 무엇인가요?

    - 연속된 메모리기 때문에 캐시의 공간친화성으로 캐시 친화적이라고 볼 수 있습니다.

2. std::vector 내부 구조를 한 문장으로 요약해보세요.

    - 힙 할당 된 연속된 메모리 공간을 가진 동적 배열입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 연속된 메모리 블록 위에 동적 크기를 관리하는 컨테이너입니다.
2. 모든 원소가 메모리 상에 연속적으로 배치된다는 의미입니다.

3. 시작 포인터, 끝(size) 포인터, 끝(capacity) 포인터를 개념적으로 가집니다.
4. size는 실제 원소 수, capacity는 재할당 없이 담을 수 있는 최대 수입니다.

5. 더 큰 메모리를 새로 할당하고 기존 원소를 옮깁니다.
6. 새 메모리로 복사 또는 이동됩니다.
7. 모두 무효화됩니다.

8. 일반적으로 capacity를 2배씩 증가시키기 때문에 재할당 빈도가 낮아져 평균 O(1)입니다.
9. 뒤 원소들을 모두 이동시켜야 하기 때문입니다.

10. 이동 생성자가 가능하면 이동, 아니면 복사가 사용됩니다.
11. 예외 안전성을 위해 vector가 이동을 선택할 수 있게 하기 위함입니다.

12. reserve는 capacity만, resize는 size 자체를 변경합니다.
13. capacity를 size에 맞게 줄이려고 시도하지만, 반드시 줄인다고 보장하지는 않습니다. 구현에 따라 무시될 수 있으며, 메모리 단편화나 성능 이유로 실제로 줄이지 않을 수 있습니다.

14. 연속 메모리로 인해 캐시 적중률이 높기 때문입니다.
15. std::vector는 “연속 메모리 + size/capacity를 관리하는 동적 배열”입니다.

</div>
</details>

