---
title: "[코딩테스트] 슬라이딩 윈도우"
date: 2026-01-19 18:27:34 +09:00
categories: [코딩테스트]
published: true
tags:
    [코딩테스트, 슬라이딩 윈도우]
---

## 개요

**연속된 구간을 효율적으로 탐색하기 위한 알고리즘**

합, 길이, 빈도, 조건 충족 여부, 최대/최소값 등을 반복적으로 계산할 때, 새로운 원소를 추가하고, 기존 원소를 제거하면서 상태를 업데이트 하는 방식

O(NK)를 O(N)이나 O(NlogK)로 최적화 할 수 있음

유형: 고정길이 윈도우, 가변길이 윈도우

```cpp
// gpt 기본형 (최대 길이)
int left = 0;
for (int right = 0; right < N; right++) {
    add(right); // 새로운 요소가 들어온다

    while (!valid()) { 
        remove(left);
        left++;
    }

    // valid()를 만족하는 현재 윈도우 [left, right]
    update_answer(left, right);
}

```

---
## 백준

[kdhc7777님의 문제집을 사용했습니다](https://www.acmicpc.net/workbook/view/13351)

> ### [백준 21921: 블로그(실3)](https://www.acmicpc.net/problem/21921)

평범한 슬윈

> ### [백준 12891: DNA 비밀번호(실2)](https://www.acmicpc.net/problem/12891)

평범한 슬윈이긴 하지만 조건을 함수화
여기까진 스스로 정규화가 되진 않았음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
bool Check(const unordered_map<char, int>& cnts) {
	int a = 0, c = 0, g = 0, t = 0;
	for (const auto& [alpha, cnt] : cnts) {
		switch (alpha)
		{
		case 'A':
			a = cnt;
			break;
		case 'C':
			c = cnt;
			break;
		case 'G':
			g = cnt;
			break;
		case 'T':
			t = cnt;
			break;
		default:
			return false;
			break;
		}
	}

	return a >= acgt[0] && c >= acgt[1] && g >= acgt[2] && t >= acgt[3];
}

void Solution() {
	// um으로 추적
	unordered_map<char, int> cnts;

	for (int i = 0; i < P; i++) {
		cnts[text[i]]++;
	}

	int cnt = 0;
	if (Check(cnts)) cnt++;

	for (int i = P; i < S; i++) {
		cnts[text[i - P]]--;
		cnts[text[i]]++;

		if (Check(cnts)) cnt++;
	}

	cout << cnt << '\n';
}
```

{: file=''}
</div>
</details>


> ### [백준 15565: 귀여운 라이언(실1)](https://www.acmicpc.net/problem/15565)

가변 슬윈
이때까진 헷갈리긴 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	int cnt = 0, right = 0, left = 0;
	int len = INF;
	while (left <= right) {
		while (right < N && cnt < K) {
			if (nums[right++] == 1) cnt++;
		}

		while (left <= right && nums[left++] != 1) {}

		if (cnt == K)
			len = min(len, right - left + 1);

		cnt--;
	}
	if (len == INF)
		cout << -1 << '\n';
	else
		cout << len << '\n';
}
```

{: file=''}
</div>
</details>



> ### [백준 10025: 게으른 백곰(실3)](https://www.acmicpc.net/problem/10025)

평범한 슬윈

> ### [백준 12847: 꿀 아르바이트(실3)](https://www.acmicpc.net/problem/12847)

평범한 슬윈

> ### [백준 24499: blobyum(실4)](https://www.acmicpc.net/problem/24499)

원형 슬윈
N+K만큼 반복하고, 모듈러 연산자로 나눠줌
여기서부터 형태를 잡음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	int left = 0, sum = 0, ret = 0;
	for (int right = 0; right < N + K; right++) {
		sum += A[right % N];

		while (right - left >= K) {
			sum -= A[left % N];
			left++;
		}

		ret = max(ret, sum);
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>

> ### [백준 8933: MCS(실3)](https://www.acmicpc.net/problem/8933)

정의한 구조체를 맵에 넣어야 하는 문제
지금 푼 방법으로는 개인적으로 실3은 아니라고 생각됨... ㄷㄷ

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
struct ACGT {
	int a = 0;
	int c = 0;
	int g = 0;
	int t = 0;

	bool operator<(const ACGT& other) const {
		if (a != other.a) return a < other.a;
		if (c != other.c) return c < other.c;
		if (g != other.g) return g < other.g;
		return t < other.t;
	}
};

void ACGTChange(char ch, ACGT& data, int delta) {
	switch (ch)
	{
	case 'A':
		data.a += delta;
		break;
	case 'C':
		data.c += delta;
		break;
	case 'G':
		data.g += delta;
		break;
	case 'T':
		data.t += delta;
		break;
	default:
		break;
	}
}

void Solution() {
	int N = str.size();
	if (K >= N) {
		cout << 1 << '\n';
		return;
	}

	int left = 0, ret = 0;
	map<ACGT, int> cnts;
	ACGT cur;
	for (int right = 0; right < N; right++) {
		ACGTChange(str[right], cur, 1);

		while (right - left + 1 >= K) {
			ret = max(ret, ++cnts[cur]);
			ACGTChange(str[left++], cur, -1);
		}
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>



> ### [백준 13422: 도둑(골4)](https://www.acmicpc.net/problem/13422)

평범한 원형 슬윈같은데, 전체에 대한 처리를 따로 해줘야 했음
추가로 처음엔 for문 도는 방식을 잘못해서 틀렸었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	if (N == M) {
		int sum = 0;
		// 틀린 포문
		// for(int money : Money)
		for (int i = 0; i < N; i++)
			sum += Money[i];
		if (sum < K)
			cout << 1 << '\n';
		else
			cout << 0 << '\n';
		return;
	}

	int ret = 0, left = 0, sum = 0;
	for (int right = 0; right < N + M - 1; right++) {
		sum += Money[right % N];

		while (right - left + 1 >= M) {
			if (sum < K)
				ret++;
			sum -= Money[left % N];
			left++;
		}
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>


> ### [백준 2531: 회전 초밥(실1)](https://www.acmicpc.net/problem/2531)

종류의 개수를 추적하는 um
종류의 증감을 위한 상황을 정의해야 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	unordered_map<int, int> cnts;

	int left = 0, kind = 0, ret = 0;
	for (int right = 0; right < N + k; right++) {
		cnts[sushi[right % N]]++;
		if (cnts[sushi[right % N]] == 1) kind++;

		while (right - left + 1 >= k) {
			// 종류 개수 세기
			int valid = 0;
			if (cnts[c] == 0) valid = 1;
			ret = max(ret, kind + valid);

			// 왼쪽 빼기
			cnts[sushi[left % N]]--;
			if (cnts[sushi[left % N]] == 0) kind--;
			left++;
		}

	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>



> ### [백준 15961: 회전 초밥(골4)](https://www.acmicpc.net/problem/15961)

2531문제와 다르지 않지만 입력이 최대 3만에서 300만으로 변경됨

> ### [백준 3078: 좋은 친구(골4)](https://www.acmicpc.net/problem/3078)

조합의 개수를 세는 방법이 떠오르지 않으면 어려울 수 있음
더할 때 현재 있는 길이의 개수들 -1 만큼 더하기
타입 문제도 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	long long left = 0, ret = 0;
	int cnts[21];
	memset(cnts, 0, sizeof(cnts));

	for (int right = 0; right < N; right++) {
		cnts[Names[right].size()]++;

		while (right - left > K) {
			cnts[Names[left++].size()]--;
		}

		if (cnts[Names[right].size()] > 1)
			ret += cnts[Names[right].size()] - 1;
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>

---
# LeetCode(Easy)

> ### [LeetCode 643: Maximum Average Subarray1](https://leetcode.com/problems/maximum-average-subarray-i/)

기본 슬윈

> ### [LeetCode 219: Contains Duplicate 2](https://leetcode.com/problems/contains-duplicate-ii/)

슬윈 안에 들어가있는 개수를 세는 문제
um 사용

---
# LeetCode(Med)

> ### [LeetCode 1695: Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/)

슬윈 안에 개수 세는 문제
가변 슬윈
left를 중복되는 순간 이후까지

> ### [LeetCode 3: Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

1695번 문제와 완전히 같음
char 버전

> ### [LeetCode 209: Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

조건을 만족하는 슬윈 중 최단 사이즈

> ### [LeetCode 904: Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)

종류의 개수를 세야함
여러개가 들어갈 수도 있어서 set과 um 사용

> ### [LeetCode 567: Permutation in String](https://leetcode.com/problems/permutation-in-string/)

한 string의 구성요소를 모두 갖고있는지 확인하는 슬윈

> ### [LeetCode 438: Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

567번 문제랑 같음

> ### [LeetCode 1004: Max COnsecutive Ones 3](https://leetcode.com/problems/max-consecutive-ones-iii/)

바꿀 수 있는 개수만큼 바꿨을 때 최대 개수
백트래킹과 헷갈릴 수 있을듯
필요한 것과 다른 것의 개수를 유지하면 됨

> ### [LeetCode 1052: Grumpy Bookstore Owner](https://leetcode.com/problems/grumpy-bookstore-owner/)

특정 조건에 해당하는 요소들만 따로 분리해서 슬윈
처음 떠올리기까지 시간이 좀 걸림

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int ret = 0, left = 0, notGrumpySum = 0;

        for (int i = 0; i < customers.size(); i++) {
            notGrumpySum += grumpy[i] ? 0 : customers[i];
        }

        int grumpySum = 0;
        for (int right = 0; right < customers.size(); right++) {
            grumpySum += grumpy[right] ? customers[right] : 0;

            if (right - left + 1 > minutes) {
                grumpySum -= grumpy[left] ? customers[left] : 0;
                left++;
            }

            ret = max(ret, grumpySum);
        }

        return ret + notGrumpySum;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 1493: Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

가변슬윈을 0 개수로 조절하기

---
# LeetCode(Hard)

> ### [LeetCode 76: Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

옛날에 풀었었지만 현재가 더 잘 푼듯
left를 변화시킬 때 마다 substr을 하는 것이 오버헤드

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int sCnts[128];
    unordered_map<char, int> tCnts;

    bool IsSubstring() {

        for (auto& [c, cnt] : tCnts) {
            if (sCnts[c] < cnt)
                return false;
        }

        return true;
    }

    string minWindow(string s, string t) {
        if (t.size() > s.size())
            return "";

        for (char c : t) {
            tCnts[c]++;
        }

        string ret = "";
        int left = 0;

        for (int right = 0; right < s.size(); right++) {
            sCnts[s[right]]++;

            if (IsSubstring()) {

                while (IsSubstring()) {
                    sCnts[s[left]]--;
                    left++;
                }

                if (ret == "" || right - left + 1 < ret.size()) {
                    ret = s.substr(left - 1, right - left + 2);
                }
            }
        }

        return ret;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 239: Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

옛날에 풀었던 문제
idx와 val를 갖는 구조체를 품는 pq로 감고, 되감고를 반복
찾아보니 lazy deletion이라고도 하는듯

<details>
<summary>옛날 코드</summary>
<div markdown="1">

```cpp
옛날 ver
class Solution {
public:
    struct Data{
        int idx;
        int val;
    };

    struct cmp{
        bool operator()(const Data& d1, const Data& d2){
            return d1.val == d2.val ? d1.idx > d2.idx : d1.val < d2.val;
        }
    };

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<Data, vector<Data>, cmp> pq;

        vector<int> res;
        for (int i = 0; i < k; i++) {
            pq.push({i, nums[i]});
        }
        res.push_back(pq.top().val);

        for(int i = k ; i<nums.size(); i++){
            pq.push({i, nums[i]});
            int popNum = nums[i-k];

            if(popNum == pq.top().val){
                while(!pq.empty()){
                    pq.pop();
                    if(pq.top().idx > i-k){
                        break;
                    }
                }
            }
            res.push_back(pq.top().val);
        }
        return res;
    }
};

```

{: file=''}
</div>
</details>



이번엔 map을 사용해서 가장 끝에 있는 key를 참조하도록 함
성능은 느려지긴 했지만 굉장히 쉽게 품

<details>
<summary>이번 코드</summary>
<div markdown="1">

```cpp
현재 ver
class Solution {
public:
    map<int, int> cnts;
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ret;
        
        int left = 0;
        for(int right = 0; right < nums.size(); right++){
            cnts[nums[right]]++;

            if(right - left + 1 == k){
                ret.push_back((--cnts.end())->first);
                cnts[nums[left]]--;
                if(cnts[nums[left]] == 0){
                    cnts.erase(nums[left]);
                }
                left++;
            }
        }

        return ret;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 480: Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)

lower_bound와 insert로 정렬된 상태를 유지하며 중앙 값을 찾음
처음엔 맵으로도 해봤지만 가운데 지점을 찾는 시간이 오버헤드

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<int> window;
        vector<double> ret;

        int left = 0;

        for (int right = 0; right < nums.size(); right++) {
            window.insert(
                lower_bound(window.begin(), window.end(), nums[right]),
                nums[right]);

            if (right - left + 1 == k) {
                double val = 0;
                int idx = (k - 1) / 2;
                val += window[idx];
                if (!(k & 1)) {
                    val += window[idx + 1];
                    val /= 2;
                }
                ret.push_back(val);

                window.erase(
                    lower_bound(window.begin(), window.end(), nums[left]));
                left++;
            }
        }

        // for(int i : window){
        //     cout << i << ' ';
        // }

        return ret;
    }
};
```

{: file=''}
</div>
</details>
