---
title: "[코딩테스트] DFS"
date: 2026-01-19 19:09:34 +09:00
categories: [코딩테스트]
published: true
tags:
    [코딩테스트, DFS]
---

## 개요

** 한 방향으로 갈 수 있을 때까지 갔다가, 더이상 갈 곳이 없으면 되돌아오는 완전 탐색 방식 **
유형: 그래프 탐색, 경로 탐색, 백트래킹, 사이클 판별
visited 배열이 필수
가능 한 인접 리스트로 엣지 관리

---
## 백준

> ### [백준 11724: 연결 요소의 개수(실2)](https://www.acmicpc.net/problem/11724)
> ### [백준 2606: 바이러스(실3)](https://www.acmicpc.net/problem/2606)
> ### [백준 1260: DFS와 BFS(실2)](https://www.acmicpc.net/problem/1260)
> ### [백준 2667: 단지번호붙이기(실1)](https://www.acmicpc.net/problem/2667)
> ### [백준 1012: 유기농 배추(실2)](https://www.acmicpc.net/problem/1012)
> ### [백준 1926: 그림(실1)](https://www.acmicpc.net/problem/1926)
> ### [백준 1303: 전쟁 - 전투(실1)](https://www.acmicpc.net/problem/1303)
> ### [백준 2468: 안전영역(실1)](https://www.acmicpc.net/problem/2468)
> ### [백준 2583: 영역 구하기(실1)](https://www.acmicpc.net/problem/2583)

기본

- 기본형
```cpp
int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };

bool IsValid(int r, int c) {
	if (r < 0 || r >= N || c < 0 || c >= M)return false;
	return !maps[r][c];
}

void DFS(int r, int c) {
	for (int i = 0; i < 4; i++) {
		int nr = r + dr[i];
		int nc = c + dc[i];

		if (IsValid(nr, nc)) {
			maps[nr][nc] = 0;
			DFS(nr, nc);
		}
	}
}
```

> ### [백준 4963: 섬의 개수(실2)](https://www.acmicpc.net/problem/4963)

대각선 움직임이 있음

> ### [백준 1987: 알파벳(골4)](https://www.acmicpc.net/problem/1987)

visited가 요소에 종속적

> ### [백준 16929: Two Dots(골4)](https://www.acmicpc.net/problem/16929)
> ### [백준 9466: 텀 프로젝트(골3)](https://www.acmicpc.net/problem/9466)

사이클을 찾는 문제
finished 사용 필요

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int DFS(int idx) {
	int ret = 0;

	int next = nums[idx];
	if (!visited[next]) {
		visited[next] = true;
		ret += DFS(next);
	}
	else if (!finished[next]) {
		int cur = nums[idx];
		while (true) {
			ret++;
			if (cur == idx) break;
			cur = nums[cur];
		}
	}

	finished[idx] = true;

	return ret;
}
```

{: file=''}
</div>
</details>



> ### [백준 2239: 스도쿠(골4)](https://www.acmicpc.net/problem/2239)

네모를 지정하는 식을 헷갈렸음
시간초과나서 보니까 O(1)로 검사할 수 있는 방법이 있었음
추가적으로, 검사해야 할 지점을 뽑는 것도 줄일 수 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 처음 시간초과 코드
bool IsValid(int r, int c) {
	FOR(i, 9) {
		memset(cnt, 0, sizeof(cnt));
		FOR(j, 9) {
			if (maps[i][j] != 0) {
				cnt[maps[i][j]]++;
				if (cnt[maps[i][j]] > 1) return false;
			}
		}
	}

	FOR(i, 9) {
		memset(cnt, 0, sizeof(cnt));
		FOR(j, 9) {
			if (maps[j][i] != 0) {
				cnt[maps[j][i]]++;
				if (cnt[maps[j][i]] > 1) return false;
			}
		}
	}

	memset(cnt, 0, sizeof(cnt));
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (maps[(r / 3) * 3 + i][(c / 3) * 3 + j] != 0) {
				if (++cnt[maps[(r / 3) * 3 + i][(c / 3) * 3 + j]] > 1)return false;
			}
		}
	}

	return true;
}
```

```cpp
// O(1)로 변경
bool IsValid(int r, int c, int num) {
	if (rused[r][num] || cused[c][num] || bused[(r / 3) * 3 + c / 3][num]) return false;

	return true;
}
```

```cpp
// 검사 리스트 탐색시간 줄이기
bool DFS(int idx) {
    // 모든 빈 칸을 다 채웠으면 성공
    if (idx == (int)blanks.size()) return true;

    int r = blanks[idx].first;
    int c = blanks[idx].second;
    int b = GetBoxIndex(r, c);
}
```

{: file=''}
</div>
</details>

> ### [백준 1182: 부분수열의 합(실2)](https://www.acmicpc.net/problem/1182)

입력이 0일 때 예외가 필요

> ### [백준 11403: 경로 찾기(실1)](https://www.acmicpc.net/problem/11403)

플루이드 워셜
플루이드 워셜인지 알아채지 못했었음
DFS로 플루이드 워셜을 구현하는 것도 생각해내지 못함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void DFS(int r) {
	for (int i = 0; i < N; i++) {
		if (!visited[i] && maps[r][i] == 1) {
			visited[i] = true;
			DFS(i);
		}
	}
}

void Solution() {

	for (int i = 0; i < N; i++) {
		memset(visited, 0, sizeof(visited));
		DFS(i);
		for (int j = 0; j < N; j++) {
			cout << visited[j] << ' ';
		}
		cout << '\n';
	}
}

```

{: file=''}
</div>
</details>

> ### [백준 15686: 치킨 배달(골5)](https://www.acmicpc.net/problem/15686)

드디어 한 번에 품 ㅋㅋㅋ 으하
치킨집을 선택하는 함수와 치킨 거리를 구하는 함수로 나눠서 차근차근
집 위치와 치킨집 위치를 배열로 따로 구분

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int ChickenLen(const vector<int>& S) {
	int ret = 0;
	FOR(i, H.size()) {
		int hr = H[i].first, hc = H[i].second;
		int minValue = INF;
		FOR(j, M) {
			int cr = C[S[j]].first, cc = C[S[j]].second;
			int len = abs(hr - cr) + abs(hc - cc);
			minValue = min(minValue, len);
		}

		ret += minValue;
	}

	return ret;
}

int  DFS(int idx, vector<int>& selected) {
	int ret = INF;
	if (selected.size() == M) {
		return ChickenLen(selected);
	}
	if (idx == C.size())return INF;

	ret = min(ret, DFS(idx + 1, selected));
	selected.push_back(idx);

	ret = min(ret, DFS(idx + 1, selected));
	selected.pop_back();

	return ret;
}
```

{: file=''}
</div>
</details>


> ### [백준 1520: 내리막 길(골3)](https://www.acmicpc.net/problem/1520)

cache가 필수

---
## LeetCode(Easy)

> ### [LeetCode 733: Floot Fill](https://leetcode.com/problems/flood-fill/)

인접 영역을 같은 값으로 변경하기

> ### [LeetCode 463: Island Perimeter](https://leetcode.com/problems/island-perimeter/)

인접 영역의 테두리 세기
생각해내지 못하면 상당히 어려울듯
인접 영역이 아닌 다른 영역을 완탐으로 돌면서 땅의 개수를 셈

> ### [LeetCode 617: Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/)

Tree 합치기

> ### [LeetCode 104: Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

최고 깊이 찾기

> ### [LeetCode 257: Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)

지정된 string의 글자 찾아가기

---
## LeetCode(Med)

> ### [LeetCode 200: Number of Islands](https://leetcode.com/problems/number-of-islands/)

이젠 손가락이 아플정도

> ### [LeetCode 695: Max Area of Island](https://leetcode.com/problems/max-area-of-island/)

가장 큰 영역 찾기

> ### [LeetCode 207: Course Schedule](https://leetcode.com/problems/course-schedule/)

위상정렬인데 그냥 사이클 여부 판단하는거라 finished 배열로 해결

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    vector<vector<int>> edges;
    int N;
    vector<int> visited;
    vector<int> finished;

    bool DFS(int n){
        
        for(int i = 0; i < edges[n].size(); i++){
            int next = edges[n][i];
            if(!visited[next]){
                visited[next] = true;
                if(!DFS(next))return false;
            }else if(!finished[next]){
                return false;
            }
        }

        finished[n] = true;
        return true;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 위상정렬 같긴한데, 그냥 사이클판별하면 되는것 같기도?
        N = numCourses;
        edges.resize(N);
        visited.resize(N);
        finished.resize(N);
        for(const vector<int>& v:prerequisites){
            edges[v[0]].push_back(v[1]);
        }

        for(int i = 0 ; i < N; i++){
            if(!visited[i]){
                visited[i] = true;
                if(!DFS(i))return false;
            }
        }

        return true;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 1466: Reorder Routes to Make All Paths Lead to the City Zero](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

0이 캐피탈
0부터 DFS로 돌면서 뒤집혀있으면 개수++

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    vector<vector<pair<int, int>>> edges;
    vector<int> visited;
    int N;

    void Init(int n, vector<vector<int>>& connections){
        N = n;
        edges.resize(n);
        visited.resize(n);
        for(int i = 0 ; i < n-1; i++){
            int n1 = connections[i][0], n2 = connections[i][1];
            edges[n1].push_back({n1, n2});
            edges[n2].push_back({n1, n2});
        }
    }

    int DFS(int n){
        int ret = 0;
        for(int i = 0 ; i < edges[n].size(); i++){
            auto cand = edges[n][i];
            bool reverse = (cand.first == n) ? true : false;
            int next = reverse ? cand.second : cand.first;
            
            if(!visited[next]){
                visited[next] = true;
                ret += reverse ? 1 : 0;
                ret += DFS(next);
            }
        }

        return ret;
    }

    int minReorder(int n, vector<vector<int>>& connections) {
        Init(n, connections);

        visited[0] = true;
        return DFS(0);
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 79: Word Search](https://leetcode.com/problems/word-search/)

지정된 string의 글자 찾아가기

> ### [LeetCode 129: Sum Roots to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)

257번과 매우 유사

> ### [LeetCode 547: Numbers of Provinces](https://leetcode.com/problems/number-of-provinces/)

인접영역 개수 찾기

> ### [LeetCode 841: Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/)

기본

> ### [LeetCode 130: Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)

가장자리 인접영역만

> ### [LeetCode 698: Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)

지금까지 가장 어려웠음
백트래킹으로 예외처리가 많이 필요
sort, 조합에 대한 중복처리, 같은 값 여부 등

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int N, K;
    int sum = 0, target = 0;
    vector<int> m_nums, visited;
    bool DFS(int cur, int idx, int group) {
        if (group == K - 1)
            return true;
        if (cur == target) {
            return DFS(0, 0, group + 1);
        }

        int prev = -1;
        for (int i = idx; i < N; i++) {
            if (m_nums[i] == prev || visited[i] || cur + m_nums[i] > target)
                continue;
                
            visited[i] = true;
            if (DFS(cur + m_nums[i], i + 1, group))
                return true;
            visited[i] = false;
            prev = m_nums[i];
        }

        return false;
    }
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), greater<int>());
        m_nums = nums;
        N = nums.size(), K = k;

        visited.resize(N);
        for (int num : nums)
            sum += num;

        target = sum / k;

        if (sum % k != 0 || nums[0] > target)
            return false;

        return DFS(0, 0, 0);
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 39: Combinations Sum](https://leetcode.com/problems/combination-sum/)

조합하기
sort해줬어야 함
오랜만에 종만북 느낌

> ### [LeetCode 40: Combinations Sum 2](https://leetcode.com/problems/combination-sum-ii/)

39번에서 idx 하나 늘리기가 필요하지만 수열에 대한 중복 처리가 필요
698번에서 했던 prev 예외가 필요

> ### [LeetCode 46: Permutations](https://leetcode.com/problems/permutations/)
> ### [LeetCode 47: Permutations 2](https://leetcode.com/problems/permutations-ii/)

next_permutation

> ### [LeetCode 417: Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)

Pacific쪽에서 오르는 쪽으로, Atlantic쪽에서 오르는 쪽으로 둘 다 오를 수 있는 지점 반환


---
## LeetCode(Hard)

> ### [LeetCode 332: Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)

set을 while문으로 지우면서 사용하는 것이 핵심

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    unordered_map<string, multiset<string>> edges;
    vector<string> ret;

    void DFS(const string& from){
        
        while(!edges[from].empty()){
            auto iter = edges[from].begin();
            string to = *iter;
            edges[from].erase(iter);
            DFS(to);
        }
        ret.push_back(from);
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(int i = 0 ; i < tickets.size(); i++){
            string s1 = tickets[i][0], s2 = tickets[i][1];
            edges[s1].insert(s2);
        }

        DFS("JFK");

        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 329: Longest Increasing Path in Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)

백준 1520 문제와 유사

> ### [LeetCode 212: Word Search 2](https://leetcode.com/problems/word-search-ii/)

Trie가 필요함
풀었다고 볼 수 없음
매우 어려움

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    struct Trie {
        Trie* child[26];
        string word;

        Trie() {
            word = "";
            memset(child, 0, sizeof(child));
        }
    };

    void BuildTrie(Trie* root, const vector<string>& words) {
        for (int i = 0; i < words.size(); i++) {
            string word = words[i];

            Trie* node = root;
            for (int j = 0; j < word.size(); j++) {
                int idx = word[j] - 'a';
                if (node->child[idx] == nullptr) {
                    node->child[idx] = new Trie;
                }
                node = node->child[idx];
            }
            node->word = word;
        }
    }

    vector<vector<char>> m_board;
    vector<string> ret;
    int N, M;
    int dr[4] = {1, 0, -1, 0};
    int dc[4] = {0, 1, 0, -1};

    bool IsValid(int r, int c, const vector<vector<int>>& visited) {
        if (r < 0 || r >= N || c < 0 || c >= M)
            return false;
        return !visited[r][c];
    }
    void DFS(int r, int c, vector<vector<int>>& visited, Trie* node) {
        char ch = m_board[r][c];
        int idx = ch - 'a';
        Trie* next = node->child[idx];
        if (next == nullptr)
            return;

        if (next->word != "") {
            ret.push_back(next->word);
            next->word.clear();
        }

        for(int i = 0; i <4 ;i++){
            int nr = r + dr[i];
            int nc = c + dc[i];
            if(IsValid(nr, nc, visited)){
                visited[nr][nc] = true;
                DFS(nr, nc, visited, next);
                visited[nr][nc] = false;
            }
        }
    }

    vector<string> findWords(vector<vector<char>>& board,
                             vector<string>& words) {
        Trie* root = new Trie;
        BuildTrie(root, words);
        m_board = board;
        N = m_board.size(), M = m_board[0].size();
        vector<vector<int>> visited(N, vector<int>(M));
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                visited[i][j] = true;
                DFS(i, j, visited, root);
                visited[i][j] = false;
            }
        }

        return ret;
    }
};
```

{: file=''}
</div>
</details>
