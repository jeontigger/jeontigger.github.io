---
title: "[코딩테스트] 배낭문제"
date: 2026-01-19 18:14:18 +09:00
categories: [코딩테스트]
published: true
tags:
    [코딩테스트, 배낭문제]
---

## 개요
**아이템이 존재하고, 아이템에 무게(Weight)와 가치(Value)가 존재. 아이템을 한정된 무게에서 가장 많은 가치를 가져가고 싶은 문제를 해결하기 위함. DP의 발전된 종류라고 볼 수 있음**

시간복잡도: 기본은 O(N\*W)
유형: 물건을 한 번만 선택할 수 있는 문제(0/1 냅색), 물건을 무한히 선택할 수 있는 문제, 물건을 일부만 쪼개서 선택 가능한 문제, 넣을 배낭이 여러개인 문제, DP 발전형

선택 여부, 제한 조건, 최대 가치 or 최소 비용의 목표가 있으면 배낭 문제일 가능성을 염두해야 함

> ### 0/1 냅색

W를 순회할 때 W부터 item[i].weight까지 반대로 순회해야 저장한 데이터를 중복해서 활용하지 않음
중복되선 안되는 속성을 가장 바깥쪽 반복문의 요소로 선택해야 함

> ### 무한 냅색

W를 순회할 때 0/1 냅색과 반대로 item[i].weight부터 W까지 차례대로 순회하면 됨

> ### 제한 냅색

여러개가 있을 수는 있지만 무한은 아니고 제한된 개수를 갖고있는 냅색 문제

갖고있는 개수를 2의 제곱수(비트단위)로 가치와 무게를 분할해서 0/1 냅색으로 만들어야 함

> ### 넣을 배낭이 여러개인 문제

- A그룹에 넣을 경우, B그룹에 넣을 경우
- A그룹에 넣을 경우, B그룹에 넣을 경우, 두 그룹 모두 안넣을 경우
두 그룹의 차이에 대해 인덱스로 갖는 경우가 있음
[0~i]까지의 합을 인덱스로 갖는 경우가 있음
양과 음의 영역으로 나누는 경우도 있음

---
## 백준

> ### [백준 12865: 평범한 배낭(골5)](https://www.acmicpc.net/problem/12865)

가장 기본적인 0/1 배낭 문제



<details>
<summary>기본형</summary>
<div markdown="1">

```cpp
void Solution() {
	vector<int> knapsack(vector<int>(K + 1));

	for (int i = 0; i < N; i++) {
		Item item = items[i];
		for (int j = K; j >= item.w; j--) {
			knapsack[j] = max(last[j], last[j - item.w] + item.v);
		}
	}

	cout << *max_element(knapsack.begin(), knapsack.end());
}
```
{: file=''}
</div>
</details>



> ### [백준 9084: 동전(골5)](https://www.acmicpc.net/problem/9084)

물건을 무한히 선택할 수 있는 배낭 문제

<details>
<summary>기본형</summary>
<div markdown="1">

```cpp
void Solution() {
	vector<int> dp(M + 1, 0);
	dp[0] = 1;

	for (int i = 0; i < N; i++) {
		int coin = coins[i];
		for (int j = coin; j < dp.size(); j++) {
			dp[j] += dp[j - coin];
		}

	}

	cout << dp[M] << '\n';
}
```

{: file=''}
</div>
</details>

> ### [백준 14728: 벼락치기(골5)](https://www.acmicpc.net/problem/14728)

0/1 기본 문제

> ### [백준 1535: 안녕(실2)](https://www.acmicpc.net/problem/1535)

0/1 기본 문제

> ### [백준 2293: 동전 1(골4)](https://www.acmicpc.net/problem/2293)

9084번 문제와 크게 차이 없음

> ### [백준 2294: 동전 2(골5)](https://www.acmicpc.net/problem/2294)

찾고자 하는 값이 경우의 수가 아니라 개수로 변경 됐을 뿐

> ### [백준 1106: 호텔(골4)](https://www.acmicpc.net/problem/1106)

무한 냅색과 유사
물건을 샀을 때 영향받는 범위에 대한 고려가 필요했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	// 최대 인원수를 더해줘야하는데 왜그런지 이해는 못했음
	vector<int> dp(C + 100, INF);
	dp[0] = 0;
	for (int i = 0; i < N; i++) {
		// 물건 샀을 때 영향 받는 부분
		for (int j = 1; j < value[i]; j++) {
			dp[j] = min(dp[j], cost[i]);
		}
        
		for (int j = value[i]; j <= C; j++) {
			dp[j] = min(dp[j], dp[j - value[i]] + cost[i]);
		}
	}
	cout << dp[C] << '\n';
}
```

{: file='호텔.cpp'}
</div>
</details>


> ### [백준 4384: 공평하게 팀 나누기(골1)](https://www.acmicpc.net/problem/4384)

상당히 어려웠음(아예 풀었다고 볼 수가 없음)
냅색을 발전시켜 dp를 푸는 느낌
k 무게가 가능한지 여부를 물어보는 bool dp를 구성하는 것이 핵심
0/1로 선택해야하는 선택지는 항상 가장 바깥 반복문에 있어야 함

> ### [백준 7579: 앱(골3)](https://www.acmicpc.net/problem/7579)

M 메모리를 구하기 위한 최소값을 찾는 문제
M메모리가 최대 10억이라 어떤 dp의 idx로 잡느냐를 물어보는 문제같다고 생각
N이 최대 100이고 cost가 최대 100이라 N * cost => 100\*100을 갖는 dp를 생성하고 최대 메모리를 value로 함

> ### [백준 17845: 수강 과목(골5)](https://www.acmicpc.net/problem/17845)

0/1 기본 문제

> ### [백준 16493: 최대 페이지 수(실2)](https://www.acmicpc.net/problem/16493)

0/1 기본 문제

> ### [백준 22115: 창영이와 커피(골5)](https://www.acmicpc.net/problem/22115)

예상외로 생각할게 많았던 문제
dp의 키를 카페인, 밸류를 개수로 둬야 함
K가 0일때를 위한 고려도 필요

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	// 카페인 양 = 커피 개수
	vector<int> dp(K + 1, INF);

	for (int i = 0; i < N; i++) {
		auto before = dp;
		// 초기화가 before선언 전에 이뤄지면 잘못된 동작
		dp[c[i]] = 1;
		for (int j = c[i]; j < dp.size(); j++) {
			if (before[j - c[i]] != INF) {
				dp[j] = min(before[j], before[j - c[i]] + 1);
			}
		}
	}
	if (K == 0)
		cout << 0;
	else if (dp[K] == INF)
		cout << -1;
	else
		cout << dp[K];
}
```

{: file=''}
</div>
</details>



> ### [백준 15817: 배수공사(골4)](https://www.acmicpc.net/problem/15817)

상당히 오래 걸림
쪼갤 수 있는 냅색
아마도 이때는 쪼개는 방법을 정확히 몰랐어서 오래걸렸을듯 함

> ### [백준 2629: 양팔저울(골3)](https://www.acmicpc.net/problem/2629)

이 또한 생각보다 까다로웠음
추를 한쪽에만 올리는게 아니라 구슬을 놓은 곳에 올리거나, 구슬 반대편에 올리거나, 안올리는 3가지 경우를 따져야 함
우선 난 구슬 반대편에 올리는 방식을 모두 하고, 구슬 편에 올리는 방식을 다시 한 번 순회했더니 성공
재귀로 푸는 경우도 있음. N이 적으면 재귀로 푸는게 훨씬 편할듯 함(속도는 느림)

> ### [백준 12920: 평범한 배낭 2(플4)](https://www.acmicpc.net/problem/12920)

배수공사와 마찬가지인 쪼개는 문제
배수공사도 사실 쪼개야 하는 문제였던 것을 깨닳음
쪼개고 나면 별 건 없었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 개수대로 쪼개는 코드
// 
void Init(vector<int>& w, vector<int>& c) {
	for (int i = 0; i < N; i++) {
		for (int j = 1; K[i] > 0; j <<= 1) {
			int n = min(j, K[i]);
			w.push_back(V[i] * n);
			c.push_back(C[i] * n);
			K[i] -= n;
		}
	}
}
```

{: file=''}
</div>
</details>

> ### [백준 4781: 사탕 가게(골4)](https://www.acmicpc.net/problem/4781)

소수점 2째자리 까지만 표기하는 문제
최대 100.00이었기 때문에 100씩 곱해서 정수로 계산
16.40을 double로 입력 받으면 16.39999997로 받는 문제가 있어서 반올림해야 했었음
그 이후로는 무한 배낭문제

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
// 반올림 코드
int N, C[5000], P[5000];
int M;

void Inputs() {
	float m;
	cin >> N >> m;
	M = round(m * 100);
	if (N == 0 && M == 0) exit(0);
	FOR(i, N) {
		int c;
		float p;
		cin >> c >> p;
		C[i] = c;
		P[i] = round(p * 100);
	}
}
```

{: file=''}
</div>
</details>


> ### [백준 18427: 함께 블록 쌓기(골4)](https://www.acmicpc.net/problem/18427)

사람, 블럭, 높이 순으로 포문 도니까 해결

> ### [백준 11066: 파일 합치기(골3)](https://www.acmicpc.net/problem/11066)

이것도 상당히 어려웠음
dp를 [i][j]로 [i]부터 [j]까지 더했을 때 최대 결과값을 가지면 됨
dp를 구성할 때 반환형태(예시로 이번엔 dp[1][N])를 생각하면 dp의 인덱스를 뭐로 잡아야할지 생각날 수 있을 듯 함
실전 코테 준비 전에 한 번씩 다시 보면 좋을 듯 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {

	vector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));
	vector<int> prefix(N + 1);
	for (int i = 1; i <= N; i++) {
		prefix[i] = prefix[i - 1] + num[i - 1];
	}

	//for (int i = 0; i < N; i++) {
	//	dp[i][i] = num[i];
	//}

	for (int len = 2; len <= N; ++len) {
		for (int i = 1; i + len - 1 <= N; ++i) {
			int j = i + len - 1;
			int best = INF;
			for (int k = i; k < j; ++k) {
				best = min(best, dp[i][k] + dp[k + 1][j]);
				//dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefix[j] - prefix[i - 1]);
			}
			dp[i][j] = best + (prefix[j] - prefix[i - 1]);
		}
	}
	cout << dp[1][N] << '\n';

}
```

{: file=''}
</div>
</details>



> ### [백준 23748: 방문 판매(골2)](https://www.acmicpc.net/problem/23748)

두 항목이 동시에 고려되는 배낭 문제
dp를 2차원으로 두면 됨
사이즈를 잘못 고려해서 시간초과 받았었음

---
## LeetCode(Easy)

없음..

---
## LeetCode(Med)

> ### [LeetCode 416: Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/)

하나의 배열을 두 서브셋으로 나누는 문제
두 서브셋의 차이를 구하는 문제에서 전체 합의 절반이 되는 문제로 변경 후 0/1 배낭 문제가 됨
```
Psub + Nsub = sum
Psub - Nsub = 0
Psub = sum/2
```

> ### [LeetCode 494: Target Sum](https://leetcode.com/problems/target-sum/)

양의 서브셋과 음의 서브셋으로 구분하는 0/1 냅색
개수를 세야하다보니 um으로 해결하는게 편안했음

> ### [LeetCode 1049: Last Stone Weight 2](https://leetcode.com/problems/last-stone-weight-ii/description/)

너무 어려웠음
양의 서브셋과 음의 서브셋의 합이 최소가 되는 지점 구하기
```
P + N = sum
|P - N| => |2P - sum| => sum - 2P => sum/2 - P 의 최소값이 되는 순간 P <= sum/2
```

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp

class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        // P + N = sum;
        // N = sum - P;
        // P - N = 2*P - sum 이 가장 작아지는 
        // 
        int S = accumulate(stones.begin(), stones.end(), 0);
        vector<char> dp(S + 1, 0);
        dp[0] = 1;
        for (int w : stones) {
            for (int j = S; j >= w; --j) {
                dp[j] = dp[j] | dp[j - w];
            }
        }
        int best = 0;
        for (int s = S / 2; s >= 0; --s) {
            if (dp[s]) { best = s; break; }
        }
        return S - 2 * best;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 474: Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)

입력을 변경시켜야 함
zero와 one을 인덱스로 갖는 pair dp

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 입력을 0과 1의 개수로 변경
        // dp[0개수][1개수] => 구성할 수 있는 최대 개수?
        // m => 0, n => 1 개수
        int N = strs.size();
        vector<pair<int, int>> nums(N);
        for (int i = 0; i < N; i++) {
            int one = 0, zero = 0;
            for (int j = 0; j < strs[i].size(); j++) {
                if (strs[i][j] == '0')
                    zero++;
                else
                    one++;
            }
            nums[i] = {zero, one};
        }

        int dp[101][101];
        memset(dp, 0, sizeof(dp));

        dp[0][0] = 0;
        for (auto& [zero, one] : nums) {
            for (int i = m; i >= zero; i--) {
                for (int j = n; j >= one; j--) {
                    
                    // if (dp[i - zero][j - one] != 0)
                        dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 322: Coin Change](https://leetcode.com/problems/coin-change/description/)

완전 평범한 무한 배낭

> ### [LeetCode 139: Word Break](https://leetcode.com/problems/word-break/description/)

string을 나눠서 구성하기
[0~i]까지 만들 수 있는지 여부를 저장하는 dp 구성

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int N = s.size(), M = wordDict.size();
        vector<bool> dp(N+1, false);
        dp[0] = true;

        unordered_set<string> dict(wordDict.begin(), wordDict.end());

        for(int i = 0;  i <= N; i++){
            for(int j = 0; j < i; j++){
                if(!dp[j]) continue;

                string str = s.substr(j, i - j);
                
                if(dict.find(str) != dict.end()){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[N];
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 1155: Number of Dice Rolls With Target Sum](https://leetcode.com/problems/word-break/description/)

경우의 수를 세는 문제
이해가 어려웠지만 주사위를 나눠주는 기점에서 레이어를 나눠줘야하기 때문에 dp를 초기화 해줘야하는것이 가장 중요했고 어려웠음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    static constexpr int MOD = 1000000007;
    int numRollsToTarget(int n, int k, int target) {
        vector<int> dp(target + 1);
        dp[0] = 1;

        for (int dice = 1; dice <= n; dice++) {
            auto before = dp;
            // 레이어 초기화
            fill(dp.begin(), dp.end(), 0);
            for (int face = 1; face <= k; face++) {
                for (int sum = face; sum <= target; sum++) {
                    dp[sum] = (dp[sum] + before[sum - face]) % MOD;
                }
            }
        }

        return dp[target];
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 1981: Minimize the Difference Between Target and Chosen Elements](https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/description/)

row가 지날 때 마다 레이어를 분리해야 하는 문제
풀긴 풀었는데 생각보다 실행시간이 느렸음
bitset을 사용하면 훨씬 빨라진다 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int minimizeTheDifference(vector<vector<int>>& mat, int target) {
        // [가능한 합] => 최대 4900
        int N = mat.size();
        int M = mat[0].size();

        vector<int> dp(4901, 0);
        dp[0] = 1;
        for (int row = 0; row < N; row++) {
            auto before = dp;
            fill(dp.begin(), dp.end(), 0);
            for (int col = 0; col < M; col++) {
                int num = mat[row][col];
                for (int i = num; i < dp.size(); i++) {
                    dp[i] = dp[i] | before[i - num];
                }
            }
        }

        if (dp[target])
            return 0;
        int left = target - 1, right = target + 1;
        while(left >= 0 || right < dp.size()){
            if((left >= 0 && dp[left]) || (right < dp.size() && dp[right])){
                return abs(target - left);
            }
            left--;
            right++;
        }
        return 0;
    }
};
```

{: file=''}
</div>
</details>

<details>
<summary>비트셋</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int minimizeTheDifference(vector<vector<int>>& mat, int target) {
        const int MAX_SUM = 70 * 70; // 4900
        bitset<5001> dp, next;
        dp.reset();
        dp[0] = 1;

        for (auto& row : mat) {
            next.reset();
            for (int num : row) {
                next |= (dp << num);
            }
            dp = next;
        }

        int ans = INT_MAX;
        for (int s = 0; s <= MAX_SUM; ++s) {
            if (dp[s]) {
                ans = min(ans, abs(s - target));
            }
        }
        return ans;
    }
};
```

{: file=''}
</div>
</details>

---
## LeetCode(Hard)

> ### [LeetCode 879: Profitable Schemes](https://leetcode.com/problems/profitable-schemes/description/)

n명 썼을 때 얻을 수 있는 이익을 dp의 인덱스로 둠
최대 minProfit으로만 가질 수 있도록 하고 max를 정해주면 됨

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        const int MOD = 1e9 + 7;
        vector<vector<int>> dp(n+1, vector<int>(minProfit+1, 0));

        dp[0][0] = 1;

        for (int i = 0; i < group.size(); i++) {
            int g = group[i];
            int p = profit[i];

            for (int j = n; j >= g; j--) {
                for (int k = minProfit; k >= 0; k--) {
		                // 최대 프로핏을 정해줌
                    int newProfit = min(minProfit, k + p);
                    dp[j][newProfit] = (dp[j][newProfit] + dp[j - g][k]) % MOD;
                }
            }
        }

        int res = 0;
        for (int j = 0; j <= n; j++) {
            res = (res + dp[j][minProfit]) % MOD;
        }
        return res;
    }
};

```

{: file=''}
</div>
</details>



> ### [LeetCode 956: Tallest Billboard](https://leetcode.com/problems/tallest-billboard/description/)

아니 진짜 세상 어려움 ㅋㅋㅋ
[차이] = 더 낮은 쪽 중 가장 큰 값.
vector가 쓰기에 까다로울 땐 um을 쓸 수도 있을듯
확실히 필요한 요소들을 나열하고, 굳이 저장할 필요가 없는 것(다른걸로 유추할 수 있는 (이번에는 값+인덱스 => 큰 값을 유추할 수 있음)경우에는 제거(압축))

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int tallestBillboard(vector<int>& rods) {
        // 최대 => sum/2;
        // 두 서브셋의 합이 같은 가장 큰 수
        // 1집단에 넣을수도, 2집단에 넣을수도 있음
        // [차이] = 낮은 쪽 높이의 최대값
        // [현재idx], 현재 val,
        // 현재 차이에서 큰 쪽에 넣기 -> [현재idx+현재val]에다가

        unordered_map<int, int> dp;
        dp[0] = 0;
        for (int rod : rods) {
            // 이번 rod를 쓰기 전의 상태를 복사
            auto cur = dp;

            for (auto [diff, low] : cur) {
                // 높은 쪽 더하기
                dp[diff + rod] = max(dp[diff + rod], low);

                // 낮은 쪽 더하기
                if (diff >= rod) {
                    dp[diff - rod] = max(dp[diff - rod], low + rod);
                } else {
                    dp[rod - diff] = max(dp[rod - diff], low + diff);
                }
            }
        }

        return dp[0];
    }
};
```


{: file=''}
</div>
</details>

> ### [LeetCode 518: Coin Change 2](https://leetcode.com/problems/coin-change-ii/description/)

경우의 수 세기
다른 하드에 비하면 쉬웠음
근데 자꾸 오버플로우가 남
근데 답은 32비트 sign integer를 보장한다고 함(???)
long long 환경에서도 오버플로우가 남 (???)
생각해보니 답은 오버플로우가 안날 수 있지만 중간과정은 오버플로우가 안난다고 보장한건 아니었음 ㅋㅋㅋㅋ
그래서 중간에 모듈러 연산 추가 필요

> ### [LeetCode 1235: Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/description/)

endTime을 기준으로 모든 파라미터를 정렬하고, [0~i]까지의 최대 합을 dp로 생성
일일이 순회하는게 아니라, upper_bound로 특정한 지점만 찾는것이 핵심
추가할 경우와 추가하지 않을 경우를 고려해야 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    class Work {
    public:
        int start;
        int end;
        int profit;
        // Data(int s, int e, int p):start(s), end(e), profit(p){}
    };

    struct cmp {
        bool operator()(const Work& w1, const Work& w2) {
            return w1.end < w2.end;
        }
    };

    int jobScheduling(vector<int>& startTime, vector<int>& endTime,
                      vector<int>& profit) {
        int N = startTime.size();

        // [0 ~ i]까지의 최대 이익
        vector<int> dp(N + 1, 0);
        vector<Work> works(N + 1);
        vector<int> ends(N + 1);
        for (int i = 1; i <= N; i++) {
            works[i].start = startTime[i - 1];
            works[i].end = endTime[i - 1];
            works[i].profit = profit[i - 1];
            ends[i] = endTime[i - 1];
        }

        sort(works.begin(), works.end(), cmp());
        sort(ends.begin(), ends.end());
        // for(int i : ends){
        //     cout << i << ' ' ;
        // }

        for (int i = 1; i <= N; i++) {
            int idx = upper_bound(ends.begin(), ends.begin() + i, works[i].start) - ends.begin() - 1;
            dp[i] = max(dp[i - 1], dp[idx] + works[i].profit);
            
            // cout << idx << ' ';
            // for (int i : dp) {
            //     cout << i << ' ';
            // }
            // cout << '\n';

            // for (int j = 0; j <= i; j++) {
            //     // 스타트 시간이 j의 끝나는 시간과 같거나 이후여야 함
            //     if (works[j].end <= works[i].start)
            //         dp[i] = max(dp[i], before[j] + works[i].profit);
            //         else
            //         dp[i] = max(dp[i], before[j]);
            // }
        }

        return dp[N];
    }
};
```
{: file=''}
</div>
</details>


> ### [LeetCode 1458: Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/)

거의 못풀었다고 보면 됨
[i][j]는 [0~i][0~j]까지의 최대 dot
사용할 경우와 사용하지 않을 경우를 구분해야 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        int N = nums1.size(), M = nums2.size();
        vector<vector<int>> dp(N, vector<int>(M));

        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                int a = nums1[i], b = nums2[j];
                dp[i][j] = a*b;
                // a, b의 dot
                if (i > 0 && j > 0)
                    dp[i][j] = max(dp[i][j], max(0, dp[i - 1][j - 1]) + a * b);

                // i 만 빠질경우
                if (i > 0)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j]);

                if (j > 0)
                    dp[i][j] = max(dp[i][j], dp[i][j - 1]);
            }
        }

        return dp[N - 1][M - 1];
    }
};
```

{: file=''}
</div>
</details>
