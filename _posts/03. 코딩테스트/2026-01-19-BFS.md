---
title: "[코딩테스트] BFS"
date: 2026-01-19 19:14:34 +09:00
categories: [코딩테스트]
published: true
tags:
    [코딩테스트, BFS]
---

## 개요

**현재 단계를 모두 탐색한 후 다음 단계의 노드들을 탐색하는 완전 탐색 방식
상태나 조건에 따라 탐색할 노드일지 결정지음**

유형: 1차원, 2차원 4방향, 2차원 8방향, 2차원 특수(나이트 움직임같은) 방향, k개의 벽을 부술 수 있는 경우, 벽을 최대한 덜 부수고 도달하는 경우(pq필요), 열쇠, 3차원, queue를 구분해야 하는 경우, 그래프, 한글자 차이 (hash), 현재 맵을 상태로 구분하는 경우 (cache)

queue, visited 필수

---
## 백준

> ### [백준 2178: 미로 탐색(실1)](https://www.acmicpc.net/problem/2178)

- 출발점이라 그런지 실수가 좀 있음. size를 사용 안했다거나, 도착지점에서 break를 했었음

- 기본형 코드

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
void Solution() {
	int ret = 0;

	queue<pair<int, int>> q;
	q.push({ 0, 0 });
	maps[0][0] = 0;
	while (!q.empty()) {
		ret++;
		int size = q.size();
		while (size--) {
			auto pos = q.front();
			q.pop();

			if (pos.first == N - 1 && pos.second == M - 1) {
				cout << ret << '\n';
				return;
			}

			for (int i = 0; i < 4; i++) {
				int nr = pos.first + dr[i];
				int nc = pos.second + dc[i];

				if (IsValid(nr, nc)) {
					maps[nr][nc] = 0;
					q.push({ nr, nc });
				}
			}
		}
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>

> ### [백준 1697: 숨바꼭질(실1)](https://www.acmicpc.net/problem/1697)
> ### [백준 1926: 그림(실1)](https://www.acmicpc.net/problem/1926)
> ### [백준 2667: 단지번호붙이기(실1)](https://www.acmicpc.net/problem/2667)
> ### [백준 1012: 유기농 배추(실2)](https://www.acmicpc.net/problem/1012)
> ### [백준 7576: 토마토(골5)](https://www.acmicpc.net/problem/7576)
> ### [백준 11724: 연결 요소의 개수(실2)](https://www.acmicpc.net/problem/11724)

기본

> ### [백준 7562: 나이트의 이동(실1)](https://www.acmicpc.net/problem/7562)

나이트 움직임 dr, dc 구현

> ### [백준 7569: 토마토(골5)](https://www.acmicpc.net/problem/7569)

3차원 BFS
dr, dc, dh까지 필요했음

> ### [백준 4179: 불!(골3)](https://www.acmicpc.net/problem/4179)

좀 신박했음
캐릭터가 움직이고 탈출여부와 탈출 시간, 장애물이 퍼짐
queue가 2종류로 하나의 while문 안에 2 종류의 while문이 돌았어야 함
캐릭터가 있던 자리 처리와 바깥 while문 조건 처리에서 문제가 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int Escape() {
	queue<pair<int, int>> jq;
	queue<pair<int, int>> fq;
	vector<vector<int>> visited(N, vector<int>(M));
	FOR(r, N)
		FOR(c, M) {
		if (maps[r][c] == 'J') {
			jq.push({ r, c });
			maps[r][c] = '.';
			visited[r][c] = true;
		}
		else if (maps[r][c] == 'F') {
			fq.push({ r, c });
			maps[r][c] = '#';
		}
	}

	int ret = 0;

	while (!jq.empty() || !fq.empty()) {
		int fsize = fq.size();
		while (fsize--) {
			auto pos = fq.front();
			fq.pop();

			for (int i = 0; i < 4; i++) {
				int nr = pos.first + dr[i];
				int nc = pos.second + dc[i];

				if (IsValid(nr, nc)) {
					maps[nr][nc] = 'F';
					fq.push({ nr, nc });
				}
			}
		}

		int jsize = jq.size();
		ret++;
		while (jsize--) {
			auto pos = jq.front();
			jq.pop();

			//cout << pos.first << ' ' << pos.second << '\n';

			for (int i = 0; i < 4; i++) {
				int nr = pos.first + dr[i];
				int nc = pos.second + dc[i];
				if (CanEscape(nr, nc)) {
					return ret;
				}
				else if (IsValid(nr, nc) && !visited[nr][nc]) {
					visited[nr][nc] = true;
					jq.push({ nr, nc });
				}
			}
		}

	}

	return -1;
}
```

{: file=''}
</div>
</details>

> ### [백준 13549: 숨바꼭질 3(골5)](https://www.acmicpc.net/problem/13549)

0초만에 움직이는 조건이 존재
t가 들어가는 인자를 갖는 pq 사용
시간을 인자로 갖는 visited 사용

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
bool IsValid(int n, int t) {
	if (n < 0 || n > 100000) return false;

	return visited[n] > t;
}
struct cmp {
	bool operator()(const Data& d1, const Data& d2) {
		return d1.t > d2.t;
	}
};

void Solution() {
	priority_queue<Data, vector<Data>, cmp> pq;
	pq.push({ N, 0 });
	visited.resize(1000001, INF);
	visited[N] = 0;
	//Teleport(pq, N, 0);

	while (!pq.empty()) {
		Data cur = pq.top();
		pq.pop();

		//cout << cur.n << ' ' << cur.t << '\n';

		if (cur.n == K) {
			cout << cur.t << '\n';
			return;
		}

		Data cand[3] = { {cur.n - 1, cur.t + 1}, {cur.n + 1, cur.t + 1}, {cur.n * 2 , cur.t} };
		for (int i = 0; i < 3; i++) {
			Data next = cand[i];
			if (IsValid(next.n, next.t)) {
				visited[next.n] = next.t;
				pq.push(next);
			}
		}
	}
}
```

{: file=''}
</div>
</details>

> ### [백준 1261: 알고스팟(골4)](https://www.acmicpc.net/problem/1261)

예전에 못맞추고 넘어갔던 문제
이번에도 visited 비교형이 필요했음
부순 개수를 요소로 갖는 visited로 더 적은 부순 개수일 경우엔 갈 수있도록 함
부순 개수와 걸음 개수를 요소로 갖는 pq도 사용

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
struct Data {
	int r;
	int c;
	int b;
	int step;
};

struct cmp {
	bool operator()(const Data& d1, const Data& d2) {
		if (d1.b != d2.b) {
			return d1.b > d2.b;
		}
		else {
			return d1.step > d2.step;
		}
	}
};

bool IsValid(int r, int c) {
	if (r < 0 || r >= N || c < 0 || c >= M)return false;
	return true;
}

void Solution() {

	// [r][c] = b
	vector<vector<int>> visited(N, vector<int>(M, INF));
	priority_queue<Data, vector<Data>, cmp> pq;
	pq.push({ 0, 0 });
	visited[0][0] = 0;

	while (!pq.empty()) {
		Data cur = pq.top();
		pq.pop();

		if (cur.r == N - 1 && cur.c == M - 1) {
			cout << cur.b << '\n';
			return;
		}

		for (int i = 0; i < 4; i++) {
			int nr = cur.r + dr[i];
			int nc = cur.c + dc[i];

			// 바운더리 검사
			if (IsValid(nr, nc)) {
				// 벽이라면
				int nb = cur.b;
				if (maps[nr][nc] == 1) {
					nb++;
				}

				if (visited[nr][nc] > nb) {
					visited[nr][nc] = nb;
					pq.push({ nr, nc, nb, cur.step + 1 });
				}
			}
		}
	}
}
```


{: file=''}
</div>
</details>

> ### [백준 1600: 말이 되고픈 원숭이(골3)](https://www.acmicpc.net/problem/1600)

4방향과 나이트방향을 모두 사용해야 함
나이트 방향 횟수에 따른 visited도 사용해야 함

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
struct Pos {
	int r;
	int c;
	int k;
};

inline bool IsValid(int r, int c, int k, const vector<vector<int>>& visited) {
	return !(r < 0 || r >= H || c < 0 || c >= W) && k <= K && visited[r][c] > k && !maps[r][c];
}

void Solution() {

	queue<Pos>q;
	q.push({ 0, 0, 0 });
	vector<vector<int>> visited(H, vector<int>(W, INF));
	visited[0][0] = true;

	int ret = -1;
	while (!q.empty()) {
		ret++;

		int size = q.size();
		while (size--) {
			Pos pos = q.front();
			q.pop();

			if (pos.r == H - 1 && pos.c == W - 1) {
				cout << ret << '\n';
				return;
			}

			for (int i = 0; i < 4; i++) {
				int nr = pos.r + dr[i];
				int nc = pos.c + dc[i];
				if (IsValid(nr, nc, pos.k, visited)) {
					visited[nr][nc] = pos.k;
					q.push({ nr, nc, pos.k });
				}
			}

			for (int i = 0; i < 8; i++) {
				int nr = pos.r + kr[i];
				int nc = pos.c + kc[i];
				if (IsValid(nr, nc, pos.k + 1, visited)) {
					visited[nr][nc] = pos.k + 1;
					q.push({ nr, nc, pos.k + 1 });
				}
			}
		}
	}

	cout << -1 << '\n';
}
```

{: file=''}
</div>
</details>

> ### [백준 2206: 벽 부수고 이동하기(골3)](https://www.acmicpc.net/problem/2206)

또 벽 부순 개수 visited 처리

> ### [백준 1389: 케빈 베이컨의 6단계 법칙(실1)](https://www.acmicpc.net/problem/1389)

플루이드 워셜
DFS와 달리 이번엔 플워인걸 눈치챌 수 있었음
덕분에 구현 완료

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
struct Data {
	int node;
	int dist;
};

int KB(int n) {
	vector<int> distance(N + 1, INF);
	distance[n] = 0;

	queue<Data> q;
	q.push({ n, 0 });

	while (!q.empty()) {
		Data cur = q.front();
		q.pop();

		for (int i = 0; i < edges[cur.node].size(); i++) {
			int next = edges[cur.node][i];
			if (distance[next] > cur.dist + 1) {
				distance[next] = cur.dist + 1;
				q.push({ next, cur.dist + 1 });
			}
		}
	}

	int ret = 0;
	for (int i = 1; i <= N; i++) {
		ret += distance[i];
	}

	return ret;
}

void Solution() {

	int minValue = INF;
	int res = 0;
	for (int i = 1; i <= N; i++) {
		int ret = KB(i);
		if (ret < minValue) {
			minValue = ret;
			res = i;
		}
	}
	cout << res << '\n';
}
```

{: file=''}
</div>
</details>

> ### [백준 16236: 아기 상어(골3)](https://www.acmicpc.net/problem/16236)

물고기의 위치를 관계도로 해석하려다가 엄청나게 꼬여서 오래걸림
초기화하고 처음부터 그냥 판 자체를 보도록 하니까 금방 함
상어 초기 위치를 맵에서 0으로 바꿔주는거 안해서 지체됨

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
bool CanEat(Pos pos) {
	return maps[pos.r][pos.c] != 0 && maps[pos.r][pos.c] < babySize;
}

void Eat(Pos pos) {
	maps[pos.r][pos.c] = 0;
	baby = pos;
	baby.t = 0;
	babyExp++;
	if (babyExp == babySize) {
		babySize++;
		babyExp = 0;
	}
}

bool CanMove(int r, int c, const vector<vector<int>>& visited) {
	return !(r < 0 || r >= N || c < 0 || c >= N) && !visited[r][c] && maps[r][c] <= babySize;
}

struct cmp {
	bool operator()(const Pos& p1, const Pos& p2) {
		if (p1.t != p2.t) {
			return p1.t > p2.t;
		}
		else if (p1.r != p2.r) {
			return p1.r > p2.r;
		}
		else {
			return p1.c > p2.c;
		}
	}
};


int BFS() {
	priority_queue<Pos, vector<Pos>, cmp> pq;
	pq.push(baby);
	vector<vector<int>> visited(N, vector<int>(N));
	visited[baby.r][baby.c] = true;

	int time = 0;
	while (!pq.empty()) {
		Pos pos = pq.top();
		pq.pop();

		if (CanEat(pos)) {
			Eat(pos);
			//cout << pos.r << ' ' << pos.c << ' ' << pos.t << '\n';
			return pos.t;
		}

		for (int i = 0; i < 4; i++) {
			int nr = pos.r + dr[i];
			int nc = pos.c + dc[i];
			if (CanMove(nr, nc, visited)) {
				visited[nr][nc] = true;
				pq.push({ nr, nc, pos.t + 1 });
			}
		}
	}

	return 0;
}

void Solution() {
	int ret = 0, time = 0;
	while (ret = BFS()) {
		time += ret;
	}

	cout << time << '\n';

}
```

{: file=''}
</div>
</details>

> ### [백준 3197: 백조의 호수(플5)](https://www.acmicpc.net/problem/3197)

처음에는 백조가 만날 수 있는지 확인(BFS) → 빙하 녹이기 (BFS)를 만날 수 있을 때까지 반복했음 → TLE
두 번째로 생각한 것은 맵을 녹는 시간으로 변경 → 백조가 만나기까지 걸리는 최소 녹는 시간 찾기로 변경 → TLE
두 번째에서 q를 pq로 변경 → 성공(300ms)
다른사람의 정답을 확인해보니 백조가 갈 수 있는 BFS를 위한 Queue와 녹이는 BFS를 위한 Queue를 분리해서 레벨별로 진행 → 성공(100ms)

<details>
<summary>TLE 난 내 코드</summary>
<div markdown="1">

```cpp
// TLE 난 내 코드
int R, C;
vector<vector<char>> maps;
vector<pair<int, int>> swans;

bool Inputs() {

	cin >> R >> C;
	maps.resize(R, vector<char>(C));
	FOR(r, R)
		FOR(c, C) {
		cin >> maps[r][c];
		if (maps[r][c] == 'L') {
			swans.push_back({ r, c });
		}
	}
	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= R || c < 0 || c >= C);
}

inline bool IsValid(int r, int c, const vector<vector<int>>& visited) {
	if (!Boundary(r, c))return false;
	return !visited[r][c] && maps[r][c] != 'X';
}

bool CanMeet() {
	vector<vector<int>> visited(R, vector<int>(C));
	queue<pair<int, int>> q;
	q.push(swans[0]);
	visited[swans[0].first][swans[0].second] = true;

	while (!q.empty()) {
		auto pos = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = pos.first + dr[i];
			int nc = pos.second + dc[i];
			if (IsValid(nr, nc, visited)) {
				visited[nr][nc] = true;
				q.push({ nr, nc });
			}
		}
	}

	return visited[swans[1].first][swans[1].second];
}

void Melt(int r, int c, vector<vector<int>>& visited) {
	visited[r][c] = true;
	queue<pair<int, int>> q;
	q.push({ r , c });

	while (!q.empty()) {
		auto pos = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = pos.first + dr[i];
			int nc = pos.second + dc[i];
			if (Boundary(nr, nc) && !visited[nr][nc]) {
				visited[nr][nc] = true;
				if (maps[nr][nc] == 'X') {
					maps[nr][nc] = '.';
				}
				else {
					q.push({ nr, nc });
				}
			}
		}
	}
}

void Melting() {
	// 물이 있는 주변 다 녹임
	vector<vector<int>> visited(R, vector<int>(C));
	FOR(r, R) {
		FOR(c, C) {
			if (IsValid(r, c, visited)) {
				Melt(r, c, visited);
			}
		}
	}
}
```

{: file=''}
</div>
</details>

<details>
<summary>성공한 내 코드</summary>
<div markdown="1">

```cpp
// 성공한 내 코드
int R, C;
vector<vector<char>> inputs;
vector<vector<int>> maps;
vector<pair<int, int>> swans;

bool Inputs() {

	cin >> R >> C;
	inputs.resize(R, vector<char>(C));
	maps.resize(R, vector<int>(C));
	FOR(r, R)
		FOR(c, C) {
		cin >> inputs[r][c];
		if (inputs[r][c] == 'L') {
			swans.push_back({ r, c });
		}
	}

	return true;
}

inline bool BoundaryCheck(int r, int c) {
	return !(r < 0 || r >= R || c < 0 || c >= C);
}

inline bool IsValid(int r, int c, vector<vector<int>>& visited) {
	if (!BoundaryCheck(r, c)) return false;
	return !visited[r][c];
}

void Init() {
	vector<vector<int>> visited(R, vector<int>(C));
	queue<pair<int, int>> q;
	FOR(r, R)
		FOR(c, C) {
		if (inputs[r][c] == '.' || inputs[r][c] == 'L') {
			q.push({ r, c });
			visited[r][c] = true;
			maps[r][c] = 0;
		}
	}

	int day = 1;
	while (!q.empty()) {
		int size = q.size();
		while (size--) {
			auto pos = q.front();
			q.pop();

			for (int i = 0; i < 4; i++) {
				int nr = pos.first + dr[i];
				int nc = pos.second + dc[i];
				if (IsValid(nr, nc, visited)) {
					visited[nr][nc] = true;
					q.push({ nr, nc });
					maps[nr][nc] = day;
				}
			}
		}
		day++;
	}
}

struct Pos {
	int r, c, w;
};

struct cmp {
	bool operator()(const Pos& p1, const Pos& p2) {
		return p1.w > p2.w;
	}
};

int FindSwans() {
	// swans[0]이 swans[1]에 도달하기 까지 가장 작은 빙하 가중치를 거치는지 확인
	priority_queue<Pos, vector<Pos>, cmp> pq;
	vector<vector<int>> weights(R, vector<int>(C, INF));
	pq.push({ swans[0].first, swans[0].second , 0 });
	weights[swans[0].first][swans[0].second] = 0;

	while (!pq.empty()) {
		auto pos = pq.top();
		pq.pop();

		for (int i = 0; i < 4; i++) {
			int nr = pos.r + dr[i];
			int nc = pos.c + dc[i];

			if (BoundaryCheck(nr, nc)) {
				if (weights[nr][nc] > max(maps[nr][nc], pos.w)) {
					weights[nr][nc] = max(maps[nr][nc], pos.w);
					pq.push({ nr, nc, max(maps[nr][nc], pos.w) });
				}
			}
		}
	}

	//PrintVec(weights);

	return weights[swans[1].first][swans[1].second];
}

void Solution() {
	// 맵을 처음부터 몇일 날 녹는 빙하인지 체크

	Init();
	cout << FindSwans() << '\n';
	//PrintVec(maps);
}
```

{: file=''}
</div>
</details>

> ### [백준 4991: 로봇 청소기(골1)](https://www.acmicpc.net/problem/4991)

처음엔 greedy하게 순서를 잡았지만 틀림
두 번째로 순서를 DFS로 골라서 하기 위해 각 정점to정점의 거리를 BFS로 구하고, DFS로 찾음 800ms
두 번째에서 캐시를 사용하여 8ms로 줄임

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, M, D;
vector<vector<char>> maps;
vector<vector<int>> dist;
vector<pair<int, int>> poses;
map<pair<int, int>, int> idxs;
int roboIdx = -1;
int minValue = INF;

// [방문한 노드 bitmask][현재 노드]
int cache[2049][12];

bool Inputs() {
	cin >> M >> N;
	if (M == 0 || N == 0)return false;
	maps.assign(N, vector<char>(M));
	poses.clear();
	dist.clear();
	idxs.clear();
	memset(cache, -1, sizeof(cache));
	minValue = INF;

	FOR(r, N)
		FOR(c, M) {
		cin >> maps[r][c];
		if (maps[r][c] == 'o' || maps[r][c] == '*') {
			if (maps[r][c] == 'o') {
				roboIdx = poses.size();
			}
			idxs[{r, c}] = poses.size();
			poses.push_back({ r, c });
		}
	}
	D = poses.size();
	dist.resize(D, vector<int>(D, INF));

	return true;
}

inline bool IsValid(int r, int c, const vector<vector<int>>& visited) {
	return !(r < 0 || r >= N || c < 0 || c >= M) && !visited[r][c] && maps[r][c] != 'x';
}

void BFS(int n) {
	dist[n][n] = 0;
	queue<pair<int, int>> q;
	q.push(poses[n]);
	vector<vector<int>> visited(N, vector<int>(M));
	visited[poses[n].first][poses[n].second] = true;

	int step = 0;
	while (!q.empty()) {
		int size = q.size();
		while (size--) {
			auto node = q.front();
			q.pop();

			for (int i = 0; i < 4; i++) {
				int nr = node.first + dr[i];
				int nc = node.second + dc[i];

				if (IsValid(nr, nc, visited)) {
					visited[nr][nc] = true;
					q.push({ nr, nc });
					if (maps[nr][nc] == '*' || maps[nr][nc] == 'o') {
						dist[n][idxs[{nr, nc}]] = step + 1;
					}
				}
			}
		}
		step++;
	}
}

int DFS(int path, int idx) {
	int& ret = cache[path][idx];
	if (ret != -1) return ret;
	if (path == pow(2, D) - 1) {
		return ret = 0;
	}
	ret = INF;

	for (int i = 0; i < D; i++) {
		if ((path & (1 << i)) == 0) {
			ret = min(ret, DFS(path | (1 << i), i) + dist[idx][i]);
		}
	}

	return ret;
}

void Solution() {
	// 그리디 아님. 
	// 로청 위치를 포함한 더러운 부분들을 가야하는 정점이라고 생각함
	// 모든 정점에서 모든 정점을 가는 최소치를 찾음
	// 로청 row에서 못가는 영역 있으면 -1
	// 그 다음 순회해서 제일 작은 값

	// 로청과 다른 더러운 곳 정점간의 거리 찾기
	BFS(roboIdx);

	// 하나라도 못가면 -1
	for (int i = 0; i < D; i++) {
		if (dist[roboIdx][i] == INF) {
			cout << -1 << '\n';
			return;
		}
	}

	// 모든 정점에서 모든 정점으로 가는 거리 찾기
	for (int i = 0; i < D; i++) {
		if (i == roboIdx)continue;
		BFS(i);
	}

	cout << DFS(1 << roboIdx, roboIdx) << '\n';

}
```

{: file=''}
</div>
</details>

> ### [백준 9328: 열쇠(골1)](https://www.acmicpc.net/problem/9328)

백조의 호수에서 아이디어를 얻음
열쇠별 queue를 두고 해결

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
int N, M;
vector<vector<char>> maps;
vector<vector<int>> visited;
int keys[26];
vector<queue<pair<int, int>>> vecQ;
bool Inputs() {
	cin >> N >> M;
	maps.assign(N, vector<char>(M));
	visited.assign(N, vector<int>(M));
	vecQ.assign(26, queue<pair<int, int>>());
	memset(keys, 0, sizeof(keys));
	FOR(r, N)
		FOR(c, M)
		cin >> maps[r][c];

	string str;
	cin >> str;
	if (str != "0") {
		for (int i = 0; i < str.size(); i++) {
			keys[str[i] - 'a'] = 1;
		}
	}


	return true;
}

inline bool IsValid(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= M) && !visited[r][c] && maps[r][c] != '*';
}

inline bool IsKey(int r, int c) {
	return 'a' <= maps[r][c] && maps[r][c] <= 'z';
}

inline bool IsDoor(int r, int c) {
	return 'A' <= maps[r][c] && maps[r][c] <= 'Z';
}

inline bool IsPaper(int r, int c) {
	return maps[r][c] == '$';
}

bool DKP(int r, int c, queue<pair<int, int>>& q) {
	bool ret = false;
	if (IsDoor(r, c)) {
		vecQ[maps[r][c] - 'A'].push({ r, c });
		visited[r][c] = true;
		return false;
	}
	else if (IsKey(r, c)) {
		keys[maps[r][c] - 'a'] = 1;
	}
	else if (IsPaper(r, c)) {
		ret = true;
	}
	q.push({ r, c });
	visited[r][c] = true;
	return ret;
}

int BFS(int r, int c) {
	// 문을 만나면 vecQ에 추가
	// 문서를 만나면 ret++
	// 열쇠를 만나면 keys에 체크

	int ret = 0;
	queue<pair<int, int>> q;
	ret += DKP(r, c, q);

	while (!q.empty()) {
		auto pos = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = pos.first + dr[i];
			int nc = pos.second + dc[i];

			if (IsValid(nr, nc)) {
				ret += DKP(nr, nc, q);
			}
		}
	}

	return ret;
}

int Init() {
	int ret = 0;
	FOR(r, N) {
		if (IsValid(r, 0)) {
			ret += BFS(r, 0);
		}
		if (IsValid(r, M - 1)) {
			ret += BFS(r, M - 1);
		}
	}

	FOR(c, M) {
		if (IsValid(0, c)) {
			ret += BFS(0, c);
		}

		if (IsValid(N - 1, c)) {
			ret += BFS(N - 1, c);
		}
	}

	return ret;
}

int BFS(queue<pair<int, int>>& q) {
	int ret = 0;

	while (!q.empty()) {
		auto pos = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = pos.first + dr[i];
			int nc = pos.second + dc[i];

			if (IsValid(nr, nc)) {
				ret += DKP(nr, nc, q);
			}
		}
	}

	return ret;
}

void Solution() {
	int ret = 0;
	ret += Init();

	int tmp = -1;
	while (tmp != 0) {
		tmp = 0;
		for (int i = 0; i < vecQ.size(); i++) {
			if (keys[i] && !vecQ[i].empty()) {
				ret += BFS(vecQ[i]);
				tmp++;
			}
		}
	}

	cout << ret << '\n';
}
```

{: file=''}
</div>
</details>

---
## LeetCode(Easy)

> ### [LeetCode 733: Flood Fill](https://leetcode.com/problems/flood-fill/)

기본

---
## LeetCode(Med)

> ### [LeetCode 200: Number of Islands](https://leetcode.com/problems/number-of-islands/)
> ### [LeetCode 542: 01 Matrix](https://leetcode.com/problems/01-matrix/)
> ### [LeetCode 130: Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)
> ### [LeetCode 841: Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/)

기본


> ### [LeetCode 102: Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

그래프형 BFS

> ### [LeetCode 994: Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

토마토와 같은 문제
오렌지가 하나도 없는 경우에 대한 예외가 필요했음

> ### [LeetCode 909: Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/)

헷갈리는 요소가 좀 있었던듯
num을 지정하는 방법, numToPos map이 필요했음

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
class Solution {
public:
    int N;
    unordered_map<int, pair<int, int>> numToPos;
    vector<vector<int>> m_board;

    void Init(vector<vector<int>>& board) {
        m_board = board;
        N = board.size();

        int cnt = 1;
        int flip = 1;
        for (int i = N - 1; i >= 0; i--) {
            if (flip % 2 == 0) {
                for (int j = N - 1; j >= 0; j--) {
                    numToPos[cnt++] = {i, j};
                }
            } else {
                for (int j = 0; j < N; j++) {
                    numToPos[cnt++] = {i, j};
                }
            }
            flip++;
        }

        // for (int i = 1; i <= N * N; i++) {
        //     cout << numToPos[i].first << ' ' << numToPos[i].second << '\n';
        // }
    }
    int snakesAndLadders(vector<vector<int>>& board) {
        Init(board);

        queue<int> q;
        q.push(1);
        vector<int> visited(N * N + 1);
        visited[1] = true;
        int dice = -1;
        while (!q.empty()) {
            dice++;
            int size = q.size();
            while (size--) {
                int cur = q.front();
                q.pop();

                if(cur == N*N) return dice;

                for(int i = 1; i <= 6; i++){
                    int next = min(cur + i, N*N);
                    if(!visited[next]){
                        visited[next] = true;
                        auto pos = numToPos[next];
                        if(board[pos.first][pos.second] != -1){
                            next = board[pos.first][pos.second];
                        }
                        q.push(next);
                    }
                }
            }
        }
        return -1;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 752: Open the Lock](https://leetcode.com/problems/open-the-lock/)

4자리 string 비밀번호를 타겟에 가장 빠르게 돌리는 문제
하면 안되는 4자리 번호가 존재함
예외에 “0000”이 들어올 때를 생각을 못했었음

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
class Solution {
public:
    unordered_map<string, int> um;
    int openLock(vector<string>& deadends, string target) {
        for (string& str : deadends) {
            um[str]++;
        }

        if(um.count("0000"))return -1;

        queue<string> q;
        q.push("0000");
        vector<int> visited(10001);
        visited[0] = true;

        int turn = -1;
        while (!q.empty()) {
            turn++;
            int size = q.size();
            while (size--) {
                string cur = q.front();
                q.pop();

                // cout << cur << ' ' << turn << '\n';

                if (cur == target)
                    return turn;

                for (int i = 0; i < 4; i++) {
                    string next = cur;
                    next[i] = (cur[i] - '0' + 10 + 1) % 10 + '0';
                    int inext;
                    inext = stoi(next);
                    if (!visited[inext] && !um.count(next)) {
                        visited[inext] = true;
                        q.push(next);
                    }
                    next[i] = (cur[i] - '0' + 10 - 1) % 10 + '0';
                    inext = stoi(next);
                    if (!visited[inext] && !um.count(next)) {
                        visited[inext] = true;
                        q.push(next);
                    }
                }
            }
        }

        return -1;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 107: Binary Tree Level Order Traversal 2](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)

리트코드 102번이랑 크게 다르지 않음

> ### [LeetCode 199: Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)

오른쪽부터 넣고, 깊이에 따라 처음 나오는 것만 push_back

<details>
<summary>소스 코드</summary>
<div markdown="1">


```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);

        vector<int> ret;
        while(!q.empty()){
            int size = q.size();

            bool input = false;
            while(size--){
                auto cur = q.front();
                q.pop();

                if(cur == nullptr) continue;
                if(!input)
                ret.push_back(cur->val);
                input = true;
                q.push(cur->right);
                q.push(cur->left);
            }
        }

        return ret;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 958: Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)

nullptr이 나온 뒤에 숫자가 나오면 false

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);

        bool nullcheck = false;

        while(!q.empty()){
            auto cur = q.front();
            q.pop();

            if(cur == nullptr){
                nullcheck = true;
                continue;
            }

            if(nullcheck) return false;

            q.push(cur->left);
            q.push(cur->right);
            
        }

        return true;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 417: Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)

더 큰 구역으로 이동하는 BFS
두 번 이동할 수 있는 영역들을 리턴

> ### [LeetCode 433: Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/)

리트코드 752 번형 버전. 이번엔 통과!

---
## LeetCode(Hard)

> ### [LeetCode 127: Word Ladder](https://leetcode.com/problems/word-ladder/)

나는 visited로 돌면서 현재 단어와 모든 단어를 1차이 나는지 구분했지만, 더 빠르기 위해서는 그냥 현재 단어에서 하나만 다른 단어를 존재하는지 찾는게 훨씬 빨랐음

<details>
<summary>내코드</summary>
<div markdown="1">

```cpp
// 내코드
class Solution {
public:
    inline bool AdjWord(const string& str1, const string& str2) {
        int cnt = 0;
        for (int i = 0; i < str1.size(); i++) {
            cnt += (str1[i] != str2[i]);
            if (cnt > 1)
                return false;
        }
        return true;
    }

    int ladderLength(string beginWord, string endWord,
                     vector<string>& wordList) {
        queue<string> q;
        q.push(beginWord);
        vector<int> visited(wordList.size());

        int ret = 0;

        while (!q.empty()) {
            int size = q.size();
            ret++;
            while (size--) {
                string word = q.front();
                q.pop();

                if (word == endWord) {
                    return ret;
                }

                for (int i = 0; i < visited.size(); i++) {
                    if (visited[i])
                        continue;
                    if (AdjWord(word, wordList[i])) {
                        visited[i] = true;
                        q.push(wordList[i]);
                    } 
                }
            }
        }

        return 0;
    }
};
```

{: file=''}
</div>
</details>

<details>
<summary>훨씬 빠른 다른사람 코드</summary>
<div markdown="1">

```cpp
// 훨씬 빠른 다른사람 코드
class Solution {
public:
    int ladderLength(string beginWord, string endWord,
                     vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(), wordList.end());
        queue<pair<string,int>> q;
        q.push({beginWord,1});
        while(!q.empty()){
            auto [word , count ] = q.front();
            q.pop();
            if(word == endWord) return count;
            for(int i = 0; i < word.size(); ++i){
                char original = word[i];
                for(char j  = 'a'; j <= 'z'; ++j){
                    word[i] = j;
                    if(dict.count(word)){
                        dict.erase(word);
                        q.push({word, count + 1});
                    }
                }
                word[i] = original;
            }
        }
        return 0;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 773: Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/)

현재 맵을 int로 변환하는 인코딩 디코딩 기법이 필요했음
타겟이 하나라서 그것에 맞춤

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    inline int Encode(const vector<vector<int>>& board) {
        int ret = 0;
        ret += board[0][0];
        ret += board[0][1] * 6;
        ret += board[0][2] * 6 * 6;
        ret += board[1][0] * pow(6, 3);
        ret += board[1][1] * pow(6, 4);
        ret += board[1][2] * pow(6, 5);
        return ret;
    }

    inline vector<vector<int>> Decode(int num) {
        vector<vector<int>> ret(2, vector<int>(3));
        ret[0][0] = num % 6;
        num /= 6; // a0
        ret[0][1] = num % 6;
        num /= 6; // a1
        ret[0][2] = num % 6;
        num /= 6; // a2
        ret[1][0] = num % 6;
        num /= 6; // a3
        ret[1][1] = num % 6;
        num /= 6;            // a4
        ret[1][2] = num % 6; // a5
        return ret;
    }

    inline bool Boundary(int r, int c) {
        return !(r < 0 || r >= 2 || c < 0 || c >= 3);
    }

    int slidingPuzzle(vector<vector<int>>& board) {
        int target = 7465;

        // 6^6 + 1만큼 할당
        vector<int> visited(46657);
        int start = Encode(board);
        visited[start] = true;
        queue<int> q;
        q.push(start);
        // cout << start << '\n';

        int dr[4] = {0, 1, 0, -1};
        int dc[4] = {1, 0, -1, 0};

        int turn = -1;
        while (!q.empty()) {
            turn++;
            int size = q.size();
            while (size--) {
                int cur = q.front();
                q.pop();

                if (cur == target)
                    return turn;

                auto vec = Decode(cur);
                int zr = -1, zc = -1;
                for (int i = 0; i < 2; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (vec[i][j] == 0) {
                            zr = i;
                            zc = j;
                            break;
                        }
                    }
                    if (zr != -1)
                        break;
                }

                for (int i = 0; i < 4; i++) {
                    int nr = zr + dr[i];
                    int nc = zc + dc[i];
                    if (Boundary(nr, nc)) {
                        swap(vec[zr][zc], vec[nr][nc]);
                        int next = Encode(vec);
                        if (!visited[next]) {
                            visited[next] = true;
                            q.push(next);
                        }
                        swap(vec[zr][zc], vec[nr][nc]);
                    }
                }
            }
        }

        return -1;
    }
};
```

{: file=''}
</div>
</details>


> ### [LeetCode 847: Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/)

방문하면서, 현재 노드를 추적하며 경로 개수 구하기
경로 구하기면 못하겠는데 경로 개수라서 가능했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
 class Solution {
public:
    int N;

    struct Data{
        int visited;
        int cur;
    };

    int shortestPathLength(vector<vector<int>>& graph) {
        N = graph.size();

        int target = pow(2, N)-1;
        vector<vector<int>> visited(target+1, vector<int>(N));
        queue<Data> q;
        for(int i = 0 ; i < N; i++){
            q.push({0, i});
        }

        int cnt = -2;
        while(!q.empty()){
            int size = q.size();
            cnt++;
            while(size--){
                auto data = q.front();
                q.pop();

                if(data.visited == target){
                    return cnt;
                }

                for(int i = 0 ; i < graph[data.cur].size(); i++){
                    int next = graph[data.cur][i];
                    int nextVisited = data.visited | (1 << next);
                    if(!visited[nextVisited][next]){
                        visited[nextVisited][next] = true;
                        q.push({nextVisited, next});
                    }
                }
            }
        }
        return 0;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 864: Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/)

백준 9328 열쇠 문제와 거의 같은줄 알았는데 완전히 다른 문제
visited를 어떻게 두느냐가 필요했음
백준 열쇠는 queue를 어떻게 두느냐가 필요했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    // 스타팅 포인트가 주어지고
    // 소문자가 열쇠, 대문자가 잠긴 문
    // 모든 열쇠를 얻기까지 걸리는 최소 움직임 구하기
    // 못구하면 -1 리턴
    int N, M, target;

    struct Data {
        int r;
        int c;
        int k;
    };

    unordered_map<char, int> keyIdx;
    queue<Data> q;
    vector<vector<vector<int>>> visited;

    void Init(vector<string>& grid) {
        // N, M 갱신하기
        N = grid.size(), M = grid[0].size();

        // 열쇠 인덱싱하기
        // 시작 위치 찾기
        Data startPos;
        startPos.k = 0;
        int idx = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == '@') {
                    startPos.r = i;
                    startPos.c = j;
                } else if (islower(grid[i][j])) {
                    keyIdx[grid[i][j]] = idx++;
                } else if (isupper(grid[i][j])) {
                    // cout << grid[i][j] << ' ';
                }
            }
        }

        // 시작위치 Q에 넣기
        q.push(startPos);

        // visited 갱신하기 [key][row][col]
        target = pow(2, idx) - 1;
        // cout << target;
        visited.resize(target + 1, vector<vector<int>>(N, vector<int>(M)));
    }

    inline bool IsKey(int r, int c, vector<string>& grid) {
        return islower(grid[r][c]);
    }

    inline bool IsDoor(int r, int c, vector<string>& grid){
        return isupper(grid[r][c]);
    }

    inline bool CanUnlock(int r, int c, int k, char d){
        int idx = keyIdx[d + 'a' - 'A'];
        return k & (1 << idx);
    }

    inline bool IsValid(int r, int c, vector<string>& grid) {
        return !(r < 0 || r >= N || c < 0 || c >= M) && grid[r][c] != '#';
    }

    int shortestPathAllKeys(vector<string>& grid) {

        Init(grid);

        int dr[4] = {0, 1, 0, -1};
        int dc[4] = {1, 0, -1, 0};

        int cnt = -1;
        while (!q.empty()) {
            cnt++;
            int size = q.size();
            while (size--) {
                auto pos = q.front();
                q.pop();

                if (pos.k == target) {
                    return cnt;
                }

                for (int i = 0; i < 4; i++) {
                    int nr = pos.r + dr[i];
                    int nc = pos.c + dc[i];
                    int nk = pos.k;
                    if (IsValid(nr, nc, grid)) {
                        if (IsKey(nr, nc, grid)) {
                            // cout << keyIdx[grid[nr][nc]] << ' ';
                            nk = nk | (1 << keyIdx[grid[nr][nc]]);
                        }

                        if(IsDoor(nr, nc, grid)){
                            if(!CanUnlock(nr, nc, nk, grid[nr][nc]))
                            continue;
                        }
                        // cout << nr << ' ' << nc << '\n';
                        if (!visited[nk][nr][nc]) {
                            visited[nk][nr][nc] = true;
                            q.push({nr, nc, nk});
                        }
                    }
                }
            }
        }

        return -1;
    }
};
```

{: file=''}
</div>
</details>

> ### [LeetCode 1293: Shortest Path in a Grid With Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

k개의 벽을 부술 수 있는 길찾기라고 생각됐음
백준 1600이랑 나름 비슷한듯?

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int N, M;
    struct Node {
        int r, c, b;
    };

    inline bool Boundary(int r, int c) {
        return !(r < 0 || r >= N || c < 0 || c >= M);
    }

    inline bool IsWall(int r, int c, vector<vector<int>>& grid) {
        return grid[r][c] == 1;
    }

    int shortestPath(vector<vector<int>>& grid, int k) {
        // k개의 벽을 부술 수 있는 문제에 가까운듯
        N = grid.size(), M = grid[0].size();
        // [break][r][c]
        vector<vector<vector<int>>> visited(
            k+1, vector<vector<int>>(N, vector<int>(M)));

        // 0, 0부터 N-1, M-1까지
        queue<Node> q;
        q.push({0, 0, 0});
        visited[0][0][0] = true;

        int dr[4] = {0, 1, 0, -1};
        int dc[4] = {1, 0, -1, 0};

        int cnt = -1;
        while (!q.empty()) {
            int size = q.size();
            cnt++;
            while (size--) {
                auto cur = q.front();
                q.pop();

                if (cur.r == N - 1 && cur.c == M - 1) {
                    return cnt;
                }

                for (int i = 0; i < 4; i++) {
                    int nr = cur.r + dr[i];
                    int nc = cur.c + dc[i];
                    if (Boundary(nr, nc)) {
                        int nb = cur.b + IsWall(nr, nc, grid);
                        if (nb > k)
                            continue;
                        if (!visited[nb][nr][nc]) {
                            visited[nb][nr][nc] = true;
                            q.push({nr, nc, nb});
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```

{: file=''}
</div>
</details>
