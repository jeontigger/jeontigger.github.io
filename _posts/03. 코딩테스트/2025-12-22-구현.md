---
title: "[코딩테스트] 구현"
date: 2025-12-22 20:24:44 +09:00
categories: [코딩테스트]
published: true
tags:
    [코딩테스트, 구현]
---

## 개요

**특별한 알고리즘이 필요하지 않거나 있어도 핵심은 조건처리 + 상태 관리**

시간복잡도: 보통 O(N^2)이나 O(N\*M) 허용

사용되는 스킬(?): (4, 8)방향으로 조건에 따라 움직이기, 이전 상태관리로 순서 종속성 제거(복사본 사용하는 것), 문자열 다루기, 완전탐색

구현 파트는 코드 구현이 중요한 것이기에 거의 모든 문제에 소스코드가 첨부 될 예정

## 백준

> ### [백준 2578: 빙고(실4)](https://www.acmicpc.net/problem/2578)

백준 2239 스도쿠 문제에서 배웠던 방식으로 빙고 검사 시간을 최대한 줄여봤음

아마도 O(N^2) → O(1)인듯

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
bool IsBingo() {
	int cnt = 0;
	FOR(i, 5) {
		cnt += rows[i] == 5;
		cnt += cols[i] == 5;
	}
	cnt += ltrb == 5;
	cnt += rtlb == 5;

	return cnt >= 3;
}

void Check(int r, int c) {
	rows[r]++;
	cols[c]++;
	if (r == c) ltrb++;
	if (r == 4 - c) rtlb++;
}

void Solution() {
	int cnt = 0;
	for (; cnt < 25; cnt++) {
		auto pos = numPos[nums[cnt]];
		//cout << nums[cnt] << ' ';
		Check(pos.first, pos.second);
		if (IsBingo()) break;
	}

	cout << cnt + 1 << '\n';
}
```
{: file='Bingo.cpp'}

</div>
</details>

> ### [백준 14503: 로봇 청소기(골5)](https://www.acmicpc.net/problem/14503)

말그대로 시키는 그대로 했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, M;
int maps[50][50];
pair<int, int> roboPos;
enum EDir { UP, RIGHT, DOWN, LEFT };
EDir dir;

int dr[4] = { -1, 0, 1, 0 };
int dc[4] = { 0, 1, 0, -1 };
int cleanCnt = 0;
// 현재 칸이 청소되었는지
// 청소
// 주변 4칸이 모두 청소되었는지
// 후진
// 후진할 수 없다면 작동 중지
// 청소안된 칸이 있으면 반시계 방향 90도 회전
// 앞쪽 칸이 청소되지 않았으면 빈 칸인경우 전진
// 반복

/// <summary>
/// r과 c가 맵 범위 안에 들어오는지를 검사하는 함수
/// </summary>
inline bool Boundary(int r, int c) {

	return !(r < 0 || r >= N || c < 0 || c >= M);
}

/// <summary>
/// r과 c가 청소 안된 구역인지 검사하는 함수
/// </summary>
inline bool IsDirty(int r, int c) {
	return Boundary(r, c) && maps[r][c] == 0;
}

/// <summary>
/// 주변 4칸에 청소 안된 구역이 존재하는지 검사하는 함수
/// </summary>
bool DirtyAreaExsist(int r, int c) {
	for (int i = 0; i < 4; i++) {
		int nr = r + dr[i];
		int nc = c + dc[i];
		if (IsDirty(nr, nc)) return true;
	}
	return false;
}

/// <summary>
/// dir을 반시계 방향으로 회전하는 함수입니다.
/// </summary>
EDir Rotate(EDir dir, int cnt = 1) {
	return EDir(((int)dir - cnt + 4) % 4);
}

/// <summary>
/// 후진이 가능한지 판단하는 함수입니다.
/// </summary>
inline bool CanReverse(int r, int c, EDir dir) {
	dir = Rotate(dir, 2);
	int nr = r + dr[(int)dir];
	int nc = c + dc[(int)dir];

	return Boundary(nr, nc) && maps[nr][nc] != 1;
}

inline void MoveForward(int r, int c, EDir dir) {
	//cout << __FUNCTION__ << '\n';
	int nr = r + dr[(int)dir];
	int nc = c + dc[(int)dir];
	roboPos.first = nr;
	roboPos.second = nc;
}

inline void MoveBack(int r, int c, EDir dir) {
	//cout << __FUNCTION__ << '\n';
	dir = Rotate(dir, 2);
	int nr = r + dr[(int)dir];
	int nc = c + dc[(int)dir];
	roboPos.first = nr;
	roboPos.second = nc;
}

inline void Clean(int r, int c) {
	maps[r][c] = 2;
	cleanCnt++;
}



bool Inputs() {
	int _dir;
	cin >> N >> M;
	cin >> roboPos.first >> roboPos.second >> _dir;
	dir = (EDir)_dir;
	FOR(r, N)
		FOR(c, M)
		cin >> maps[r][c];

	return true;
}

void Solution() {
	while (true) {
		//cout << roboPos.first << ' ' << roboPos.second << '\n';
		if (IsDirty(roboPos.first, roboPos.second))
			Clean(roboPos.first, roboPos.second);

		if (DirtyAreaExsist(roboPos.first, roboPos.second)) {
			for (int i = 0; i < 4; i++) {
				dir = Rotate(dir);
				int nr = roboPos.first + dr[(int)dir];
				int nc = roboPos.second + dc[(int)dir];
				if (IsDirty(nr, nc)) {
					MoveForward(roboPos.first, roboPos.second, dir);
					break;
				}
			}
		}
		else {
			if (CanReverse(roboPos.first, roboPos.second, dir)) {
				MoveBack(roboPos.first, roboPos.second, dir);
			}
			else {
				break;
			}
		}
	}

	cout << cleanCnt << '\n';
}
```

{: file='Robot Cleaner.cpp'}
</div>
</details>

> ### [백준 14890: 경사로(골3)](https://www.acmicpc.net/problem/14890)

문제가 문제가 좀 있음

가로와 세로의 경사로가 부딪히는 경우가 없다는 조건이 명시가 안돼있음

<details>
<summary>기존 소스코드 (2번체크)-> 내리막과 오르막을 별개로 for문을 돔</summary>
<div markdown="1">

```cpp
int N, L;
int maps[100][100];

enum EDir { UP, RIGHT, DOWN, LEFT };
int dr[4] = { -1, 0, 1, 0 }, dc[4] = { 0, 1, 0, -1 };

bool Inputs() {
	cin >> N >> L;
	FOR(r, N)
		FOR(c, N)
		cin >> maps[r][c];

	return true;
}

// 아예 경사로로 커버가 안되는지
// 경사로가 필요한지
// 경사로를 놓을 수 있는지

bool CanCandidate(int idx, char type) {
	if (type == 'v') {
		for (int i = 0; i < N - 1; i++) {
			if (abs(maps[i][idx] - maps[i + 1][idx]) > 1)return false;
		}
	}
	else if (type == 'h') {
		for (int i = 0; i < N - 1; i++) {
			if (abs(maps[idx][i] - maps[idx][i + 1]) > 1)return false;
		}
	}
	else {
		cout << "Mistake Use\n";
		return false;
	}

	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= N);
}

inline bool NeedRamp(int cr, int cc, int nr, int nc) {
	return maps[cr][cc] - 1 == maps[nr][nc];
}

/// <summary>
/// NeedRamp에서 true를 받은 cr, cc를 인자로 넣어야 합니다.
/// </summary>
bool CanInstall(int r, int c, EDir dir, const vector<int>& visited) {
	int originValue = maps[r][c];
	for (int i = 0; i < L; i++) {
		r += dr[(int)dir];
		c += dc[(int)dir];
		int idx;
		if ((int)dir % 2 == 0)
			idx = r;
		else
			idx = c;
		if (!Boundary(r, c))
			return false;
		if (visited[idx])
			return false;
		if (maps[r][c] != originValue - 1)
			return false;
	}

	return true;
}

/// <summary>
/// NeedRamp에서 true를 받은 cr, cc를 인자로 넣어야 합니다.
/// </summary>
void Install(int r, int c, EDir dir, vector<int>& visited) {
	for (int i = 0; i < L; i++) {
		r += dr[(int)dir];
		c += dc[(int)dir];
		int idx;
		if ((int)dir % 2 == 0)
			idx = r;
		else
			idx = c;
		visited[idx] = true;
	}
}

bool Check(int idx, char type) {
	vector<int> visited(N);

	// 아래, 오른쪽
	for (int i = 0; i < N - 1; i++) {
		int cr, cc, nr, nc;
		EDir dir;
		if (type == 'v') {
			cr = i;
			nc = cc = idx;
			nr = i + 1;
			dir = DOWN;
		}
		else {
			cr = nr = idx;
			cc = i;
			nc = i + 1;
			dir = RIGHT;
		}
		if (NeedRamp(cr, cc, nr, nc)) {
			if (CanInstall(cr, cc, dir, visited)) {
				Install(cr, cc, dir, visited);
			}
			else {
				return false;
			}
		}
	}

	// 위 왼쪽
	for (int i = N - 1; i > 0; i--) {
		int cr, cc, nr, nc;
		EDir dir;
		if (type == 'v') {
			cr = i;
			nc = cc = idx;
			nr = i - 1;
			dir = UP;
		}
		else {
			cr = nr = idx;
			cc = i;
			nc = i - 1;
			dir = LEFT;
		}
		if (NeedRamp(cr, cc, nr, nc)) {
			if (CanInstall(cr, cc, dir, visited)) {
				Install(cr, cc, dir, visited);
			}
			else {
				return false;
			}
		}
	}

	return true;
}

void Solution() {
	int ret = 0;
	for (int i = 0; i < N; i++) {
		if (CanCandidate(i, 'v')) {
			ret += Check(i, 'v');
		}
		if (CanCandidate(i, 'h')) {
			ret += Check(i, 'h');
		}
	}
	cout << ret << '\n';
}
```

{: file='Ramp1.cpp'}
</div>
</details>

<details>
<summary>gpt 조언 받고 수정 (1번체크)-> 내리막 필요시와 오르막 필요시에 따라 맞춰 설계</summary>
<div markdown="1">

```cpp
bool Check(int idx, char type) {
	vector<int> visited(N);

	for (int i = 0; i < N - 1; i++) {
		int cr, cc, nr, nc;
		if (type == 'v') {
			cc = nc = idx;
			cr = i, nr = i + 1;
		}
		else {
			cr = nr = idx;
			cc = i, nc = i + 1;
		}

		int delta = maps[nr][nc] - maps[cr][cc];
		if (delta == 0) continue;
		if (delta == 1) {
			if (!CanInstall(nr, nc, type == 'v' ? UP : LEFT, visited)) return false;
			Install(nr, nc, type == 'v' ? UP : LEFT, visited);
		}
		else if (delta == -1) {
			if (!CanInstall(cr, cc, type == 'v' ? DOWN : RIGHT, visited)) return false;
			Install(cr, cc, type == 'v' ? DOWN : RIGHT, visited);
		}
	}

	return true;
}
```

{: file='Ramp2.cpp'}
</div>
</details>


> ### [백준 14719: 빗물(골5)](https://www.acmicpc.net/problem/14719)

빗물을 모두 채워넣고, 양 사이드에서 빗물을 빼는 방식으로 구현

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int H, W;
int maps[500][500];
bool Inputs() {
	cin >> H >> W;
	vector<int> nums(W);
	FOR(n, W)
		cin >> nums[n];

	// 맵 구성
	for (int i = 0; i < W; i++) {
		int r = 0;

		// 블록 세우기
		for (; r < nums[i]; r++) {
			maps[r][i] = 1;
		}

		// 빗물 집어넣기
		for (; r < H; r++) {
			maps[r][i] = 2;
		}
	}

	// 출력 체크
	/*FOR(r, H) {
		FOR(c, W)
			cout << maps[r][c] << ' ';
		cout << '\n';
	}*/

	return true;
}

void RemoveRain(int r, int c, int delta) {
	for (int i = 0; i < W; i++) {
		if (maps[r][c] != 2) break;
		maps[r][c] = 0;
		c += delta;
	}
}

int CountRain() {
	int ret = 0;
	FOR(r, H) {
		FOR(c, W) {
			if (maps[r][c] == 2) ret++;
		}
	}
	return ret;
}

void Solution() {
	for (int r = 0; r < H; r++) {
		// 빗물 제거
		if (maps[r][0] == 2) {
			RemoveRain(r, 0, 1);
		}

		if (maps[r][W - 1] == 2) {
			RemoveRain(r, W - 1, -1);
		}
	}
	cout << CountRain() << '\n';
}
```

{: file='Rain.cpp'}
</div>
</details>

> ### [백준 15683: 감시(골3)](https://www.acmicpc.net/problem/15683)

줄을 긋는 함수 설계가 중요했음

한줄로 긋도록하고 타입에 따라 여러줄로 그을 수 있도록 하면서 방향이 회전할 수 있도록 함

그리는 것을 누적하도록 해서 덮어씌워진 곳을 완전히 없애지 않도록 해야함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, M;
int maps[8][8];

struct CCTV {
	int r;
	int c;
	int type;
};
vector<CCTV> cctvs;

bool Inputs() {
	cin >> N >> M;
	FOR(r, N)
		FOR(c, M) {
		cin >> maps[r][c];
		if (1 <= maps[r][c] && maps[r][c] <= 5) {
			cctvs.push_back({ r, c, maps[r][c] });
			maps[r][c] = 0;
		}

	}

	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= M);
}

inline bool IsValid(int r, int c) {
	return Boundary(r, c) && maps[r][c] != 6;
}
enum EDir { RIGHT, UP, LEFT, DOWN };
int dr[4] = { 0, -1, 0, 1 };
int dc[4] = { 1, 0, -1, 0 };

void DrawStraight(int r, int c, int dir, int delta) {
	while (true) {
		if (!IsValid(r, c))return;

		maps[r][c] += 8 * delta;

		r += dr[dir];
		c += dc[dir];
	}
}

void Draw(CCTV cctv, int rotate, int delta) {
	if (cctv.type == 1) {
		DrawStraight(cctv.r, cctv.c, ((int)RIGHT + rotate) % 4, delta);
	}
	else if (cctv.type == 2) {
		DrawStraight(cctv.r, cctv.c, ((int)RIGHT + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)LEFT + rotate) % 4, delta);
	}
	else if (cctv.type == 3) {
		DrawStraight(cctv.r, cctv.c, ((int)RIGHT + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)UP + rotate) % 4, delta);
	}
	else if (cctv.type == 4) {
		DrawStraight(cctv.r, cctv.c, ((int)LEFT + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)UP + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)RIGHT + rotate) % 4, delta);
	}
	else if (cctv.type == 5) {
		DrawStraight(cctv.r, cctv.c, ((int)LEFT + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)UP + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)RIGHT + rotate) % 4, delta);
		DrawStraight(cctv.r, cctv.c, ((int)DOWN + rotate) % 4, delta);
	}
	else {
		cout << "잘못된 cctv type 입니다.\n";
	}
}

int CountingUnvisibleArea() {
	int ret = 0;
	FOR(r, N)
		FOR(c, M) {
		ret += (maps[r][c] == 0);
	}

	return ret;
}

int DFS(int idx) {
	if (idx == cctvs.size()) {
		return CountingUnvisibleArea();
	}

	int ret = INF;
	for (int rotate = 0; rotate < 4; rotate++) {
		Draw(cctvs[idx], rotate, 1);
		ret = min(ret, DFS(idx + 1));
		Draw(cctvs[idx], rotate, -1);
	}

	return ret;
}

void Solution() {
	cout << DFS(0);
}
```

{: file='CCTV.cpp'}
</div>
</details>

> ### [백준 14499: 주사위 굴리기(골4)](https://www.acmicpc.net/problem/14499)

비교적 최근에 풀어봤던 문제다보니 금방 풀었다고 생각함

dice를 5조각과 1조각으로 나누는 것이 핵심

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, M, sr, sc, K;
int maps[20][20];
int commands[1000];

enum EDir { RIGHT, LEFT, UP, DOWN };
int dr[4] = { 0, 0, -1, 1 };
int dc[4] = { 1, -1, 0, 0 };

int dice[3][3];
int diceBack;

bool Inputs() {
	cin >> N >> M >> sr >> sc >> K;
	FOR(r, N)
		FOR(c, M)
		cin >> maps[r][c];

	FOR(i, K) {
		cin >> commands[i];
		commands[i]--;
	}

	memset(dice, 0, sizeof(dice));
	diceBack = 0;

	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= M);
}

bool Move(int comm) {
	int nr = sr + dr[comm];
	int nc = sc + dc[comm];
	if (!Boundary(nr, nc))return false;

	int back = diceBack;

	switch (comm)
	{
	case (int)RIGHT:
		diceBack = dice[1][2];
		dice[1][2] = dice[1][1];
		dice[1][1] = dice[1][0];
		dice[1][0] = back;
		break;
	case (int)LEFT:
		diceBack = dice[1][0];
		dice[1][0] = dice[1][1];
		dice[1][1] = dice[1][2];
		dice[1][2] = back;
		break;
	case (int)UP:
		diceBack = dice[0][1];
		dice[0][1] = dice[1][1];
		dice[1][1] = dice[2][1];
		dice[2][1] = back;
		break;
	case (int)DOWN:
		diceBack = dice[2][1];
		dice[2][1] = dice[1][1];
		dice[1][1] = dice[0][1];
		dice[0][1] = back;
		break;
	default:
		cout << "잘못된 명령어 입력입니다.\n";
		break;
	}

	if (maps[nr][nc] == 0) {
		maps[nr][nc] = diceBack;
	}
	else {
		diceBack = maps[nr][nc];
		maps[nr][nc] = 0;
	}

	sr = nr;
	sc = nc;
	return true;
}

void Solution() {
	for (int i = 0; i < K; i++) {
		int comm = commands[i];
		if (Move(comm))
			cout << dice[1][1] << '\n';
	}
}
```

{: file='DiceRoll.cpp'}
</div>
</details>

> ### [백준 14891: 톱니바퀴(골5)](https://www.acmicpc.net/problem/14891)

번엔 직접 기어를 돌렸던 것 같은데 이번엔 인덱스만으로 처리

문제는 기어가 무조건 돌아가는 줄 알았는데 기어가 조건에 의해 돌아간다는걸 깜빡함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int gears[4][8];
int idxs[4];
int K;

struct Command {
	int idx;
	int dir;
};
vector<Command> commands;

bool Inputs() {
	FOR(i, 4) {
		FOR(j, 8) {
			char ch;
			cin >> ch;
			gears[i][j] = ch - '0';
		}
	}

	cin >> K;

	FOR(i, K) {
		int c, d;
		cin >> c >> d;
		commands.push_back({ c - 1, d });
	}

	memset(idxs, 0, sizeof(idxs));

	return true;
}

int ConvertIdx(int idx) {
	return (idx + 8) % 8;
}

void Rotate(int idx, int dir, vector<int>& visited) {
	if (idx < 0 || idx >= 4) return;
	if (visited[idx]) return;
	visited[idx] = true;
	int rightIdx = ConvertIdx(idxs[idx] + 2);
	int leftIdx = ConvertIdx(idxs[idx] - 2);
	if (idx > 0) {
		int lrIdx = ConvertIdx(idxs[idx - 1] + 2);
		if (gears[idx - 1][lrIdx] != gears[idx][leftIdx])
			Rotate(idx - 1, -dir, visited);
	}

	if (idx < 3) {
		int rlIdx = ConvertIdx(idxs[idx + 1] - 2);
		if (gears[idx + 1][rlIdx] != gears[idx][rightIdx])
			Rotate(idx + 1, -dir, visited);
	}

	idxs[idx] = ConvertIdx(idxs[idx] - dir);
}

int CalcScore() {
	int ret = 0;
	for (int i = 0; i < 4; i++) {
		int val = gears[i][idxs[i]];
		if (val == 1) {
			ret += pow(2, i);
		}
	}
	return ret;
}

void PrintIdxs() {
	for (int i = 0; i < 4; i++) {
		cout << idxs[i] << ' ';
	}
	cout << '\n';
}

void Solution() {
	//PrintIdxs();
	for (int i = 0; i < K; i++) {
		auto comm = commands[i];
		vector<int> visited(4);
		Rotate(comm.idx, comm.dir, visited);
		//PrintIdxs();
	}

	cout << CalcScore();
}
```

{: file='Gear.cpp'}
</div>
</details>

> ### [백준 17144: 미세먼지 안녕!(골4)](https://www.acmicpc.net/problem/17144)

나름 금방 품
 
먼지 송풍에서 경계값들에서 자꾸 틀림

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 미세먼지 확산
	// 인접한 네 방향으로 확산 (공기청정기나 바깥으로는 확산 x)
	// 확산되는 양은 5등분, 남은 양은 원래 양 - 5등분 * 확산된 개수
// 공기청정기 작동
	// 위쪽은 반시계로, 아래쪽은 시계로 순환
	// 먼지가 한 칸씩 이동
	// 공기 청정기로 들어간 먼지는 모두 정화
// 미세먼지 양 출력

int R, C, T;
int maps[50][50];

int cleaner;

bool Inputs() {
	cin >> R >> C >> T;
	FOR(r, R)
		FOR(c, C) {
		cin >> maps[r][c];
		if (maps[r][c] == -1)
			cleaner = r;
	}

	return true;
}

int tmp[50][50];
int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };

inline bool IsValid(int r, int c) {
	return !(r < 0 || r >= R || c < 0 || c >= C) && maps[r][c] != -1;
}

inline int DiffuseAmount(int durst) {
	return durst / 5;
}

void Diffuse(int r, int c) {
	int amount = DiffuseAmount(maps[r][c]);
	tmp[r][c] += maps[r][c];
	for (int i = 0; i < 4; i++) {
		int nr = r + dr[i];
		int nc = c + dc[i];
		if (IsValid(nr, nc)) {
			tmp[r][c] -= amount;
			tmp[nr][nc] += amount;
		}
	}
}

void Diffuse() {
	memset(tmp, 0, sizeof(tmp));
	tmp[cleaner - 1][0] = tmp[cleaner][0] = -1;
	for (int i = 0; i < R; i++) {
		for (int j = 0; j < C; j++) {
			if (maps[i][j] > 0) {
				Diffuse(i, j);
			}
		}
	}
	swap(tmp, maps);
}

void CleaningCCW(int startrow) {
	for (int r = startrow - 1; r > 0; r--)
		maps[r][0] = maps[r - 1][0];
	for (int c = 0; c < C - 1; c++)
		maps[0][c] = maps[0][c + 1];
	for (int r = 0; r < startrow; r++)
		maps[r][C - 1] = maps[r + 1][C - 1];
	for (int c = C - 1; c > 1; c--)
		maps[startrow][c] = maps[startrow][c - 1];
	maps[startrow][1] = 0;
}

void CleaningCW(int startrow) {
	for (int r = startrow + 1; r < R - 1; r++)
		maps[r][0] = maps[r + 1][0];
	for (int c = 0; c < C - 1; c++)
		maps[R - 1][c] = maps[R - 1][c + 1];
	for (int r = R - 1; r > startrow; r--)
		maps[r][C - 1] = maps[r - 1][C - 1];
	for (int c = C - 1; c > 1; c--)
		maps[startrow][c] = maps[startrow][c - 1];
	maps[startrow][1] = 0;
}

void Clean() {
	CleaningCCW(cleaner - 1);
	CleaningCW(cleaner);
}

int CountDust() {
	int ret = 0;
	FOR(r, R)
		FOR(c, C)
		ret += maps[r][c];
	return ret + 2;
}

void PrintMap() {
	FOR(r, R) {
		FOR(c, C) {
			cout << maps[r][c] << ' ';
		}
		cout << '\n';
	}
	cout << '\n';
}

void Solution() {
	for (int i = 0; i < T; i++) {
		Diffuse();
		//PrintMap();
		Clean();
		//PrintMap();
	}

	cout << CountDust();
}
```

{: file='Dust.cpp'}
</div>
</details>

> ### [백준 16234: 인구 이동(골4)](https://www.acmicpc.net/problem/16234)

BFS로 조건에 맞는 나라 연합맺고, 벡터로 추적해서 분배함

union find쓰면 8배쯤 줄어드는듯(800ms →100ms)

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, L, R;
int maps[50][50];

bool Inputs() {
	cin >> N >> L >> R;
	FOR(r, N)
		FOR(c, N)
		cin >> maps[r][c];

	return true;
}

struct Pos {
	int r, c;
};

int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };

inline bool IsValid(int r, int c, const vector<vector<int>>& visited) {
	return !(r < 0 || r >= N || c < 0 || c >= N) && !visited[r][c];
}

bool Union(int r, int c, vector<vector<int>>& visited) {
	visited[r][c] = true;
	queue<Pos> q;
	q.push({ r, c });

	int cnt = 0;
	int people = maps[r][c];
	vector<Pos> path;
	while (!q.empty()) {
		auto cur = q.front();
		q.pop();

		path.push_back(cur);

		for (int i = 0; i < 4; i++) {
			int nr = cur.r + dr[i];
			int nc = cur.c + dc[i];
			if (IsValid(nr, nc, visited)) {
				int diff = abs(maps[cur.r][cur.c] - maps[nr][nc]);
				if (L <= diff && diff <= R) {
					visited[nr][nc] = true;
					q.push({ nr, nc });
					cnt++;
					people += maps[nr][nc];
				}
			}
		}
	}

	for (int i = 0; i < path.size(); i++) {
		maps[path[i].r][path[i].c] = people / path.size();
	}
	return cnt != 0;
}

bool PeopleMove() {
	int cnt = 0;
	vector<vector<int>> visited(N, vector<int>(N));
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (!visited[i][j])
				cnt += Union(i, j, visited);
		}
	}

	return cnt != 0;
}

void Solution() {
	int days = 0;
	while (PeopleMove()) {
		days++;
	}
	cout << days;
}
```

{: file='PeopleMove.cpp'}
</div>
</details>

> ### [백준 17822: 원판 돌리기(골2)](https://www.acmicpc.net/problem/17822)

벡터의 길이가 최대 50밖에 안됐기 때문에 헷갈리는 idx리스트를 만들기보다는 벡터를 직접 돌림

nc를 설계할 때 원형으로 추적이 필요했음

끝처리라던가, 배수의 원판을 돌리는거나, 맵 처리 등에서 문제가 좀 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
int N, M, T;
vector<vector<int>> maps;

struct Command {
	int idx;
	int ccw;
	int cnt;
};
vector<Command> commands;

bool Inputs() {
	cin >> N >> M >> T;
	maps.resize(N, vector<int>(M));
	FOR(r, N)
		FOR(c, M)
		cin >> maps[r][c];

	commands.resize(T);
	FOR(i, T) {
		int idx, ccw, cnt;
		cin >> commands[i].idx >> commands[i].ccw >> commands[i].cnt;
		commands[i].idx;
	}

	return true;
}

// 회전시키기
// 인접 수 찾기
// 평균 구해서 +1, -1

void Rotate(Command comm) {
	for (int k = comm.idx; k <= N; k += comm.idx) {
		vector<int> tmp = maps[k - 1];
		for (int i = 0; i < M; i++) {
			maps[k - 1][i] = comm.ccw ? tmp[(i + comm.cnt) % M] : tmp[(i - comm.cnt + M) % M];
		}
	}
}

struct Pos {
	int r, c;
};
int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };

bool IsValid(int r, int c, const vector<vector<int>>& visited, int val) {
	return !(r < 0 || r >= N || c < 0 || c >= M) && !visited[r][c] && maps[r][c] == val;
}

bool BFS(int r, int c, vector<vector<int>>& visited) {
	queue<Pos> q;
	q.push({ r, c });
	visited[r][c] = true;
	if (maps[r][c] == 0) return false;
	int origin = maps[r][c];
	bool ret = false;

	while (!q.empty()) {
		auto cur = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = cur.r + dr[i];
			int nc = (cur.c + dc[i] + M) % M;
			if (IsValid(nr, nc, visited, origin)) {
				visited[nr][nc] = true;
				ret = true;
				maps[nr][nc] = 0;
				q.push({ nr, nc });
			}
		}
	}
	if (ret)
		maps[r][c] = 0;
	return ret;
}

bool Erase() {
	vector<vector<int>> visited(N, vector<int>(M));
	bool haveErase = false;
	FOR(r, N)
		FOR(c, M) {
		if (!visited[r][c]) {
			haveErase |= BFS(r, c, visited);
		}
	}
	return haveErase;
}

int Counting() {
	int ret = 0;
	FOR(r, N)
		FOR(c, M)
		ret += maps[r][c];
	return ret;
}

void Everage() {
	int sum = 0;
	int cnt = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (maps[i][j] == 0)continue;
			sum += maps[i][j];
			cnt++;
		}
	}

	double avrg = (double)sum / cnt;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++)
			sum += maps[i][j];
		for (int j = 0; j < M; j++) {
			if (maps[i][j] == 0) continue;
			if (maps[i][j] > avrg) {
				maps[i][j]--;
			}
			else if (maps[i][j] < avrg) {
				maps[i][j]++;
			}
		}
	}
}

void Solution() {
	for (int i = 0; i < T; i++) {
		Rotate(commands[i]);
		if (!Erase()) {
			Everage();
		}
		//PrintVec(maps);
		//cout << '\n';
	}

	cout << Counting();
}
```

{: file='Disc.cpp'}
</div>
</details>

> ### [백준 19236: 청소년 상어(골1)](https://www.acmicpc.net/problem/19236)

구현을 하긴 했는데 자꾸 실수가 있었고, 다중으로 관리하고 있다보니 놓친 자료구조가 있었음

이걸 잡느라 오래걸림 이럴거면 그냥 복제본을 전달하는게 나았을듯

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
enum EDir {
	UP, UL, LEFT, DL, DOWN, DR, RIGHT, UR
};
int dr[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
int dc[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };

struct Node {
	int fish;
	EDir dir;
};

int N = 4;
vector<vector<Node>> maps;
vector<int> ate;
unordered_map<int, pair<int, int>> fishPos;

bool Inputs() {
	maps.resize(N, vector<Node>(N));
	ate.resize(N * N + 1);

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			int f, d;
			cin >> f >> d;
			maps[i][j].fish = f;
			maps[i][j].dir = (EDir)(d - 1);
			fishPos[f] = { i, j };
		}
	}

	return true;
}

// 상어를 놓고 먹는 것
// 물고기 이동
// 상어가 더이상 이동하지 못한다면 

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= N);
}

constexpr int SHARK = 20;

bool CanSwap(int r, int c) {

	return Boundary(r, c) && maps[r][c].fish != SHARK;
}

void FishSwap(int r, int c, int nr, int nc) {
	auto origin = maps[r][c];
	auto target = maps[nr][nc];

	fishPos[target.fish] = { r, c };
	fishPos[origin.fish] = { nr, nc };

	maps[r][c] = target;
	maps[nr][nc] = origin;
}

void ChangeFishPos() {
	for (int i = 1; i < ate.size(); i++) {
		if (ate[i])continue;
		auto pos = fishPos[i];
		if (maps[pos.first][pos.second].fish != i) {
			cout << "물고기 위치랑 물고기 노드가 일치하지 않습니다 \n";
		}
		for (int i = 0; i < 8; i++) {
			auto dir = maps[pos.first][pos.second].dir;
			int nr = pos.first + dr[dir];
			int nc = pos.second + dc[dir];
			if (CanSwap(nr, nc)) {
				FishSwap(pos.first, pos.second, nr, nc);
				break;
			}
			maps[pos.first][pos.second].dir = (EDir)((maps[pos.first][pos.second].dir + 1) % 8);
		}
	}
}

void PrintFish() {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			cout << maps[i][j].fish << ' ';
		}
		cout << '\n';
	}
	cout << '\n';
}

void PrintDir() {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			cout << maps[i][j].dir << ' ';
		}
		cout << '\n';
	}
	cout << '\n';
}

void PrintPos() {
	for (int i = 1; i <= 16; i++) {
		cout << fishPos[i].first << ' ' << fishPos[i].second << '\n';
	}
}

int MaxEat(int r, int c) {
	int origin = maps[r][c].fish;
	int ret = 0;
	EDir dir = maps[r][c].dir;
	maps[r][c].fish = SHARK;
	ate[origin] = true;

	// 물고기 변환
	auto copymaps = maps;
	auto copypos = fishPos;
	ChangeFishPos();
	//PrintPos();

	maps[r][c].fish = 0;
	for (int i = 0; i < N; i++) {
		int nr = r + dr[dir] * (i + 1);
		int nc = c + dc[dir] * (i + 1);

		if (!Boundary(nr, nc)) continue;
		if (1 <= maps[nr][nc].fish && maps[nr][nc].fish <= 16) {
			ret = max(ret, MaxEat(nr, nc));
		}
	}
	maps = copymaps;
	fishPos = copypos;
	maps[r][c].fish = origin;
	ate[origin] = false;

	return ret + origin;
}

void Solution() {
	cout << MaxEat(0, 0);
}
```

{: file='TeenShark.cpp'}
</div>
</details>

> ### [백준 19237: 어른 상어(골1)](https://www.acmicpc.net/problem/19237)

거의 뭐.. 혼자 해결했다고 볼 수가 없음

너무 많이 다양하게 쪼개려고 한 것 같음

State를 쓴 것이 굳이 필요 없었음

- 처음엔 TNode에 State(빈, 냄새가 있는, 상어가 있는), 상어, 냄새 구조체를 가짐. 근데 상어가 순서별로 관리되고 있으면 좋을 것 같아서 상어를 순서대로 관리하는 구조체도 가지려고 했음. 그랬더니 이중관리 문제가 생겨서 힙할당을 하려고 했음. 근데 하다보니까 TNode에 상어 구조체가 필요가 없게 됐음. State에도 냄새와 상어가 같이 있어야 하는 문제가 있었음
- 두 번째로 상어와 냄새를 모두 일반 구조체로 다시 변경함. 근데도 계속 틀림. 예제정도는 맞았는데 심화 테스트에서 좀 틀림. 아무래도 초기화 문제가 좀 있었던거같음 (중요도 심각)
- 지피티를 통해서 단계는 똑같이 구성되어있지만, 첫 단계인 상어를 옮기는 단계가 조금 달랐음. 나는 상어 관리를 하나의 자료구조에서 했지만, 다음으로 이동할 예정인 상어 구조체들의 복제본(?)으로 따로 관리하게 됨. 병적으로 중복을 제거해야한다는 생각이 약간 문제였던 듯
- 결론) 스테이트도 enum은 필요 없고, 힙할당도 필요 없음. 추가 할당을 겁내지 말자
- 그리고 완전 처음에 상어의 개수가 모든 문제에 정해져있고, 우선순위가 정해져있는줄… → 문제좀 잘 읽자

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 상어가 번호에 따라, 같이 만나면 추방됨
// 상어는 번호에 따라, 방향에 따라 방향 우선순위가 달라짐
// 상어가 지나간 곳엔 냄새를 남김
// 냄새는 k시간동안 남음
// 냄새가 나는곳은 안감, 냄새가 안나는곳이 없으면 자신의 냄새가 나는곳으로 감 (여기서도 우선순위가 적용 되는듯?)
// 1상어만 남을때까지

enum ESpaceState {
	NONE, Smell,
};

enum EDir {
	UP, DOWN, LEFT, RIGHT
};

int dr[4] = { -1, 1, 0, 0 };
int dc[4] = { 0, 0, -1, 1 };

struct TPos {
	int r, c;
};

class TShark {
public:
	bool death = false;
	int num = 0;
	EDir dir = UP;
	TPos pos = { 0, 0 };
};

class TSmell {
public:
	int sharkNum = 0;
	int remainTime = 0;
};

struct TNode {
	TSmell smell;
};

int N, M, K;
//[shark][dir][priority]
vector<vector<vector<EDir>>> Priority;
vector<vector<TNode>> maps;
vector<TShark> sharks;

bool Inputs() {
	cin >> N >> M >> K;

	maps.resize(N, vector<TNode>(N));
	sharks.resize(M + 1);
	Priority.resize(M + 1, vector<vector<EDir>>(4, vector<EDir>(4)));
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			int n;
			cin >> n;
			if (n != 0) {
				maps[i][j].smell.sharkNum = n;
				maps[i][j].smell.remainTime = K;
				sharks[n].num = n;
				sharks[n].death = false;
				sharks[n].pos = { i, j };
			}
		}
	}

	for (int i = 1; i <= M; i++) {
		int dir;
		cin >> dir;
		sharks[i].dir = (EDir)(dir - 1);
	}

	for (int i = 1; i <= M; i++) {
		for (int j = 0; j < 4; j++) {
			for (int k = 0; k < 4; k++) {
				int n;
				cin >> n;
				Priority[i][j][k] = (EDir)(n - 1);
			}
		}
	}

	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= N);
}

inline bool HasSmell(int r, int c) {
	return maps[r][c].smell.remainTime > 0;
}

void PrintShark() {
	for (int i = 1; i <= M; i++) {
		if (sharks[i].death) {
			cout << i << " Shark is Dead\n";
		}
		else {
			cout << i << " shark is Alive and " << sharks[i].pos.r << ' ' << sharks[i].pos.c << ' ' << sharks[i].dir << '\n';
		}
	}
}

TShark NextPos(TShark shark) {
	TShark ret = shark;
	int r = shark.pos.r;
	int c = shark.pos.c;
	EDir d = shark.dir;

	// 냄새 없는 칸이 있다면
	for (int i = 0; i < 4; i++) {
		EDir nd = Priority[shark.num][d][i];
		int nr = r + dr[nd];
		int nc = c + dc[nd];

		if (!Boundary(nr, nc))continue;
		if (HasSmell(nr, nc))continue;

		ret.dir = nd;
		ret.pos.r = nr;
		ret.pos.c = nc;
		return ret;
	}

	// 냄새 없는 칸이 없다면 자기 냄새로
	for (int i = 0; i < 4; i++) {
		EDir nd = Priority[shark.num][d][i];
		int nr = r + dr[nd];
		int nc = c + dc[nd];

		if (!Boundary(nr, nc))continue;
		if (HasSmell(nr, nc) && maps[nr][nc].smell.sharkNum == shark.num) {
			ret.dir = nd;
			ret.pos.r = nr;
			ret.pos.c = nc;
			return ret;
		}
	}

	cout << "자기 냄새조차 없는 상어가 존재합니다. \n";
	return shark;
}

void Step() {
	// 상어들 다음 이동 경로
	vector<TShark> nextSharks;
	for (int i = 1; i <= M; i++) {
		if (sharks[i].death) continue;
		nextSharks.push_back(NextPos(sharks[i]));
	}

	// 실제 이동(작은놈은 사망) 상어 갱신
	vector<vector<int>> visited(N, vector<int>(N, 0));
	for (int i = 0; i < nextSharks.size(); i++) {
		int sharkNum = nextSharks[i].num;
		int r = nextSharks[i].pos.r;
		int c = nextSharks[i].pos.c;
		if (!visited[r][c]) {
			visited[r][c] = sharkNum;
			sharks[sharkNum].pos = nextSharks[i].pos;
			sharks[sharkNum].dir = nextSharks[i].dir;
		}
		else {
			sharks[sharkNum].death = true;
		}
	}

	// 냄새 시간 소모 및 제거
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (HasSmell(i, j)) {
				maps[i][j].smell.remainTime--;
				// 지워져야 하면 삭제
				if (maps[i][j].smell.remainTime == 0) {
					maps[i][j].smell.sharkNum = 0;
				}
			}
		}
	}

	// 냄새 생성
	for (int i = 1; i <= M; i++) {
		if (sharks[i].death)continue;
		auto pos = sharks[i].pos;
		maps[pos.r][pos.c].smell.remainTime = K;
		maps[pos.r][pos.c].smell.sharkNum = i;
	}
}

bool OnlyOne() {
	for (int i = 2; i <= M; i++) {
		if (!sharks[i].death) return false;
	}
	return sharks[1].death == false;
}

void Solution() {
	for (int i = 0; i < 1000; i++) {
		Step();
		if (OnlyOne()) {
			cout << i + 1 << '\n';
			return;
		}
		//PrintShark();
	}

	cout << -1 << '\n';
}
```

{: file='AdultShark.cpp'}
</div>
</details>

> ### [백준 20056: 마법사 상어와 파이어볼(골4)](https://www.acmicpc.net/problem/20056)

조건 하나를 놓쳤었음(0일 때 소멸)

틀렸을 땐 꼭 조건을 모두 구현했는지 돌아보기

순환하는 격자에서의 처리가 필요했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 격자는  NxN, 파이어볼 M개, 격자는 계속 순환함
// 파이어볼 위치는 ri, ci, 질량은 mi, 방향은 di, 속력은 si

// 방향 순서
enum EDir { UP, UR, RIGHT, DR, DOWN, DL, LEFT, UL, END };
int dr[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
int dc[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };

// 규칙
// 모든 파이어볼이 자신의 방향 di로 속력 si칸 만큼 이동
// 이동하는 중은 계산 x
// 이동이 모두 끝나면 2개 이상의 파이어볼이 있는 칸에서 다음과 같은 일이 일어남
	// 파이어볼은 모두 하나로 합쳐지고, 4개로 나누어짐
	// 질량은 전체합 / 5, 속력은 전체합 / 합쳐진 파이어볼 개수 => 소수점은 모두 내림처리
	// 모두 홀수이거나 모두 짝수면 방향이 0, 2,4, 6이 되고, 아니면 1, 3, 5, 7이 됨
	// 질량이 0인 파이어볼은 소멸됨

// 결과
// K번 이동 후 파이어볼의 질량 합

int N, M, K;
struct Pos {
	int r = 0, c = 0;
};

struct FireBall {
	Pos pos = { 0, 0 };
	int mass = 0;
	int speed = 0;
	EDir dir = END;
};

vector<FireBall> fireBalls;

bool Inputs() {
	cin >> N >> M >> K;
	fireBalls.resize(M);
	for (int i = 0; i < M; i++) {
		int dir;
		cin >> fireBalls[i].pos.r >> fireBalls[i].pos.c >> fireBalls[i].mass >> fireBalls[i].speed >> dir;
		fireBalls[i].dir = (EDir)dir;
		fireBalls[i].pos.r--;
		fireBalls[i].pos.c--;
	}
	return true;
}

int CountingMass() {
	int ret = 0;
	for (int i = 0; i < fireBalls.size(); i++) {
		ret += fireBalls[i].mass;
	}
	return ret;
}

FireBall Move(FireBall fb) {
	int r = fb.pos.r;
	int c = fb.pos.c;
	EDir d = fb.dir;
	int s = fb.speed;

	// origin + delta + Min_Max % N
	int nr = (r + dr[d] * s + N * 250) % N;
	int nc = (c + dc[d] * s + N * 250) % N;

	fb.pos.r = nr;
	fb.pos.c = nc;
	return fb;
}

void PrintFireBalls() {
	for (int i = 0; i < fireBalls.size(); i++) {
		cout << fireBalls[i].pos.r << ' ' << fireBalls[i].pos.c << '\n';
	}
}

vector<FireBall> Divide(vector<FireBall>& fbs) {
	if (fbs.size() == 1) {
		return fbs;
	}

	// 속력 및 질량 구하기
	int ms = 0, ss = 0;
	Pos pos = fbs[0].pos;

	// 방향 구하기
	bool isOdd = false;
	bool isEven = false;
	for (int i = 0; i < fbs.size(); i++) {
		ms += fbs[i].mass;
		ss += fbs[i].speed;

		if (fbs[i].dir % 2 == 0) {
			isEven = true;
		}
		else {
			isOdd = true;
		}
	}
	int nm = ms / 5;
	if (nm == 0) return {};
	int ns = ss / fbs.size();

	vector<FireBall> ret(4);
	for (int i = 0; i < 4; i++) {
		ret[i].dir = EDir(isOdd ^ isEven ? 2 * i : 1 + 2 * i);
		ret[i].mass = nm;
		ret[i].speed = ns;
		ret[i].pos = pos;
	}

	return ret;
}

void Step() {
	// [r][c][fireballs]
	vector<vector<vector<FireBall>>> maps(N, vector<vector<FireBall>>(N));

	// 1. 파이어볼 이동
	for (int i = 0; i < fireBalls.size(); i++) {
		auto ret = Move(fireBalls[i]);
		auto pos = ret.pos;
		maps[pos.r][pos.c].push_back(ret);
	}

	// 2. 파이어볼 중복 처리
	fireBalls.clear();
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (!maps[i][j].empty()) {
				auto vec = Divide(maps[i][j]);
				if (vec.empty())continue;
				fireBalls.insert(fireBalls.end(), vec.begin(), vec.end());
			}
		}
	}

}

void Solution() {
	for (int i = 0; i < K; i++) {
		Step();
		//PrintFireBalls();
	}

	cout << CountingMass();
}
```

{: file='Fireball.css'}
</div>
</details>

> ### [백준 20057: 마법사 상어와 토네이도(골3)](https://www.acmicpc.net/problem/20057)

아니 이건 좀 문제 설명이 부족함

알파에 대한 처리가 문제가 좀 있었음

next에 대한 정보를 바로 갱신하지 않는 것이 매우 톡톡한 역할을 했음

[https://www.youtube.com/watch?v=bIP_DOPaG2U](https://www.youtube.com/watch?v=bIP_DOPaG2U) - 덕분에 모래 날리는 부분에서 문제가 발생했다는걸 나름 손쉽게 알 수 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// NxN 격자 A[r][c]는 모래의 양을 뜻함
// 토네이도는 가운데부터 시작

enum EDir { LEFT, DOWN, RIGHT, UP };
int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { -1, 0, 1, 0 };

int N;
vector<vector<int>> maps;
struct Pos {
	int r = 0, c = 0;
};
Pos tornadoPos;
EDir tornadoDir;
int sandTotal = 0;
bool Inputs() {
	cin >> N;
	maps.resize(N, vector<int>(N));
	FOR(r, N)
		FOR(c, N) {
		cin >> maps[r][c];
		sandTotal += maps[r][c];
	}

	tornadoPos.r = tornadoPos.c = N / 2;
	tornadoDir = LEFT;
	return true;
}

int moveCnt = 0;
int rotateCnt = 0;
int moveLevel = 1;

// 토네이도의 다음 포지션과 다음 방향을 반환
pair<Pos, EDir> NextTornadoPos() {
	auto pos = tornadoPos;
	auto dir = tornadoDir;
	int nr = pos.r + dr[dir];
	int nc = pos.c + dc[dir];

	moveCnt++;
	if (moveCnt == moveLevel) {
		moveCnt = 0;
		rotateCnt++;
		dir = (EDir)((dir + 1) % 4);
		if (rotateCnt == 2) {
			rotateCnt = 0;
			moveLevel++;
		}
	}

	return { {nr, nc}, dir };
}

void PrintTornadoPos() {
	cout << tornadoPos.r << ' ' << tornadoPos.c << ' ' << tornadoDir << '\n';
}

int CountingSandAmount() {
	int ret = 0;
	FOR(r, N)
		FOR(c, N)
		ret += maps[r][c];
	return ret;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= N);
}

int ConvertDir(int num) {
	return (num + 4 * 1000) % 4;
}

int PushSand(int r, int c, int sand, float percent) {
	int ret = sand * percent;
	if (Boundary(r, c)) {
		maps[r][c] += ret;
	}
	return ret;
}

void Spread() {
	// 어떤 위치인지, 어떤 방향인지에 따라 달라짐
	Pos pos = tornadoPos;
	EDir dir = tornadoDir;

	int sand = maps[pos.r][pos.c];
	maps[pos.r][pos.c] = 0;
	int spread = 0;

	// 진행 방향의 2칸 뒤로 5퍼
	int nr = pos.r + dr[dir] * 2;
	int nc = pos.c + dc[dir] * 2;
	spread += PushSand(nr, nc, sand, 0.05f);

	// 진행 방향의 수직 방향 2칸 뒤로 2퍼
	nr = pos.r + dr[ConvertDir(dir + 1)] * 2;
	nc = pos.c + dc[ConvertDir(dir + 1)] * 2;
	spread += PushSand(nr, nc, sand, 0.02f);
	nr = pos.r + dr[ConvertDir(dir - 1)] * 2;
	nc = pos.c + dc[ConvertDir(dir - 1)] * 2;
	spread += PushSand(nr, nc, sand, 0.02f);

	// 진행 방향의 수직 방향 1칸 뒤로 7퍼
	nr = pos.r + dr[ConvertDir(dir + 1)] * 1;
	nc = pos.c + dc[ConvertDir(dir + 1)] * 1;
	spread += PushSand(nr, nc, sand, 0.07f);
	nr = pos.r + dr[ConvertDir(dir - 1)] * 1;
	nc = pos.c + dc[ConvertDir(dir - 1)] * 1;
	spread += PushSand(nr, nc, sand, 0.07f);

	// 진행방향, 수직, 방향 1칸씩 뒤로 10퍼
	nr = pos.r + dr[ConvertDir(dir)] + dr[ConvertDir(dir + 1)];
	nc = pos.c + dc[ConvertDir(dir)] + dc[ConvertDir(dir + 1)];
	spread += PushSand(nr, nc, sand, 0.1f);
	nr = pos.r + dr[ConvertDir(dir)] + dr[ConvertDir(dir - 1)];
	nc = pos.c + dc[ConvertDir(dir)] + dc[ConvertDir(dir - 1)];
	spread += PushSand(nr, nc, sand, 0.1f);

	// 진행방향 반대, 수직 1칸씩 뒤로 1퍼
	nr = pos.r + dr[ConvertDir(dir + 2)] + dr[ConvertDir(dir + 1)];
	nc = pos.c + dc[ConvertDir(dir + 2)] + dc[ConvertDir(dir + 1)];
	spread += PushSand(nr, nc, sand, 0.01f);
	nr = pos.r + dr[ConvertDir(dir + 2)] + dr[ConvertDir(dir - 1)];
	nc = pos.c + dc[ConvertDir(dir + 2)] + dc[ConvertDir(dir - 1)];
	spread += PushSand(nr, nc, sand, 0.01f);

	// 진행방향 다음 칸 남은것
	nr = pos.r + dr[ConvertDir(dir)];
	nc = pos.c + dc[ConvertDir(dir)];
	PushSand(nr, nc, sand - spread, 1.f);
}

void PrintSandMap() {
	cout << "================\n";
	PrintVec(maps);
}

void Solution() {

	// 토네이도가 0, 0에 도착하면 종료
	int step = 1;
	while (tornadoPos.r != 0 || tornadoPos.c != 0) {
		// 토네이도의 이동 경로 확보
		auto nextData = NextTornadoPos();
		tornadoPos = nextData.first;
		// 모래 퍼지기
		Spread();
		tornadoDir = nextData.second;
		//PrintTornadoPos();
		//cout << "step: " << step << '\n';
		//PrintSandMap();
		//cout << sandTotal - CountingSandAmount() << '\n' << '\n';
		step++;
	}

	// 남간 모래 양 출력
	cout << sandTotal - CountingSandAmount() << '\n';
}
```

{: file='Tornado.css'}
</div>
</details>

> ### [백준 20058: 마법사 상어와 파이어스톰(골3)](https://www.acmicpc.net/problem/20058)

사각형 자르기, 회전, 완전탐색이 필요했음

- tmp 벡터를 매 함수 호출마다 초기화하기 때문에 전역으로 둬도 됐음
- 사각형 자르기를 할 때 중간에 어떤 과정이 필요한게 아니라면 2중포문으로도 해결할 수 있었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// N^2xN^2인 격자
// 얼음을 녹인다는게 뭔소린지 모르겠음. 꼭지점에 있는것만 녹는건가?

// 과정
// 2^L x 2^L로 나눠서 시계방향으로 90도 회전
// 2개 이하로 주위에 얼음이 있는 얼음 양 1 줄어들기

// 결과
// 남아있는 얼음 합
// 가장 큰 덩어리의 칸 개수

int N, Q, S;
vector<vector<int>> maps;
vector<int> powers;
int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };
struct Pos {
	int r = 0, c = 0;
};

bool Inputs() {
	cin >> N >> Q;
	S = pow(2, N);
	maps.resize(S, vector<int>(S));
	FOR(r, S)
		FOR(c, S)
		cin >> maps[r][c];
	powers.resize(Q);
	FOR(i, Q)
		cin >> powers[i];
	return true;
}

inline bool Boundary(int r, int c);

void Rotate(int r, int c, int size) {
	// 복사본 초기화
	vector<vector<int>> tmp(size, vector<int>(size));
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			tmp[i][j] = maps[r + i][c + j];
		}
	}

	// [_r][_c] -> [_c][ size- 1- _r ] 인듯?
	// 0, 0 => 0, 4 / 0, 1 => 1, 4 / 0, 2 => 2, 4
	// 1, 0 => 0, 3 / 1, 1 => 1, 3 / 1, 2 => 2, 3
	// 그럼 전체 맵에 대입하면
	// [_r][_c] -> [r + _c][c + size-1-_r] ? 
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			maps[r + j][c + size - 1 - i] = tmp[i][j];
		}
	}
}

void Square(int r, int c, int size, int target) {
	// 회전
	if (size == target) {
		Rotate(r, c, size);
		return;
	}

	int half = size / 2;
	Square(r, c, half, target);
	Square(r + half, c, half, target);
	Square(r, c + half, half, target);
	Square(r + half, c + half, half, target);
}

/// <summary>
/// 2^power x 2^power의 크기로 나눠서 시계방향으로 90도 회전하는 함수입니다.
/// </summary>
void Tornado(int power) {
	Square(0, 0, S, pow(2, power));
}

inline bool IsIce(int r, int c) {
	return Boundary(r, c) && maps[r][c] != 0;
}

/// <summary>
/// 주위에 있는 얼음의 개수를 세는 함수입니다.
/// </summary>
int AroundIceCnt(int r, int c) {
	int cnt = 0;
	for (int i = 0; i < 4; i++) {
		int nr = r + dr[i];
		int nc = c + dc[i];
		cnt += IsIce(nr, nc);
	}
	return cnt;
}

/// <summary>
/// 얼음판에서 녹아야 할 얼음이 존재한다면 녹이는 함수입니다.
/// </summary>
void Melting() {
	auto copyMap = maps;
	for (int i = 0; i < S; i++) {
		for (int j = 0; j < S; j++) {
			if (IsIce(i, j)) {
				int ret = AroundIceCnt(i, j);
				if (ret < 3)
					copyMap[i][j]--;
			}
		}
	}
	swap(copyMap, maps);
}

/// <summary>
/// 현재 얼음의 합을 반환하는 함수입니다.
/// </summary>
int IceSum() {
	int ret = 0;
	FOR(r, S)
		FOR(c, S) {
		ret += maps[r][c];
	}
	return ret;
}
inline bool IsValid(int r, int c, vector<vector<int>>& visited);

/// <summary>
/// BFS로 이어져있는 얼음 덩어리의 개수를 반환하는 함수입니다.
/// </summary>
int BFS(int r, int c, vector<vector<int>>& visited);

/// <summary>
/// 현재 얼음판에서 가장 큰 얼음 덩어리의 칸 개수를 반환하는 함수입니다.
/// </summary>
int MaxChunkSize() {
	vector<vector<int>> visited(S, vector<int>(S));
	int ret = 0;
	FOR(r, S)
		FOR(c, S) {
		if (IsValid(r, c, visited)) {
			ret = max(ret, BFS(r, c, visited));
		}
	}
	return ret;
}

void Solution() {
	for (int i = 0; i < Q; i++) {
		Tornado(powers[i]);
		Melting();
	}
	//PrintVec(maps);
	//cout << '\n';
	cout << IceSum() << '\n' << MaxChunkSize() << '\n';
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= S || c < 0 || c >= S);
}

inline bool IsValid(int r, int c, vector<vector<int>>& visited) {
	return Boundary(r, c) && !visited[r][c] && maps[r][c] != 0;
}
int BFS(int r, int c, vector<vector<int>>& visited) {
	visited[r][c] = true;
	queue<Pos> q;
	q.push({ r, c });

	int ret = 1;
	while (!q.empty()) {
		auto cur = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nr = cur.r + dr[i];
			int nc = cur.c + dc[i];
			if (IsValid(nr, nc, visited)) {
				visited[nr][nc] = true;
				q.push({ nr, nc });
				ret++;
			}
		}
	}

	return ret;
}
```

{: file='Firestorm.css'}
</div>
</details>

> ### [백준 21610: 마법사 상어와 비바라기(골5)](https://www.acmicpc.net/problem/21610)

루프 격자, 대각선 움직임, 다음 스탭 생성과 처리 시점

근데 구름 만들어질 때 물이 줄어드는걸 놓쳤었음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
enum EDir { LEFT, UL, UP, UR, RIGHT, DR, DOWN, DL, END };
int dr[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };
int dc[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };

struct Pos {
	int r = 0, c = 0;
};

struct Commands {
	EDir dir = END;
	int speed = 0;
};

int N, M;
vector<vector<int>> maps;
vector<Commands> commands;

bool Inputs() {
	cin >> N >> M;
	maps.resize(N, vector<int>(N));
	commands.resize(M);
	FOR(r, N)
		FOR(c, N)
		cin >> maps[r][c];

	FOR(i, M) {
		int dir;
		cin >> dir >> commands[i].speed;
		commands[i].dir = (EDir)(dir - 1);
	}

	return true;
}

// 구름 첫 생성
// 루프
	// 구름 이동
	// 구름 생성

vector<Pos> clouds;
void CloudInit() {
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			clouds.push_back({ N - 1 - i, j });
		}
	}
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= N || c < 0 || c >= N);
}

inline Pos LoopPos(int r, int c) {
	return { (r + N * 50) % N,(c + N * 50) % N };
}

Pos Move(Pos cloud, EDir dir, int speed) {
	int nr = cloud.r + dr[dir] * speed;
	int nc = cloud.c + dc[dir] * speed;
	return LoopPos(nr, nc);
}

void CloudMove(EDir dir, int speed) {
	for (int i = 0; i < clouds.size(); i++) {
		clouds[i] = Move(clouds[i], dir, speed);
	}
}

void Raining() {
	for (int i = 0; i < clouds.size(); i++) {
		maps[clouds[i].r][clouds[i].c]++;
	}
}

/// <summary>
/// 물이 있는지 검사합니다. 이 때 경계를 넘지 못합니다.
/// </summary>
inline bool HasWater(int r, int c) {
	return Boundary(r, c) && maps[r][c] != 0;
}

/// <summary>
/// 주변에 있는 물의 개수를 세는 함수입니다.
/// </summary>
int CountingAroundWater(int r, int c) {
	int ret = 0;
	for (int i = 1; i < END; i += 2) {
		int nr = r + dr[i];
		int nc = c + dc[i];
		ret += HasWater(nr, nc);
	}

	return ret;
}

/// <summary>
/// 대각선 방향의 물 개수만큼 증가
/// </summary>
void CopyBug() {
	auto copymap = maps;
	for (int i = 0; i < clouds.size(); i++) {
		auto pos = clouds[i];
		int res = CountingAroundWater(pos.r, pos.c);

		// 여기서 문제가 있는데, 이전 값을 저장해야겠지?
		copymap[pos.r][pos.c] += res;
	}
	swap(copymap, maps);
}

void CloudGen() {
	vector<Pos> nextClouds;
	vector<vector<int>> visited(N, vector<int>(N));
	for (int i = 0; i < clouds.size(); i++) {
		auto pos = clouds[i];
		visited[pos.r][pos.c] = true;
	}

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (!visited[i][j] && maps[i][j] >= 2) {
				nextClouds.push_back({ i, j });
				maps[i][j] -= 2;
			}
		}
	}
	swap(nextClouds, clouds);
}

int WaterAmount() {
	int ret = 0;

	FOR(r, N)
		FOR(c, N)
		ret += maps[r][c];

	return ret;
}

void PrintMaps() {
	PrintVec(maps);
	cout << '\n';
}

void Solution() {
	CloudInit();
	for (int i = 0; i < M; i++) {
		CloudMove(commands[i].dir, commands[i].speed);
		Raining();
		CopyBug();
		CloudGen();

		//PrintMaps();
	}

	cout << WaterAmount();
}
```

{: file='Rain.css'}
</div>
</details>

> ### [백준 21611: 마법사 상어와 블리자드(골1)](https://www.acmicpc.net/problem/21611)

소용돌이를 하나의 line으로 잘 풀었내서 해결했음

라인으로 만들기 위한 전처리가 상당히 오래걸림

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
enum EDir { UP, DOWN, LEFT, RIGHT, END };
int dr[EDir::END] = { -1, 1, 0, 0 };
int dc[EDir::END] = { 0, 0, -1, 1 };
struct Pos {
	int r = 0, c = 0;
};
struct Command {
	EDir dir = EDir::END;
	int len = 0;
};
int N, M;
vector<int> lines;
vector<vector<int>> mapToLineIdx;
vector<Command>commands;
Pos center;

void MapToLine(const vector<vector<int>>& maps, vector<int>& line, vector<vector<int>>& mapToLineIdx) {
	mapToLineIdx.resize(N, vector<int>(N));
	lines.resize(N * N - 1);
	EDir rotate[4] = { LEFT, DOWN, RIGHT, UP };
	int dir = 0;
	Pos cur = center;

	int idx = 0;

	int steps = 0, rotCnt = 0, stepLv = 1;
	while (cur.r != 0 || cur.c != 0) {
		// 위치 변화
		cur.r = cur.r + dr[rotate[dir]];
		cur.c = cur.c + dc[rotate[dir]];

		//cout << cur.r << ' ' << cur.c << '\n';

		// 데이터 기입
		mapToLineIdx[cur.r][cur.c] = idx;
		lines[idx] = maps[cur.r][cur.c];
		idx++;

		// 위치 변화를 위한 데이터 변화
		steps++;
		if (steps == stepLv) {
			steps = 0;
			rotCnt++;
			dir = (dir + 1) % 4;
			if (rotCnt == 2) {
				rotCnt = 0;
				stepLv++;
			}
		}
	}
}

bool Inputs() {
	cin >> N >> M;
	vector<vector<int>> maps(N, vector<int>(N));
	commands.resize(M);
	center = { N / 2, N / 2 };
	FOR(r, N)
		FOR(c, N)
		cin >> maps[r][c];

	FOR(i, M) {
		int dir;
		cin >> dir >> commands[i].len;
		commands[i].dir = (EDir)(dir - 1);
	}

	MapToLine(maps, lines, mapToLineIdx);

	//PrintVec(mapToLineIdx);

	return true;
}

void Blizard(Command comm) {
	for (int i = 0; i < comm.len; i++) {
		int nr = center.r + dr[comm.dir] * (i + 1);
		int nc = center.c + dc[comm.dir] * (i + 1);
		int idx = mapToLineIdx[nr][nc];
		lines[idx] = 0;
	}
}

void LineRefresh() {
	int curIdx = 0;
	int zeroCnt = 0;
	for (int i = 0; i < lines.size(); i++) {
		if (lines[i] == 0) {
			zeroCnt++;
		}
		else {
			lines[curIdx] = lines[curIdx + zeroCnt];
			curIdx++;
		}
	}

	for (int i = 0; i < zeroCnt; i++) {
		lines[lines.size() - 1 - i] = 0;
	}
}

int oneP = 0, twoP = 0, threeP = 0;
bool Pang() {
	int ret = false;

	int cur = 0;
	int sequence = 0;
	for (int i = 0; i < lines.size(); i++) {
		//if (lines[i] == 0) break;

		if (cur != lines[i]) {
			// 4이상이면
			// i - sequence ~ i까지 0으로 만들어야 함
			if (sequence >= 3) {
				if (cur == 1) {
					oneP += sequence + 1;
				}
				else if (cur == 2) {
					twoP += sequence + 1;
				}
				else {
					threeP += sequence + 1;
				}
				for (int j = i - sequence - 1; j < i; j++) {
					lines[j] = 0;
				}
				ret = true;
			}

			cur = lines[i];
			sequence = 0;
		}
		else {
			sequence++;
		}

	}

	return ret;
}

void PrintLine() {
	PrintVec(lines);
}

void Increase() {
	vector<int> tmp(lines.size());
	int tmpIdx = 0;

	int sequence = 1;
	int cur = lines[0];
	for (int i = 1; i < lines.size(); i++) {
		if (cur != lines[i]) {
			tmp[tmpIdx++] = sequence;
			tmp[tmpIdx++] = cur;
			if (sequence >= 4) {
				cout << "터지지 않은 문제가 존재합니다.\n";
			}
			cur = lines[i];
			sequence = 1;
		}
		else {
			sequence++;
		}
		if (tmpIdx >= lines.size()) break;
	}
	swap(tmp, lines);
}

void Solution() {
	for (int i = 0; i < M; i++) {
		// 블리자드
		Blizard(commands[i]);

		// 4개짜리 파괴 안될때까지 반복
		while (true) {
			// 구슬 내려오기
			LineRefresh();

			//PrintLine();
			// 4개짜리 파괴
			int broken = Pang();
			//PrintLine();
			if (broken == 0) break;

		}
		// 구슬 증식
		Increase();

		//PrintLine();
	}
	cout << oneP + 2 * twoP + 3 * threeP;
}
```

{: file='Blizard.css'}
</div>
</details>

> ### [백준 23290: 마법사 상어와 복제(골1)](https://www.acmicpc.net/problem/23290)

상어가 먹게되는 물고기 양 처리, 상어의 경로 처리 등이 어려웠음

처음엔 상어 위치를 갱신 안해줘서 → 같은 자리를 갈 수 없도록 처리해서 → 초기화를 -1로 해야하는데 0으로 해서 오래 걸림

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
// 1. 복제 마법을 검. 이건 마지막에 나타나기때문에 현재의 맵 상태를 보관해야 함
// 2. 물고기가 모두 이동을 함. 이는 물고기 냄새, 상어, 다른 물고기가 있어서는 안됨. 물고기는 반시계 45도 회전을 함
//		물고기가 이동할 수 없으면 이동하지 않음
// 3. 상어는 3칸 연속으로 이동함. 가장 물고기를 많이 먹는 순서로, 그 중 가장 빠른 사전순(상(1), 좌(2), 하(3), 우(4)가 기준인듯)으로 움직임
//		가는길에 있는 물고기들은 잡아먹히고, 냄새를 남김
// 4. 2턴 지속된 냄새는 사라짐
// 5. 1에서 건 복제 마법이 나타남. 원래 위치랑 방향을 그대로 가짐

enum EDir { LEFT, UL, UP, UR, RIGHT, DR, DOWN, DL, END };
int dr[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };
int dc[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
EDir shrakPriority[4] = { UP, LEFT, DOWN, RIGHT };

// 물고기의 방향, 물고기의 유무, 냄새, 상어 를 모두 표현할 수 없나?
// 물고기의 방향과 유무는 EDir로 나타낼 수 있음
// 상어는 그냥 Pos하나 갖고, 냄새는 다른 vvec이면 될듯

// [r][c][물고기들] = 물고기들 방향
vector<vector<vector<EDir>>> maps;
vector<vector<int>> smells;
struct Pos {
	int r = 0, c = 0;
};
Pos sharkPos;

int M, S;
bool Inputs() {
	cin >> M >> S;
	maps.resize(4, vector<vector<EDir>>(4));
	smells.resize(4, vector<int>(4, 0));
	for (int i = 0; i < M; i++) {
		int r, c, d;
		cin >> r >> c >> d;
		maps[r - 1][c - 1].push_back(EDir(d - 1));
	}

	cin >> sharkPos.r >> sharkPos.c;
	sharkPos.r--;
	sharkPos.c--;
	return true;
}

inline bool Boundary(int r, int c) {
	return !(r < 0 || r >= 4 || c < 0 || c >= 4);
}

inline bool HasSmell(int r, int c) {
	return smells[r][c] > 0;
}

inline bool IsSharkPos(int r, int c) {
	return sharkPos.r == r && sharkPos.c == c;
}

void FishMove(vector<vector<vector<EDir>>>& nextMap) {
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			// [r][c]의 물고기들
			for (int k = 0; k < maps[r][c].size(); k++) {
				EDir dir = maps[r][c][k];
				bool cantMove = true;
				// 45도 회전
				for (int d = 0; d < 8; d++) {
					EDir nd = EDir((dir - d + 8) % 8);
					int nr = r + dr[nd];
					int nc = c + dc[nd];
					if (Boundary(nr, nc) && !HasSmell(nr, nc) && !IsSharkPos(nr, nc)) {
						nextMap[nr][nc].push_back(nd);
						cantMove = false;
						break;
					}
				}
				// 아무데도 못간 물고기
				if (cantMove) {
					nextMap[r][c].push_back(dir);
				}
			}
		}
	}
}

void SharkMove(vector<vector<vector<EDir>>>& nextMap) {
	// 가장 많이 먹는 경로 찾기
	int maxValue = -1;
	Pos path[3] = {};

	for (int i = 0; i < 4; i++) {
		EDir first = shrakPriority[i];
		int fr = sharkPos.r + dr[first];
		int fc = sharkPos.c + dc[first];
		if (!Boundary(fr, fc)) continue;
		int fsum = nextMap[fr][fc].size();
		for (int j = 0; j < 4; j++) {
			EDir second = shrakPriority[j];
			int sr = fr + dr[second];
			int sc = fc + dc[second];
			if (!Boundary(sr, sc))continue;
			int ssum = nextMap[sr][sc].size();
			if (sr == fr && sc == fc) ssum = 0;

			for (int k = 0; k < 4; k++) {
				EDir third = shrakPriority[k];
				int tr = sr + dr[third];
				int tc = sc + dc[third];
				if (!Boundary(tr, tc)) continue;
				int tsum = nextMap[tr][tc].size();
				if ((tr == sr && tc == sc) || (tr == fr && tc == fc)) tsum = 0;

				if (fsum + ssum + tsum > maxValue) {
					maxValue = fsum + ssum + tsum;
					path[0] = { fr, fc };
					path[1] = { sr, sc };
					path[2] = { tr, tc };
				}
			}
		}
	}

	// 진짜 이동 및 물고기 먹어서 냄새 남기기
	for (int i = 0; i < 3; i++) {
		int r = path[i].r;
		int c = path[i].c;
		if (!nextMap[r][c].empty()) {
			nextMap[r][c].clear();
			smells[r][c] = 3;
		}
	}
	sharkPos = path[2];
}

void TimeFlow() {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (smells[i][j] != 0) {
				smells[i][j]--;
			}
		}
	}
}

void Manifest(vector<vector<vector<EDir>>>& nextMap) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (!maps[i][j].empty()) {
				nextMap[i][j].insert(nextMap[i][j].end(), maps[i][j].begin(), maps[i][j].end());
			}
		}
	}

	swap(nextMap, maps);
}

int CountFish() {
	int ret = 0;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			ret += maps[i][j].size();
		}
	}
	return ret;
}

void Solution() {
	for (int i = 0; i < S; i++) {
		// 복제마법
		vector<vector<vector<EDir>>> nextMap(4, vector<vector<EDir>>(4));

		// 물고기 이동
		FishMove(nextMap);

		// 상어 이동
		SharkMove(nextMap);

		// 냄새 줄이기
		TimeFlow();

		// 복제한거 나타나기
		Manifest(nextMap);
	}

	cout << CountFish();
}
```

{: file='Copy.css'}
</div>
</details>

## LeetCode

## Easy

> ### [LeetCode 412: Fizz Buzz](https://leetcode.com/problems/fizz-buzz/)

특정 인덱스마다 별도로 관리하는 문제

<details>
<summary>소스 코드</summary>
<div markdown="1">
```cpp
class Solution {
public:
    vector<string> fizzBuzz(int n) {
        vector<string> ret;
        for (int i = 1; i <= n; i++) {
            string str = "";
            if (i % 3 != 0 && i % 5 != 0) {
                str += to_string(i);
            } else {
                if (i % 3 == 0)
                    str += "Fizz";
                if (i % 5 == 0)
                    str += "Buzz";
            }
            ret.push_back(str);
        }
        return ret;
    }
};
```

{: file='Fizz Buzz.cpp'}
</div>
</details>

> ### [LeetCode 168: Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/)

26진법인데 1based라서 0based로 만들어주기 위해 매 번 1씩 빼줘야 했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string ret = "";
        while(columnNumber != 0){
            columnNumber--;
            ret = char(columnNumber % 26 + 'A') + ret;
            columnNumber /= 26;
        }      

        return ret;
    }
};
```

{: file='Excel Sheet Column Title.cpp'}
</div>
</details>

> ### [LeetCode 66: Plus One](https://leetcode.com/problems/plus-one/)

올림 구현하기. 배열로 주어지기 때문에 배열이 한 칸 커져야 할 때에 대한 처리가 필요했음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        bool plus = true;
        for (int i = digits.size() - 1; i >= 0; i--) {
            if (!plus)
                break;
            digits[i]++;
            plus = false;
            if (digits[i] == 10) {
                digits[i] = 0;
                plus = true;
            }
        }

        if(plus){
            digits.insert(digits.begin(), 1);
        }

        return digits;
    }
};
```

{: file='Plus One.cpp'}
</div>
</details>

> ### [LeetCode 283: Move Zeroes](https://leetcode.com/problems/move-zeroes/)

0을 가장 뒤로 보내는 문제

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        auto iter = remove(nums.begin(), nums.end(), 0);
        for(;iter != nums.end(); ++iter){
            *iter = 0;
        }
    }
};
```

{: file='Move Zeroes.cpp'}
</div>
</details>

> ### [LeetCode 1863: Sum of All Subset XOR Totals](https://leetcode.com/problems/sum-of-all-subset-xor-totals/)

서브셋들의 xor 합 구하기

<details>
<summary>내코드 - 서브셋을 만들고 xor을 해서 구한 합을 누적함</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int ret = 0;
    int N;
    void Recursive(int idx, int xorNum, vector<int>& nums){
        if(idx == N){
            ret += xorNum;
            return;
        }

        Recursive(idx+1, xorNum, nums);
        Recursive(idx + 1, xorNum ^ nums[idx], nums);
    }

    int subsetXORSum(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        N = nums.size();
        Recursive(0, 0, nums);
        return ret;
    }
};
```

{: file='XOR1.cpp'}
</div>
</details>

<details>
<summary>gpt - 비트단위 풀이</summary>
<div markdown="1">

- 한번이라도 1이 등장하는 비트는 정확히 모든 서브셋의 절반만큼 등장하게 됨
    - XOR로 1이 되려면 홀수 번 골라야 하는데, 최소 하나라도 있으면 정확히 반 반 갈림
- 따라서 모든 숫자를 or로 1이 있는 수를 구하고, pow(2, n-1) 곱

```cpp
class Solution {
public:
    int subsetXORSum(vector<int>& nums) {
        int all_or = 0;
        for (int x : nums) all_or |= x;

        int n = (int)nums.size();
        // 2^(n-1)
        int mul = 1 << (n - 1);
        return all_or * mul;
    }
};

```

{: file='XOR2.cpp'}
</div>
</details>

## Med

> ### [LeetCode 54: Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

소용돌이 움직임 구현

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    enum EDir{RIGHT, DOWN, LEFT, UP};
    int dr[4] = {0, 1, 0, -1};
    int dc[4] = {1, 0, -1, 0};
    int N, M;
    vector<vector<int>>visited;

    inline bool Boundary(int r, int c){
        return !(r < 0 || r >= N || c < 0 || c >= M);
    }

    inline bool IsValid(int r, int c){
        return Boundary(r, c) && !visited[r][c];
    }

    struct Pos{
        int r = 0, c = 0;
    };

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        N = matrix.size(), M = matrix[0].size();
        int cnt = N * M - 1;
        Pos cur = {0, 0};
        EDir dir = RIGHT;
        visited.resize(N, vector<int>(M));
        vector<int> ret;
        visited[0][0] = true;
        ret.push_back(matrix[0][0]);
        while(cnt != 0){
            int nr = cur.r + dr[dir];
            int nc = cur.c + dc[dir];
            
            if(!IsValid(nr, nc)){
                dir = EDir((dir + 1) % 4);
            }else{
                // cout << nr << ' ' << nc << '\n';
                visited[nr][nc] = true;
                cur = {nr, nc};
                cnt--;
                ret.push_back(matrix[nr][nc]);
            }
        }
        return ret;
    }
};
```

{: file='Spiral1.cpp'}
</div>
</details>

> ### [LeetCode 73: Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

0이 있는 부분을 봄버맨 폭탄 터지듯이 가로 세로로 전부 0을 만듬

아마도 0의 처리에 대한 순서 종속성을 제거하는 문제인듯

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int N, M;
    int nr[4] = {0, 1, 0, -1};
    int nc[4] = {1, 0, -1, 0};
    inline bool Boundary(int r, int c){
        return !(r < 0|| r >= N || c < 0 || c >= M);
    }

    struct Pos{
        int r = 0, c = 0;
    };

    void Bomb(Pos pos, vector<vector<int>>& matrix){
        for(int i = 0; i < N; i++){
            matrix[i][pos.c] = 0;
        }
        for(int i = 0; i < M; i++){
            matrix[pos.r][i] = 0;
        }
    }

    void setZeroes(vector<vector<int>>& matrix) {
        N = matrix.size(), M = matrix[0].size();
        vector<Pos> zeroPoses;
        for(int i = 0 ; i < N; i++){
            for(int j = 0 ; j < M; j++){
                if(matrix[i][j] == 0){
                    zeroPoses.push_back({i, j});
                }
            }
        }

        for(int i = 0; i < zeroPoses.size(); i++){
            Bomb(zeroPoses[i], matrix);
        }
    }
};
```

{: file='Matrix Zeroes.cpp'}
</div>
</details>

> ### [LeetCode 8: String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)

string과 int, int의 최대 최소값을 다루는 문제

이것저것 시키는게 많아서 까다로웠음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    string Whitespace(const string& str) {
        string ret = "";

        int idx = 0;
        for (; idx < str.size(); idx++) {
            if(str[idx] != ' ') break;
        }
        ret = string(str.begin() + idx, str.end());

        return ret;
    }

    bool Signedness(string& str) {
        bool plus = str[0] != '-';
        if (str[0] == '-' || str[0] == '+')
            str = string(str.begin() + 1, str.end());
        return plus;
    }

    string Conversion(const string&str){
        string ret = "";
        int stopIdx = 0;
        int startIdx = 0;
        for(; stopIdx < str.size(); stopIdx++){
            if(str[startIdx] == '0') startIdx++;
            if(str[stopIdx] < '0' || str[stopIdx] > '9') break;
        }
        ret = string(str.begin() + startIdx, str.begin() + stopIdx);
        if(ret.empty())
            ret = "0";

        return ret;
    }
    string intMaxStr = "";
    string minusMaxStr = "";
    int Rounding(bool plus, const string& str){
        // 2,100,000,000
        if(str.size()>10)return plus ? INT_MAX : -INT_MAX-1;
        if(str.size()< 10)return plus ? stoi(str) : -stoi(str);
        if(plus){
            return intMaxStr >= str ? stoi(str) : INT_MAX;
        }else{
            if(minusMaxStr > str){
                return -stoi(str);
            }
            return minusMaxStr > str ? -stoi(str) : -INT_MAX-1;
        }
    }

    int myAtoi(string s) {
        intMaxStr = to_string((int)(pow(2, 31)-1));
        minusMaxStr = to_string((long long)(pow(2, 31)));

        string noWhitespace = Whitespace(s);
        // cout << noWhitespace << '\n';
        bool plus = Signedness(noWhitespace);
        // cout << noWhitespace << '\n';
        string conversion = Conversion(noWhitespace);
        // cout << conversion << '\n';
        int rounding = Rounding(plus, conversion);
        // cout << rounding << '\n';
        // Signedness Conversion Rounding
        // cout << rounding << '\n';
        return rounding;
    }
};
```

{: file='AtoI.cpp'}
</div>
</details>

> ### [LeetCode 38: Count and Say](https://leetcode.com/problems/count-and-say/)

연속적인 수의 개수와 그 수로 만드는 문제

센티널 틱을 추가하면 처리가 편함

<details>
<summary>기존 풀이</summary>
<div markdown="1">

```cpp
class Solution {
public:
    string countAndSay(int n) {
        if (n == 1)
            return "1";

        string before = countAndSay(n - 1);
        string ret = "";

        int sequence = 0;
        int cur = 0;
        for (int i = 0; i < before.size(); i++) {
            if (cur != before[i]) {
                if (sequence > 0)
                    ret += to_string(sequence) + (char)cur;
                cur = before[i];
                sequence = 1;
            } else {
                sequence++;
            }
        }
        if (sequence > 0) {
            ret += to_string(sequence) + (char)cur;
        }

        return ret;
    }
};
```

{: file='Count and Say1.cpp'}
</div>
</details>

<details>
<summary>센티널 틱?</summary>
<div markdown="1">

```cpp
class Solution {
public:
    string countAndSay(int n) {
        if (n == 1)
            return "1";

        string before = countAndSay(n - 1);
        // 센티널 틱? 처리
        before +='#';
        string ret = "";

        int sequence = 0;
        int cur = 0;
        for (int i = 0; i < before.size(); i++) {
            if (cur != before[i]) {
                if (sequence > 0)
                    ret += to_string(sequence) + (char)cur;
                cur = before[i];
                sequence = 1;
            } else {
                sequence++;
            }
        }

        return ret;
    }
};
```

{: file='Count and Say2.cpp'}
</div>
</details>

> ### [LeetCode 289: Game of Life](https://leetcode.com/problems/game-of-life/)

시점 종속성 제거 문제

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    enum EDir { UP, UR, RIGHT, DR, DOWN, DL, LEFT, UL, END };
    int dr[EDir::END] = {-1, -1, 0, 1, 1, 1, 0, -1};
    int dc[EDir::END] = {0, 1, 1, 1, 0, -1, -1, -1};
    int N, M;
    inline bool Boundary(int r, int c) {
        return !(r < 0 || r >= N || c < 0 || c >= M);
    }

    int AroundNeighbors(int r, int c, vector<vector<int>>& board) {
        int ret = 0;
        for (int i = 0; i < EDir::END; i++) {
            int nr = r + dr[i];
            int nc = c + dc[i];
            if (!Boundary(nr, nc))
                continue;
            ret += (board[nr][nc] == 1);
        }
        return ret;
    }
    void gameOfLife(vector<vector<int>>& board) {
        N = board.size(), M = board[0].size();
        vector<vector<int>> nextboard(N, vector<int>(M));
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                int cnt = AroundNeighbors(i, j, board);
                if (board[i][j] == 1) {
                    if (cnt < 2) {
                        nextboard[i][j] = 0;
                    } else if (cnt == 2 || cnt == 3) {
                        nextboard[i][j] = 1;
                    } else {
                        nextboard[i][j] = 0;
                    }
                }else{
                    if(cnt == 3){
                        nextboard[i][j] = 1;
                    }
                }
            }
        }
        swap(nextboard, board);
    }
};
```

{: file='Game of Life.cpp'}
</div>
</details>

> ### [LeetCode 59: Spiral Matrix2](https://leetcode.com/problems/spiral-matrix-ii/)

LeetCode 54번 문제와 반대 논리 구현

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    enum EDir { RIGHT, DOWN, LEFT, UP };
    int dr[4] = {0, 1, 0, -1};
    int dc[4] = {1, 0, -1, 0};
    int N;
    vector<vector<int>> visited;

    inline bool Boundary(int r, int c) {
        return !(r < 0 || r >= N || c < 0 || c >= N);
    }
    inline bool IsValid(int r, int c) {
        return Boundary(r, c) && !visited[r][c];
    }
    struct Pos {
        int r = 0, c = 0;
    };

    vector<vector<int>> generateMatrix(int n) {
        N = n;
        vector<vector<int>> ret(N, vector<int>(N));
        visited.resize(N, vector<int>(N));

        int cnt = 0;
        Pos cur = {0, -1};
        EDir dir = RIGHT;
        while (cnt < n * n) {
            int nr = cur.r + dr[dir];
            int nc = cur.c + dc[dir];
            if (!IsValid(nr, nc)) {
                dir = (EDir)((dir + 1) % 4);
            } else {
                cnt++;
                ret[nr][nc] = cnt;
                visited[nr][nc] = true;
                cur = {nr, nc};
            }
        }
        return ret;
    }
};
```

{: file='Spiral Matrix2.cpp'}
</div>
</details>

> ### [LeetCode 43: Multiply Strings](https://leetcode.com/problems/multiply-strings/)

string과 9 이하의 수 곱셈을 구현하고, string과 string 덧셈을 구현해서 함

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    inline int ctoi(char ch) { return ch - '0'; }

    string multiply(const string& str, int num, int th) {
        string ret = "";
        int up = 0;
        for (int i = str.size() - 1; i >= 0; i--) {
            int n = ctoi(str[i]);
            n = n * num + up;
            up = n / 10;
            ret = to_string(n % 10) + ret;
        }
        // up 처리
        if (up > 0) {
            ret.insert(ret.begin(), up + '0');
        }

        for (int i = 0; i < th; i++) {
            ret += '0';
        }
        return ret;
    }

    string Add(string str1, string str2) {
        // str1이 큰걸로 기준
        if (str1.size() < str2.size())
            swap(str1, str2);
        int up = 0;
        string ret = "";
        for (int i = 0; i < str1.size(); i++) {
            int n1 = ctoi(str1[str1.size() - 1 - i]);
            int n2 = 0;
            if ((int)str2.size() - 1 - i >= 0){
                // cout << str2.size() - 1 - i << ' ';
                n2 = ctoi(str2[str2.size() - 1 - i]);
            }
            int n = n1 + n2 + up;
            up = n / 10;
            ret = to_string(n % 10) + ret;
        }
        if (up) {
            ret = to_string(1) + ret;
        }
        return ret;
    }

    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0")
            return "0";

        string ret = "0";
        for (int i = 0; i < num2.size(); i++) {
            string str = multiply(num1, ctoi(num2[num2.size() - 1 - i]), i);
            ret = Add(ret, str);
        }

        return ret;
    }
};
```

{: file='Multiply.cpp'}
</div>
</details>

> ### [LeetCode 6: Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/)

⬇️ ↗️ 방향으로 반복해서 글자 배치하는 문제

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    struct Pos {
        int r = 0, c = 0;
    };
    enum EDir {DOWN, UR, END};
    int dr[END] = {1, -1};
    int dc[END] = {0, 1};
    string convert(string s, int numRows) {
        if(numRows == 1)return s;
        // matrix를 만들어서 설계? -> x
        // pos를 설계
        Pos cur = {-1, 0};
        EDir dir =  DOWN;
        vector<Pos> path(s.size());
        int M = 0;
        for(int i = 0; i < s.size(); i++){
            Pos next = cur;
            next.r += dr[dir];
            next.c += dc[dir];
            M = next.c;
            if(next.r == 0) dir = DOWN;
            if(next.r == numRows-1) dir = UR;
            path[i] = next;
            cur = next;
        }

        vector<vector<char>>matrix(numRows, vector<char>(M+1));
        for(int i = 0 ; i < path.size(); i++){
            Pos pos = path[i];
            matrix[pos.r][pos.c] = s[i];
        }

        string ret = "";
        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0 ; j < matrix[0].size(); j++){
                if(matrix[i][j] != 0){
                    ret += matrix[i][j];
                }
            }
        }

        return ret;
    }
};
```

{: file='Zigzag.cpp'}
</div>
</details>

> ### [LeetCode 165: Compare Version Numbers](https://leetcode.com/problems/compare-version-numbers/)

string 다루기

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector<int> versions1, versions2;
        stringstream ss1(version1), ss2(version2);
        string token;
        while(getline(ss1, token, '.')){
            versions1.push_back(stoi(token));
        }
        while(getline(ss2, token, '.')){
            versions2.push_back(stoi(token));
        }

        for(int i = 0 ; i < versions1.size() && i < versions2.size(); i++){
            if(versions1[i] < versions2[i]) return -1;
            else if(versions1[i] > versions2[i]) return 1;
        }

        while(!versions1.empty() && versions1.back() == 0){
            versions1.pop_back();
        }
        while(!versions2.empty() && versions2.back() == 0){
            versions2.pop_back();
        }

        if(versions1.size() < versions2.size())
            return -1;
        else if(versions1.size() > versions2.size())
            return 1;
        return 0;
    }
};
```

{: file='Version.cpp'}
</div>
</details>

> ### [LeetCode 1706: Where Will the Ball Fall](https://leetcode.com/problems/where-will-the-ball-fall/)

빠칭코처럼 구슬 내려가는 문제

구슬이 해당 칸에 맞으면 다음 진행 될 칸을 생각해서 구현

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    int N, M;
    int dr[4] = {0, 1, 0, -1};
    int dc[4] = {1, 0, -1, 0};
    vector<vector<int>> m_grid;
    inline bool Boundary(int r, int c){
        return !(r < 0 || r >= N || c < 0 || c >= M);
    }

    inline bool CanFall(int r, int c){
        int nc = c;
        if(m_grid[r][c] == 1){
            nc++;
        }else{
            nc--;
        }
        return Boundary(r, nc) && m_grid[r][c] == m_grid[r][nc];
    }

    struct Pos{
        int r = 0, c = 0;
    };

    inline Pos Next(int r, int c){
        // cout << r << ' ' << c << ' ' << m_grid[r][c] << '\n';
        if(m_grid[r][c] == 1){
            c++;
        }else{
            c--;
        }
        r++;
        return {r, c};
    }

    vector<vector<int>> cache;

    int Fall(int r, int c){
        // cout << r << ' ' << c << '\n';
        int& ret = cache[r][c];
        if(ret != -2)return ret;

        if(r == N-1){
            if(CanFall(r, c)){
                auto pos = Next(r, c);
                return ret = pos.c;
            }else{
                return ret = -1;
            }
                
        }

        ret = -1;
        if(CanFall(r, c)){
        // cout << r << ' ' << c << '\n';
            auto next = Next(r, c);
            // cout << next.r << ' '<< next.c << '\n';
            ret = Fall(next.r, next.c);
        }

        return ret;
        
    }


    vector<int> findBall(vector<vector<int>>& grid) {
        // 떨어진 공은 같은행 다음 방향 열이 같은 방향이라면 다음 열, 다음 행으로 떨어질 수 있음
        // 같은 행 다음 방향 열이 바깥이거나, 나와 반대 방향이라면 그대로 갖힘
        // 빠르게 해야하니까 지나온 곳은 cahche 사용하기

        // 그럼 같은 행 다음 열이 나와 같은 방향인지 체크하는 함수
        // 다음 행 다음 열을 받아오는 함수
        
        N = grid.size(), M = grid[0].size();
        m_grid = grid;
        cache.resize(N, vector<int>(M, -2));

        vector<int> ret;
        for(int i = 0; i < M; i++){
            // Fall(0, i) ? ret.push_back(1) : ret.push_back(-1);
            ret.push_back(Fall(0, i));
        }

        return ret;
    }
};
```

{: file='Ball Fall.cpp'}
</div>
</details>

## Hard

> ### [LeetCode 68: Text Justification](https://leetcode.com/problems/text-justification/)

string 다루기

나눔 정렬과 왼쪽 정렬을 구현

나눔 정렬 구현에서 스페이스 개수 맞추기가 생각보다 까다로웠음

<details>
<summary>소스 코드</summary>
<div markdown="1">

```cpp
class Solution {
public:
    void PrintLines(const vector<vector<string>>& lines) {
        for (auto& vec : lines) {
            for (auto& str : vec) {
                cout << str << ' ';
            }
            cout << '\n';
        }
        cout << '\n';
    }

    int GetLen(const vector<string>& strings) {
        int ret = 0;
        for (const auto& str : strings)
            ret += str.size();
        return ret;
    }

    vector<string> PutSpace(const vector<vector<string>>& lines, int maxWidth) {
        vector<string> ret(lines.size(), string(maxWidth, ' '));

        // 확장 정렬
        for (int i = 0; i < lines.size()-1; i++) {
            int remain = maxWidth - GetLen(lines[i]);
            int offset = 0;
            for (int j = 0; j < lines[i].size(); j++) {
                const string& str = lines[i][j];
                // cout << offset << ' ';
                for (int k = 0; k < str.size(); k++) {
                    if(k + offset >= ret[i].size()){
                        // cout << '\n'<< i << ' ' << j << ' ' << str << ' ' << k << ' ' << offset << '\n';
                        continue;
                    }
                    ret[i][k + offset] = str[k];
                }
                offset += str.size();

                // 2 단어 이상만 계산
                int len = lines[i].size();
                if(len > 1){
                    offset += remain / (len-1);
                    int quot = remain % (len - 1);
                    if(quot != 0 && j < quot){
                        offset++;
                    }
                }
                // cout << offset << ' ';
            }
            // cout << '\n';
        }

        // 마지막 줄
            int offset = 0;
        for(int i = 0; i < lines.back().size(); i++){
            const string& str = lines.back()[i];
            for(int j = 0; j < str.size(); j++){
                ret.back()[j+offset] = str[j];
            }
            offset += str.size();
            offset++;
        }


        return ret;
    }

    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        // this is an example
        // 스페이스바는 앞에서부터 크게 채우는건가? => 3개 남았을 때 2칸 채워야
        // 하면 2, 1처럼 마지막 줄만 왼쪽 정렬
        int accSize = maxWidth + 1;
        vector<vector<string>> lines;
        for (int i = 0; i < words.size(); i++) {
            int nextAccSize = accSize + words[i].size() + 1;
            if (nextAccSize > maxWidth) {
                // 다음줄
                accSize = words[i].size();
                lines.push_back({});
            } else {
                // 현재 줄 추가
                accSize = nextAccSize;
            }
            lines.back().push_back(words[i]);
        }

        // space 집어넣기

        // PrintLines(lines);
        return PutSpace(lines, maxWidth);
    }
};
```

{: file='Justification.cpp'}
</div>
</details>