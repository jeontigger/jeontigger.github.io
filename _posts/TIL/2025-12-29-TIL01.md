---
title: 26년 1월 첫 째주 TIL
date: 2025-12-30 00:11:48 +09:00
categories: [TIL]
published: true
tags:
    [TIL, Unity]
---


# 1. copilot 추가 결제 - 그래서 에디터를 visual studio code로 변경

아마도 copilot의 premium request 다 쓰면 codex사용할듯

# 2. 유니티에서 해상도에 대응하는 UI pivot? anchor? 잡기에 어려움을 겪고 있음
 - 진영이 덕분에 해결함. Canvas의 Canvas Scaler 설정이 문제였음
![alt text](..\..\assets\img\2025-12-29-TIL\image.png)
- Canvas Scaler: Constant Pixel Size, Scale With Screen Size, Constant Physical Size가 있음

Constant Pixel Size가 디폴트인데, Scale With Screen Size로 변경하는 것이 해결 방법이었음

아마도 내가 원하는 건 다양한 해상도 대응이고, 디폴트는 고정된 애셋 크기가 더 중요하다고 생각해서 그런듯

Constant Pixel Size => UI를 픽셀 기준으로 고정시켜서 해상도가 커지거나 작아도 UI가 변하지 않음. 해상도가 통제되는 환경에서 추천

Scale With Screen Size => 내가 원하던 설정. 기준 해상도를 정하고, 실제 화면 크기에 맞게 비율로 스케일

Constant Physical Size => 실제 물리 크기를 기준으로 맞춤





# 3. Addressable 사용하게 됨

자세하게 뭘 하진 않았고

```csharp
Addressables.LoadAssetsAsync<Sprite>("Equipment_Icon", null);
await iconHandle.Task;
if (iconHandle.Status == AsyncOperationStatus.Succeeded){
    var icons = iconHandle.Result;
}
```

에디터에서 Addressable 체크해주고, Group과 Label을 설정해주면 해당 라벨로 불러오는 방식?으로 사용함

![alt text](..\..\assets\img\2025-12-29-TIL\image-1.png)



# 4. Dotween

Dotween이란? - 객체 움직임을 위한 api

크게 보면 Tween과 Sequence으로 나뉨

Tween은 움직임에 대한 객체, Sequence는 Tween을 관리하는 객체

```csharp
// Kill 사전 작업
tween.Kill();
transform.DOKill();

// 생성
// Transform 계열
transform.DOMove(Vector3 end, float duration);
transform.DOMoveX(float x, float duration);
transform.DOMoveY(float y, float duration);
transform.DOMoveZ(float z, float duration);

transform.DORotate(Vector3 end, float duration);
transform.DORotateQuaternion(Quaternion q, float duration);

transform.DOScale(Vector3 end, float duration);
transform.DOScale(float uniformScale, float duration);
transform.DOScaleX(float x, float duration);

// RectTransform 계열
rectTransform.DOAnchorPos(Vector2 end, float duration);
rectTransform.DOAnchorPosX(float x, float duration);
rectTransform.DOAnchorPosY(float y, float duration);

rectTransform.DOSizeDelta(Vector2 end, float duration);
rectTransform.DOPivot(Vector2 end, float duration);

// CanvasGroup
canvasGroup.DOFade(float endValue, float duration);

// Image / SpriteRenderer / Text / TMP
image.DOFade(float endValue, float duration);
image.DOColor(Color endValue, float duration);

spriteRenderer.DOFade(...)
spriteRenderer.DOColor(...);

tmpText.DOFade(...)
tmpText.DOColor(...)

// Camera / Light / 기타 컴포넌트
camera.DOFieldOfView(float end, float duration);
camera.DOOrthoSize(float end, float duration);

light.DOIntensity(float end, float duration);
light.DOColor(Color end, float duration);

// 값(Value) 트윈 – DOTween.To 계열
DOTween.To(() => floatVal, x => floatVal = x, 10f, 1f);
DOTween.To(() => intVal,   x => intVal = x,   10,  1f);
DOTween.To(() => vector3,  x => vector3 = x,  Vector3.one, 1f);
DOTween.To(() => color,    x => color = x,    Color.red, 1f);


// 제어
tween.Pause();
tween.Play();
tween.Restart();
// 상태 확인
tween.IsActive();
tween.IsPlaying();
tween.IsComplete();

// 콜백
.OnStart(() => {});
.OnUpdate(() => {});
.OnComplete(() => {});
.OnKill(() => {});

// 옵션
.SetEase(Ease.OutQuad);
.SetEase(Ease.OutBack);
.SetUpdate(true); // Unscaled Time
.SetDelay(0.1f);
.SetLoops(3);
.SetLoops(-1, LoopType.Yoyo);
```


```csharp
// 생성
Sequence seq = DOTween.Sequence();

// 추가. 앞의 Tween이 끝난 후 실행
seq.Append(transform.DOMoveX(5, 0.5f));
// 동시. 현재 Append Tween과 동시 실행
seq.Join(transform.DOScale(1.2f, 0.5f));
// 삽입. 타미라인의 절대 시간 기준
seq.Insert(0.2f, transform.DORotate(Vector3.zero, 0.3f));
// 맨 앞에 추가
seq.Prepend(canvasGroup.DOFade(1, 0.2f));

// 시간제어
// 잠깐 대기
seq.AppendInterval(0.15f);
// 지연
seq.SetDelay(0.1f);

// 콜백
seq.AppendCallback(() => Debug.Log("중간"));
seq.OnComplete(() => Debug.Log("끝"));

// 옵션 설정
seq.SetEase(Ease.OutQuad) // 전체 타임라인 가속 곡선?
   .SetLoops(2, LoopType.Yoyo)
   .SetUpdate(true) // true: Unscaled Time, false: scaled Time
   .SetAutoKill(true)
   .SetId("UI")
   .SetTarget(gameObject);

// 제어
seq.Play();
seq.Pause();
seq.Restart();
seq.Rewind();
seq.Kill();

```