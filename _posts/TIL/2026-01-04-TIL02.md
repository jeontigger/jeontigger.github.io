---
title: 26년 1월 2째주 TIL
date: 2026-01-04 22:15:27 +09:00
categories: [TIL]
published: true
tags:
    [TIL, Unity]
---

# 1. Test Runner 사용 -> 안함

Window->General->TestRunner

Editmode와 Playmode에서 단위테스트? 등을 시험해볼 수 있음

사용하려고 하다가, 특정 폴더 경로가 기본으로 되어있고, 폴더 경로를 변경하려고 하니 어려움을 겪다가 그냥 debug.log 테스트 방식으로 회귀함

# 2. google sheet 읽어옴

구글시트 URL을 CSV export용 URL이 존재

/// 예: https://docs.google.com/spreadsheets/d/{SHEET_ID}/edit#gid={GID}

/// → https://docs.google.com/spreadsheets/d/{SHEET_ID}/export?format=csv&gid={GID}

```csharp
/// <summary>
/// CSV URL에서 데이터를 다운로드하고 파싱합니다
/// </summary>
public static IEnumerator LoadFromCsvUrl(string csvUrl, Action<SheetData> onSuccess, Action<string> onError = null)
{
    using (UnityWebRequest request = UnityWebRequest.Get(csvUrl))
    {
        yield return request.SendWebRequest();

        if (request.result == UnityWebRequest.Result.Success)
        {
            string csvText = request.downloadHandler.text;
            SheetData data = ParseCsv(csvText);
            onSuccess?.Invoke(data);
        }
        else
        {
            string error = $"구글시트 다운로드 실패: {request.error}";
            Debug.LogError(error);
            onError?.Invoke(error);
        }
    }
}
```
{: file='LoadFromCsvUrl.cs'}

# 3. Task

Task란? 비동기 실행 단위

`Task<T>`는 결과가 있음

`await`을 하면 해당 라인의 함수의 작업이 끝날 때 까지 현재 함수를 일시 중단함
```csharp
async Task<int> LoadDataAsync()
{
    await Task.Delay(1000);
    return 42;
}

async void Func()
{
    // gold = 42
    int gold = await LoadDataAsync();
}
```
메인스레드를 막지 않는 다는 것이 가장 중요

Coroutine보다는 반환값을 전달하는 것이 쉬움

```csharp
// Task<int> 반환 함수라고 할 때
// item1은 int형, item2는 Task<int>형이 됨
var item1 = await CResourceManager.Instance.LoadSpriteByLabelAndNameAsync("Equipment_Icon", "belt_common_gear");
var item2 = CResourceManager.Instance.LoadSpriteByLabelAndNameAsync("Equipment_Icon", "belt_common_gear");
```

`await`가 `Task<T>`의 `T`를 꺼내주는 키워드

그래서
```csharp
// item3는 int형
var item3 = await item2
```
이 된다

`task.Wait()`은 동기 블로킹이 됨.
이걸로 task가 완료될 때 까지 기다렸는데 무한루프에 빠져서 유니티 엔진이 멈춤.
유니티 엔진이 무한루프에 빠지면 강종밖에 답이 없나...(좋은거 있으면 공유좀).

왜 무한루프에 빠지게 되냐면
`Wait()`을 호출한 스레드가 메인 스레드이고, 블로킹이 되기 때문에 **메인 스레드가 더이상 진행되지 않음**. task로 받아둔 함수가 실행되지 못해서 비동기 함수를 실행할 수 없고, 비동기 함수의 끝을 기다리는 메인 스레드는 무한루프에 빠지게 되는 것.

> 결론) 무조건 `await`로 기다려야 함
{: .prompt-info }

# 4. Addressable

```csharp
// 알고보니 2가지 API로 로드 가능
Addressables.LoadAssetAsync<T>(address);
Addressables.LoadAssetsAsync<T>(label);
```
꼭 라벨을 붙여야만 하는 것이 아니라 경로만 입력해도 됐었음. 근데 Load한 만큼 Release를 해주어야 메모리에서 해제된다고 함. 이게 내부적으로 Load를 매번 하는게 아니라 카운트를 센다고 하는데, `shared_ptr`처럼 0이 되어야 해제 되는 방식. 그래서 Load해서 관리하는 객체가 있다면 Release를 소멸자에서 해주어야 Addressable을 사용하는 동적 메모리 관리가 유효하게 이루어지는 것으로 예상.





# 5. Input System vs Input Manager

InputManager가 구버전, InputSystem 신버전

Edit → Project Settings → Player → Other Settings → Active Input Handling에서 선택할 수 있음(Both도 가능)

```csharp
Input.GetKeyDown(A);
```
{: file='Input Manager.cs'}


```csharp
public void OnMove(InputAction.CallbackContext context)
{
    moveInput = context.ReadValue<Vector2>();
}

public void OnJump(InputAction.CallbackContext context)
{
    if (context.performed)
    {
        rb.AddForce(Vector3.up * 5f, ForceMode.Impulse);
    }
}

// 정말 잠깐 쓸 때에는 아래처럼. 왜냐면 설계 철학 위반
if (Keyboard.current.spaceKey.wasPressedThisFrame)
{
    Debug.Log("Space");
}
```
{: file='Input System.cs'}
![alt text](..\..\assets\img\2026-01-04-TIL\image.png)

마치 언리얼의 InputSystem을 이용하는 것 같음


# 6. Initializer async 문제

```csharp
protected override async void Awake()
{
    base.Awake();

    await CAssetMapper.InitializeAsync();
    CSystem1.Initialize();
    CSystem2.Initialize();
}
```
{: file='문제 코드.cs'}

위에서 await로 비동기 호출을 하니까 아래쪽의 initialize가 호출되지 않고, 메인 스레드의 틱이 넘어가서 의도했던 System들의 init이 이루어지지 않고 메인 스레드의 Start 시점이 호출됨. `Start()`에서 System의 데이터를 참조하려고 하니 값이 안들어있던 문제 발생

```csharp
protected override async void Awake()
{
    base.Awake();

    CSystem1.Initialize();
    CSystem2.Initialize();
    await CAssetMapper.InitializeAsync();
}
```
{: file='해결 코드.cs'}

await 용 init을 마지막으로 전환.

이게 결국 AssetMapper도 다른클래스에서 Start시점에 호출하게되면 문제가 발생할 여지가 많음. 모든 public함수에서 initial 체크 후 대기를 할 수도 있겠지만, 애초에 시점 제어가 필요할 듯 함


```csharp
public class Bootstrapper : MonoBehaviour
{
    async void Awake()
    {
        DontDestroyOnLoad(gameObject);

        CSystem1.Initialize();
        CSystem2.Initialize();
        await CAssetMapper.InitializeAsync();

        // 여기서 메인 씬 로드 or 게임 시작 이벤트 발행
        UnityEngine.SceneManagement.SceneManager.LoadScene("Main");
    }
}
```
{: file='gpt 추천1 부트스트랩.cs'}

씬에 부트스트래퍼 하나를 두고, 모든 시스템 초기화를 완료하면 메인 씬을 시작하도록 함

```csharp
public static class CAssetMapper
{
    static readonly System.Threading.Tasks.TaskCompletionSource<bool> _readyTcs =
        new(System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously);

    public static System.Threading.Tasks.Task WhenReady() => _readyTcs.Task;

    public static async System.Threading.Tasks.Task InitializeAsync()
    {
        // 이미 완료됐으면 재진입 방지
        if (_readyTcs.Task.IsCompleted) return;

        try
        {
            // 실제 초기화
            await LoadTablesAsync();
            _readyTcs.TrySetResult(true);
        }
        catch (System.Exception e)
        {
            _readyTcs.TrySetException(e);
            throw;
        }
    }

    static System.Threading.Tasks.Task LoadTablesAsync()
    {
        // TODO: addressables 로드 등
        return System.Threading.Tasks.Task.CompletedTask;
    }
}

// 호출 코드
async void Start()
{
    await CAssetMapper.WhenReady();
    var x = CAssetMapper.Get(...);
}

```
{: file='gpt 추천2 호출부도 async.cs'}

사용하려는 클래스에서도 사용할 수 있을 때 까지 기다리는 패턴

일단 1번이 더 좋아보이긴 함

