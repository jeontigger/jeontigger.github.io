# 🧠 Vertex Shader / Fragment Shader 역할 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. Vertex Shader란 무엇인가요?

    - 정점 정보를 가지고 가공하는 단계입니다. 주로 모델의 정점 정보를 모델->월드->뷰->투영 순서로 변환합니다.

2. Fragment Shader란 무엇인가요?

    - 그려질 픽셀 후보들이 가공되는 단계입니다. 주로 해당 픽셀의 색상을 샘플링하고 조명을 계산합니다.

## ✅ 실행 단위 차이 (핵심)

1. Vertex Shader는 어떤 단위로 실행되나요?

    - 정점 단위로 실행됩니다.

2. Fragment Shader는 어떤 단위로 실행되나요?

    - 픽셀 단위로 실행됩니다.

## ✅ 입력 / 출력

1. Vertex Shader의 입력과 출력은 무엇인가요?

    - 입력은 모델의 정점 정보이고, 출력은 행렬가공된 모델의 정점입니다.

2. Fragment Shader의 입력과 출력은 무엇인가요?

    - 그려질 후보 픽셀들이 입력이고, 해당 픽셀들의 색상, z값 등의 가공된 정보를 가진 픽셀이 출력입니다.

## ✅ 주요 역할

1. Vertex Shader의 핵심 역할은 무엇인가요?

    - 정점들을 가공하는 것입니다.

2. Fragment Shader의 핵심 역할은 무엇인가요?

    - 픽셀 후보군들을 가공하는 것입니다.

## ✅ 연산 제약

1. Vertex Shader에서 텍스처 샘플링은 가능한가요?

    - 불가능합니다.

2. Fragment Shader에서 조명 계산을 하는 이유는 무엇인가요?

    - 픽셀마다 조명의 각도 및 세기가 다르기 때문입니다.

## ✅ 성능 관점

1. 어떤 셰이더가 더 많이 실행되나요?

    - Fragment Shader가 많이 실행됩니다. 픽셀 단위의 실행이기 때문입니다.

2. 어떤 셰이더가 성능 병목이 되기 쉬운가요?

    - Fragment Shader가 성능 병목이 되기 쉽습니다. 픽셀마다 실행해야 하기 때문입니다.

## ✅ 파이프라인 연계

1. Vertex Shader 출력 값은 어떻게 Fragment Shader로 전달되나요?

    - Rasteraizer 단계를 거치고 Fragment Sahder에게 그려질 후보군만 전달됩니다.

2. 보간(interpolation)은 어느 단계에서 일어나나요?

    - Rasteraizer 단계에서 발생합니다.

## ✅ 실무 판단

1. 월드 변환과 투영 변환은 어디서 처리하는 것이 적절한가요?

    - 주로 Vertex Shader에서 처리하는 것이 적절합니다.

2. 색상 계산을 Vertex Shader에서 하면 안 되는 이유는 무엇인가요?

    - 색상 계산을 정점셰이더에서 하면 한 면의 색감이 다양해질 수 없습니다.

## ✅ 요약 질문

1. Vertex Shader와 Fragment Shader의 역할을 한 문장으로 요약해보세요.

    - 정점 정보를 가공하는 것과 픽셀 정보를 가공하는 것입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

### ✅ 기본 개념

1. 정점 단위로 실행되어 위치를 변환하는 셰이더입니다.
2. 픽셀 단위로 실행되어 최종 색상을 계산하는 셰이더입니다.

### ✅ 실행 단위 차이 (핵심)

3. 정점(vertex) 단위입니다.
4. 픽셀(fragment) 단위입니다.

### ✅ 입력 / 출력

5. 입력은 정점 속성, 출력은 변환된 위치와 보간 값입니다.
6. 입력은 보간된 값, 출력은 픽셀 색상입니다.

### ✅ 주요 역할

7. 좌표계 변환과 정점 데이터 가공입니다.
8. 색상, 조명, 텍스처 계산입니다.

### ✅ 연산 제약

9. 가능하지만 비용이 커서 권장되지 않습니다.
10. 픽셀마다 조명이 달라지기 때문입니다.

### ✅ 성능 관점

11. Fragment Shader입니다.
12. Fragment Shader입니다.

### ✅ 파이프라인 연계

13. 래스터화 단계에서 보간되어 전달됩니다.
14. 래스터화 단계입니다.

### ✅ 실무 판단

15. Vertex Shader입니다.
16. 픽셀 단위 디테일이 손실되기 때문입니다.

17. Vertex는 “위치”, Fragment는 “색”을 결정합니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: Vertex Shader란 무엇인가요?**
- **현재 답변**: "정점 정보를 가지고 가공하는 단계입니다. 주로 모델의 정점 정보를 모델->월드->뷰->투영 순서로 변환합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하고 정확한 표현이 있습니다
  - ✅ **정확한 답변**: "정점 단위로 실행되어 위치를 변환하는 셰이더입니다"
  - 정점 정보를 가공하는 것보다는 "위치를 변환"하는 것이 핵심 역할입니다

**질문 2: Fragment Shader란 무엇인가요?**
- **현재 답변**: "그려질 픽셀 후보들이 가공되는 단계입니다. 주로 해당 픽셀의 색상을 샘플링하고 조명을 계산합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하게 표현할 수 있습니다
  - ✅ **정확한 답변**: "픽셀 단위로 실행되어 최종 색상을 계산하는 셰이더입니다"
  - "픽셀 후보"보다는 "fragment"가 더 정확한 용어이지만, 픽셀 단위로 실행된다는 표현이 핵심입니다

### ✅ 실행 단위 차이 (핵심)

**질문 1: Vertex Shader는 어떤 단위로 실행되나요?**
- **현재 답변**: "정점 단위로 실행됩니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "정점(vertex) 단위입니다"
  - 각 정점마다 독립적으로 실행되며, 정점 간 통신은 불가능합니다

**질문 2: Fragment Shader는 어떤 단위로 실행되나요?**
- **현재 답변**: "픽셀 단위로 실행됩니다."
- **피드백**:
  - ⚠️ **부정확**: "픽셀"보다는 "fragment"가 더 정확한 용어입니다
  - ✅ **정확한 답변**: "픽셀(fragment) 단위입니다"
  - Rasterization의 결과인 fragment 단위로 실행되며, Depth Test를 거쳐 최종 픽셀이 결정됩니다

### ✅ 입력 / 출력

**질문 1: Vertex Shader의 입력과 출력은 무엇인가요?**
- **현재 답변**: "입력은 모델의 정점 정보이고, 출력은 행렬가공된 모델의 정점입니다."
- **피드백**:
  - ⚠️ **부정확**: 출력에 대한 설명이 부족합니다
  - ✅ **정확한 답변**: "입력은 정점 속성, 출력은 변환된 위치와 보간 값입니다"
  - 입력은 정점 속성(위치, 노멀, UV 등), 출력은 클립 공간 좌표와 보간될 속성들입니다

**질문 2: Fragment Shader의 입력과 출력은 무엇인가요?**
- **현재 답변**: "그려질 후보 픽셀들이 입력이고, 해당 픽셀들의 색상, z값 등의 가공된 정보를 가진 픽셀이 출력입니다."
- **피드백**:
  - ⚠️ **부정확**: 입력과 출력에 대한 설명이 부정확합니다
  - ✅ **정확한 답변**: "입력은 보간된 값, 출력은 픽셀 색상입니다"
  - 입력은 Vertex Shader에서 보간된 속성 값들(위치, 노멀, UV 등), 출력은 최종 픽셀 색상입니다
  - z값은 Fragment Shader의 출력이 아니라 Depth Test에서 사용됩니다

### ✅ 주요 역할

**질문 1: Vertex Shader의 핵심 역할은 무엇인가요?**
- **현재 답변**: "정점들을 가공하는 것입니다."
- **피드백**:
  - ⚠️ **부정확**: "가공"이라는 표현이 너무 일반적입니다
  - ✅ **정확한 답변**: "좌표계 변환과 정점 데이터 가공입니다"
  - 모델 공간 → 월드 공간 → 뷰 공간 → 클립 공간으로의 좌표계 변환이 핵심입니다

**질문 2: Fragment Shader의 핵심 역할은 무엇인가요?**
- **현재 답변**: "픽셀 후보군들을 가공하는 것입니다."
- **피드백**:
  - ⚠️ **부정확**: "가공"이라는 표현이 너무 일반적입니다
  - ✅ **정확한 답변**: "색상, 조명, 텍스처 계산입니다"
  - 각 fragment의 최종 색상을 계산하는 것이 핵심이며, 조명, 텍스처, 머티리얼 등을 고려합니다

### ✅ 연산 제약

**질문 1: Vertex Shader에서 텍스처 샘플링은 가능한가요?**
- **현재 답변**: "불가능합니다."
- **피드백**:
  - ⚠️ **부정확**: 기술적으로는 가능하지만 권장되지 않습니다
  - ✅ **정확한 답변**: "가능하지만 비용이 커서 권장되지 않습니다"
  - 일부 GPU에서는 Vertex Shader에서 텍스처 샘플링이 가능하지만, 성능 비용이 크고 Fragment Shader에서 하는 것이 효율적입니다

**질문 2: Fragment Shader에서 조명 계산을 하는 이유는 무엇인가요?**
- **현재 답변**: "픽셀마다 조명의 각도 및 세기가 다르기 때문입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "픽셀마다 조명이 달라지기 때문입니다"
  - 각 픽셀의 위치, 노멀, 시선 방향 등이 다르므로 픽셀 단위로 조명을 계산해야 정확한 결과를 얻을 수 있습니다

### ✅ 성능 관점

**질문 1: 어떤 셰이더가 더 많이 실행되나요?**
- **현재 답변**: "Fragment Shader가 많이 실행됩니다. 픽셀 단위의 실행이기 때문입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "Fragment Shader입니다"
  - 일반적으로 정점 수보다 픽셀 수가 훨씬 많기 때문에 Fragment Shader가 더 많이 실행됩니다

**질문 2: 어떤 셰이더가 성능 병목이 되기 쉬운가요?**
- **현재 답변**: "Fragment Shader가 성능 병목이 되기 쉽습니다. 픽셀마다 실행해야 하기 때문입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "Fragment Shader입니다"
  - Fragment Shader는 실행 횟수가 많고, 복잡한 계산(조명, 텍스처 샘플링 등)을 수행하므로 병목이 되기 쉽습니다

### ✅ 파이프라인 연계

**질문 1: Vertex Shader 출력 값은 어떻게 Fragment Shader로 전달되나요?**
- **현재 답변**: "Rasteraizer 단계를 거치고 Fragment Sahder에게 그려질 후보군만 전달됩니다."
- **피드백**:
  - ⚠️ **오타**: "Rasteraizer" → "Rasterizer", "Sahder" → "Shader"
  - ⚠️ **부정확**: 보간(interpolation) 과정이 누락되었습니다
  - ✅ **정확한 답변**: "래스터화 단계에서 보간되어 전달됩니다"
  - Vertex Shader의 출력 값들이 Rasterization 단계에서 보간되어 Fragment Shader로 전달됩니다

**질문 2: 보간(interpolation)은 어느 단계에서 일어나나요?**
- **현재 답변**: "Rasteraizer 단계에서 발생합니다."
- **피드백**:
  - ⚠️ **오타**: "Rasteraizer" → "Rasterizer"
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "래스터화 단계입니다"
  - Rasterization 단계에서 정점 속성들이 fragment 위치에 따라 보간됩니다

### ✅ 실무 판단

**질문 1: 월드 변환과 투영 변환은 어디서 처리하는 것이 적절한가요?**
- **현재 답변**: "주로 Vertex Shader에서 처리하는 것이 적절합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "Vertex Shader입니다"
  - 정점 단위로 변환하는 것이 효율적이며, Fragment Shader에서 하면 불필요한 중복 계산이 발생합니다

**질문 2: 색상 계산을 Vertex Shader에서 하면 안 되는 이유는 무엇인가요?**
- **현재 답변**: "색상 계산을 정점셰이더에서 하면 한 면의 색감이 다양해질 수 없습니다."
- **피드백**:
  - ⚠️ **부정확**: "한 면의 색감이 다양해질 수 없습니다"보다는 "픽셀 단위 디테일이 손실"이 더 정확한 표현입니다
  - ✅ **정확한 답변**: "픽셀 단위 디테일이 손실되기 때문입니다"
  - 정점 단위로 색상을 계산하면 삼각형 내부의 픽셀들은 보간된 색상을 사용하게 되어, 픽셀 단위의 디테일(텍스처, 조명 등)이 손실됩니다

### ✅ 요약 질문

**질문 1: Vertex Shader와 Fragment Shader의 역할을 한 문장으로 요약해보세요.**
- **현재 답변**: "정점 정보를 가공하는 것과 픽셀 정보를 가공하는 것입니다."
- **피드백**:
  - ⚠️ **부정확**: "가공"이라는 표현이 너무 일반적입니다
  - ✅ **정확한 답변**: "Vertex는 '위치', Fragment는 '색'을 결정합니다"
  - Vertex Shader는 정점의 위치를 변환하고, Fragment Shader는 픽셀의 색상을 계산합니다

### 📊 전체 평가

**강점:**
- ✅ Vertex Shader와 Fragment Shader의 기본 개념을 이해함
- ✅ 실행 단위 차이(정점 vs 픽셀)를 정확히 알고 있음
- ✅ Fragment Shader가 더 많이 실행되고 성능 병목이 되기 쉬운 이유를 이해함
- ✅ 보간이 Rasterization 단계에서 일어난다는 것을 이해함

**개선 필요:**
- ⚠️ **부정확**: Fragment Shader 실행 단위 표현 ("픽셀" → "fragment")
- ⚠️ **부정확**: Vertex Shader와 Fragment Shader의 입력/출력 설명이 부족
- ⚠️ **부정확**: 주요 역할 설명이 너무 일반적 ("가공" → 구체적 설명)
- ⚠️ **부정확**: Vertex Shader에서 텍스처 샘플링 가능 여부 (불가능 → 가능하지만 권장 안 함)
- ⚠️ **부정확**: 색상 계산을 Vertex Shader에서 하면 안 되는 이유 설명
- ⚠️ **부정확**: 요약 질문 답변이 너무 일반적
- ⚠️ **오타**: "Rasteraizer" → "Rasterizer", "Sahder" → "Shader"

**우선순위:**
1. **높음**: 
   - Fragment Shader 실행 단위 정확화 (fragment)
   - Vertex Shader와 Fragment Shader의 입력/출력 정확화
   - Vertex Shader에서 텍스처 샘플링 가능 여부 정정
2. **중간**: 
   - 주요 역할 설명 구체화
   - 색상 계산을 Vertex Shader에서 하면 안 되는 이유 정확화
   - 요약 질문 답변 개선
3. **낮음**: 
   - 오타 수정

**특별 주의사항:**
- **Fragment vs Pixel**: Fragment Shader는 fragment 단위로 실행되며, fragment는 Rasterization의 결과입니다. Depth Test를 거쳐 최종 픽셀이 결정됩니다.
- **입력/출력**: Vertex Shader의 출력은 클립 공간 좌표와 보간될 속성들이며, Fragment Shader의 입력은 보간된 속성 값들입니다. Fragment Shader의 출력은 픽셀 색상이며, z값은 별도로 처리됩니다.
- **텍스처 샘플링**: Vertex Shader에서 텍스처 샘플링은 기술적으로 가능하지만 비용이 크므로 권장되지 않습니다. Fragment Shader에서 하는 것이 효율적입니다.
- **색상 계산 위치**: 색상 계산을 Vertex Shader에서 하면 픽셀 단위 디테일이 손실됩니다. Fragment Shader에서 계산해야 텍스처, 조명 등의 디테일을 정확히 표현할 수 있습니다.


