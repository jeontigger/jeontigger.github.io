# 🧠 Draw Call 개념 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. Draw Call이란 무엇인가요?

    - GPU가 렌더타겟에 그리도록 명령하는 함수입니다.

2. Draw Call은 누가 호출하나요? (CPU/GPU 관점)

    - CPU가 호출합니다.

## ✅ 비용 발생 이유 (핵심)

1. Draw Call이 비싼 이유는 무엇인가요?

    - CPU->GPU로 정보 전달 비용이 비쌉니다.

2. Draw Call 비용은 GPU 연산인가요, CPU 연산인가요?

    - GPU 연산입니다.

## ✅ 상태 변경(State Change)

1. Draw Call과 렌더 상태 변경의 관계는 무엇인가요?

    - Draw Call을 호출하기 전 해당 물체를 어떻게 그릴지에 대한 Shader 상태를 변경하여 세팅 후 Draw Call 해야합니다.

2. 머티리얼(Material)이 Draw Call 수에 영향을 주는 이유는 무엇인가요?

    - 같은 머터리얼을 사용하면 인스턴싱으로 Draw call을 줄일수 있고, 머터리얼이 다르면 GPU로 전달되어야 하는 값을 다시 세팅하고 Draw Call을 호출해야하기 때문에 영향을 줍니다.

## ✅ 배치 / 정렬

1. 동일한 메쉬라도 Draw Call이 나뉘는 경우는 언제인가요?

    - 머터리얼이 달라질 때 Draw Call이 나눠집니다.

2. 렌더 순서 정렬이 Draw Call에 영향을 주는 이유는 무엇인가요?

    - 카메라에 안보이는 물체는 Draw Call을 호출할 필요가 없기 때문입니다.

## ✅ 성능 병목 관점

1. Draw Call 병목은 어떤 상황에서 발생하나요?

    - Draw Call이 많아지면 발생합니다.

2. Draw Call 병목과 Fill Rate 병목의 차이는 무엇인가요?

    - 

## ✅ 감소 기법 (중요)

1. Draw Call을 줄이는 대표적인 방법에는 무엇이 있나요?

    - 배칭과 인스턴싱이 존재합니다.

2. Batching이란 무엇인가요?

    - 

3. Instancing이란 무엇인가요?

    - 같은 매쉬와 머터리얼을 사용하는 객체를 한 번의 드로우콜로 위치좌표를 배열로 받아 한꺼번에 계산하는 기법입니다.

## ✅ 엔진 / 실무 관점

1. 게임 엔진에서 Draw Call 수를 확인하는 방법은 무엇인가요?

    - Draw Call의 호출부에 카운트를 셉니다.

2. Draw Call은 무조건 줄일수록 좋은가요?

    - 의도한대로 이뤄진다면 줄일수록 좋습니다.

## ✅ 요약 질문

1. Draw Call 개념을 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

1. CPU가 GPU에게 “이것을 그려라”고 요청하는 명령입니다.
2. CPU가 호출하고 GPU가 실행합니다.

3. CPU → GPU 명령 전달과 상태 설정 비용 때문입니다.
4. 주로 CPU 비용입니다.

5. 상태가 바뀌면 새로운 Draw Call이 필요합니다.
6. 머티리얼이 다르면 상태가 달라지기 때문입니다.

7. 머티리얼, 셰이더, 파이프라인 상태가 다를 때입니다.
8. 같은 상태끼리 묶지 않으면 Call이 분리됩니다.

9. 객체 수가 많고 CPU가 느릴 때입니다.
10. Draw Call은 CPU 병목, Fill Rate는 GPU 픽셀 병목입니다.

11. Batching, Instancing, 상태 정렬입니다.
12. 여러 메쉬를 하나로 묶어 그리는 기법입니다.
13. 동일 메쉬를 한 번의 호출로 여러 개 그리는 기법입니다.

14. 엔진 프로파일러나 렌더 디버거입니다.
15. 아닙니다, 과도한 배치는 오히려 GPU 부담이 될 수 있습니다.

16. Draw Call은 “CPU가 GPU에게 보내는 그리기 요청”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: Draw Call이란 무엇인가요?**
- **현재 답변**: "GPU가 렌더타겟에 그리도록 명령하는 함수입니다."
- **피드백**:
  - ❌ **오개념**: Draw Call은 GPU가 명령하는 것이 아닙니다
  - ✅ **정확한 답변**: "CPU가 GPU에게 '이것을 그려라'고 요청하는 명령입니다"
  - Draw Call은 CPU가 GPU에게 렌더링을 요청하는 명령입니다. GPU는 명령을 받아 실행하는 역할입니다.

### ✅ 비용 발생 이유 (핵심)

**질문 2: Draw Call 비용은 GPU 연산인가요, CPU 연산인가요?**
- **현재 답변**: "GPU 연산입니다."
- **피드백**:
  - ❌ **오개념**: Draw Call 비용은 CPU 비용입니다
  - ✅ **정확한 답변**: "주로 CPU 비용입니다"
  - Draw Call 비용은 CPU → GPU 명령 전달과 상태 설정에 드는 CPU 비용입니다. GPU는 명령을 받아 실행하는 것이므로 비용의 주체는 CPU입니다.

### ✅ 상태 변경(State Change)

**질문 1: Draw Call과 렌더 상태 변경의 관계는 무엇인가요?**
- **현재 답변**: "Draw Call을 호출하기 전 해당 물체를 어떻게 그릴지에 대한 Shader 상태를 변경하여 세팅 후 Draw Call 해야합니다."
- **피드백**:
  - 💡 **보완**: "상태가 바뀌면 새로운 Draw Call이 필요합니다"
  - 현재 답변은 맞지만, 핵심은 "상태 변경 → 새 Draw Call 필요"라는 관계입니다. 상태 변경과 Draw Call의 관계를 더 명확히 설명하면 좋습니다.

### ✅ 배치 / 정렬

**질문 1: 동일한 메쉬라도 Draw Call이 나뉘는 경우는 언제인가요?**
- **현재 답변**: "머터리얼이 달라질 때 Draw Call이 나눠집니다."
- **피드백**:
  - 💡 **보완**: "머티리얼, 셰이더, 파이프라인 상태가 다를 때입니다"
  - 머티리얼만이 아닌 셰이더, 파이프라인 상태 등도 Draw Call을 나누는 원인이 됩니다.

**질문 2: 렌더 순서 정렬이 Draw Call에 영향을 주는 이유는 무엇인가요?**
- **현재 답변**: "카메라에 안보이는 물체는 Draw Call을 호출할 필요가 없기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 렌더 순서 정렬과 가시성(카메라에 안보이는 것)은 다른 개념입니다
  - ✅ **정확한 답변**: "같은 상태끼리 묶지 않으면 Call이 분리됩니다"
  - 렌더 순서 정렬은 같은 상태(머티리얼, 셰이더 등)를 가진 물체들을 묶어 Draw Call을 줄이기 위한 것입니다. 가시성 제거는 별개의 최적화입니다.

### ✅ 성능 병목 관점

**질문 1: Draw Call 병목은 어떤 상황에서 발생하나요?**
- **현재 답변**: "Draw Call이 많아지면 발생합니다."
- **피드백**:
  - 💡 **보완**: "객체 수가 많고 CPU가 느릴 때입니다"
  - 현재 답변은 결과론적입니다. 병목이 발생하는 조건(객체 수, CPU 성능)을 명시하면 더 좋습니다.

**질문 2: Draw Call 병목과 Fill Rate 병목의 차이는 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: 성능 분석에서 중요한 개념입니다
  - ✅ **정확한 답변**: "Draw Call은 CPU 병목, Fill Rate는 GPU 픽셀 병목입니다"
  - Draw Call 병목은 CPU가 GPU에 명령을 보내는 과정에서 발생하고, Fill Rate 병목은 GPU가 픽셀을 그리는 과정에서 발생합니다.

### ✅ 감소 기법 (중요)

**질문 1: Draw Call을 줄이는 대표적인 방법에는 무엇이 있나요?**
- **현재 답변**: "배칭과 인스턴싱이 존재합니다."
- **피드백**:
  - 💡 **보완**: "Batching, Instancing, 상태 정렬입니다"
  - 배칭과 인스턴싱 외에 상태 정렬(state sorting)도 중요한 방법입니다.

**질문 2: Batching이란 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Draw Call 최적화의 핵심 기법입니다
  - ✅ **정확한 답변**: "여러 메쉬를 하나로 묶어 그리는 기법입니다"
  - Batching은 여러 개의 메쉬를 하나로 합쳐서 한 번의 Draw Call로 그리는 기법입니다.

### ✅ 엔진 / 실무 관점

**질문 1: 게임 엔진에서 Draw Call 수를 확인하는 방법은 무엇인가요?**
- **현재 답변**: "Draw Call의 호출부에 카운트를 셉니다."
- **피드백**:
  - ⚠️ **부정확**: "호출부에 카운트를 셉니다"는 구현 방법이고, 실제 확인 방법이 아닙니다
  - ✅ **정확한 답변**: "엔진 프로파일러나 렌더 디버거입니다"
  - Unity, Unreal 등의 게임 엔진에서는 프로파일러(Profiler)나 렌더 디버거를 통해 Draw Call 수를 확인합니다.

**질문 2: Draw Call은 무조건 줄일수록 좋은가요?**
- **현재 답변**: "의도한대로 이뤄진다면 줄일수록 좋습니다."
- **피드백**:
  - ⚠️ **부정확**: "무조건 줄일수록 좋다"는 오해입니다
  - ✅ **정확한 답변**: "아닙니다, 과도한 배치는 오히려 GPU 부담이 될 수 있습니다"
  - Draw Call을 줄이기 위한 배칭은 메모리를 많이 사용하고, 큰 배치는 GPU 부담을 증가시킬 수 있습니다. 트레이드오프를 고려해야 합니다.

### ✅ 요약 질문

**질문 1: Draw Call 개념을 한 문장으로 요약해보세요.**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: 핵심 개념을 요약하는 중요한 질문입니다
  - ✅ **정확한 답변**: "Draw Call은 'CPU가 GPU에게 보내는 그리기 요청'입니다"
  - 또는 "CPU가 GPU에게 렌더링을 요청하는 명령"이라고 설명할 수 있습니다.

### 📊 전체 평가

**강점:**
- ✅ Draw Call 호출 주체(CPU) 이해
- ✅ Draw Call 비용 발생 원인(CPU → GPU 전달) 이해
- ✅ 상태 변경과 Draw Call의 관계 이해
- ✅ 머티리얼이 Draw Call 수에 미치는 영향 이해
- ✅ Draw Call 감소 기법(Batching, Instancing) 언급

**개선 필요:**
- ❌ Draw Call 정의 오개념 (GPU가 명령 → CPU가 GPU에게 요청)
- ❌ Draw Call 비용 주체 오개념 (GPU 연산 → CPU 연산)
- ❌ Batching 정의 답변 누락
- ❌ Draw Call과 Fill Rate 병목 차이 답변 누락
- ❌ 요약 질문 답변 누락
- ⚠️ 렌더 순서 정렬 설명 부정확 (가시성 → 상태 묶기)
- ⚠️ Draw Call 수 확인 방법 부정확 (호출부 카운트 → 프로파일러)
- ⚠️ Draw Call 최적화 트레이드오프 부정확 (무조건 좋음 → 트레이드오프 존재)
- 💡 Draw Call과 상태 변경 관계 보완 필요
- 💡 Draw Call이 나뉘는 경우 보완 필요 (머티리얼 → 상태 전반)
- 💡 Draw Call 병목 발생 조건 보완 필요 (많아지면 → 구체적 조건)
- 💡 Draw Call 감소 방법 보완 필요 (배칭/인스턴싱 → 상태 정렬 추가)

**우선순위:**
1. **높음**: Draw Call 정의 오개념, Draw Call 비용 주체 오개념, Batching 정의 (답변 누락), 요약 질문 (답변 누락)
2. **중간**: Draw Call과 Fill Rate 병목 차이 (답변 누락), 렌더 순서 정렬 설명, Draw Call 최적화 트레이드오프, Draw Call 수 확인 방법
3. **낮음**: 답변의 구체성 개선

**특별 주의사항:**
- Draw Call은 CPU가 GPU에게 보내는 명령이며, 비용의 주체는 CPU입니다. 이는 면접에서 자주 혼동되는 부분입니다
- Draw Call 병목과 Fill Rate 병목은 각각 CPU와 GPU에서 발생하는 서로 다른 병목입니다
- Draw Call 최적화는 트레이드오프가 있습니다. 무조건 줄이는 것보다 상황에 맞는 최적화가 중요합니다

