# 🧠 렌더링 파이프라인(Rendering Pipeline) 단계 설명 가능 면접 질문 리스트

## ✅ 전체 개요

1. 렌더링 파이프라인이란 무엇인가요?

    - 하나의 물체를 그리기까지 거쳐야하는 gpu 함수들입니다.

2. 렌더링 파이프라인은 왜 여러 단계로 나뉘어 있나요?

    - 가공 단계에 따라 갈아끼울 수 있는 구조를 선택했기 때문입니다.

## ✅ 입력 단계

1. Vertex Data란 무엇인가요?

    - 정점 데이터입니다. 모델 좌표 기준의 정점 위치와 색상, normal, tangent 등의 정보를 가집니다.

2. 정점 데이터는 GPU로 어떻게 전달되나요?

    - const 버퍼를 통해 전달됩니다.

## ✅ Vertex Shader

1. Vertex Shader의 역할은 무엇인가요?

    - 모델의 정점 데이터를 전달 받고, 모델 -> 월드 -> 뷰 -> 투영 순의 행렬변환을 수행합니다.

2. Vertex Shader의 입력과 출력은 무엇인가요?

    - 입력은 정점정보이고, 출력으로는 행렬변환 된 정점 정보입니다.

3. Vertex Shader에서 수행하면 안 되는 작업은 무엇인가요?

## ✅ Primitive Assembly / Clipping

1. Primitive Assembly 단계에서는 무엇을 하나요?

    - 레이아웃과 토폴로지를 세팅합니다.

2. Clipping은 왜 필요한가요?

    - 최적화의 일환입니다. 화면에 출력되지 않을 공간을 계산할 필요는 없기 때문입니다.

## ✅ Rasterization

1. Rasterization 단계란 무엇인가요?

    - geometry shader 단계를 거친 후의 정점 정보들을 토대로 클리핑, 재구성, 픽셀 결정, 보간 등이 이루어집니다.

2. Rasterization의 결과물은 무엇인가요?

    - 그리기로 결정된 픽셀 입니다.

## ✅ Fragment(Pixel) Shader

1. Fragment Shader의 역할은 무엇인가요?

    - 하나 하나의 픽셀에 대한 함수입니다. 주로 픽셀의 색상을 결정하며 조명 계산도 합니다.

2. Fragment Shader에서 주로 어떤 계산을 하나요?

    - 조명 계산을 합니다.

## ✅ Output Merger

1. Output Merger 단계에서는 무엇이 처리되나요?

    - depthstencilstate를 통해 현재 픽셀의 z값을 토대로 그릴지 버릴지 결정하고, 블랜딩 state로 최종 렌더타겟 색상을 결정합니다.

2. Depth Test와 Blending은 어느 단계에서 수행되나요?

    - OM 에서 수행됩니다.

## ✅ 고급 파이프라인 개념

1. Fixed-function 단계와 Programmable 단계의 차이는 무엇인가요?
2. Forward Rendering과 Deferred Rendering의 파이프라인 차이는 무엇인가요?

    - 조명을 계산하는 시점에 대한 차이가 있습니다. Forward Rendering은 물체를 그릴 때 마다 해당 물체와 모든 조명을 계산합니다. Deferred Rendering은 모든 조명의 계산을 진행 후 해당 물체와 합치게 됩니다.

## ✅ 요약 질문

1. 렌더링 파이프라인 전체 흐름을 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

### ✅ 전체 개요

1. 3D 데이터를 화면의 픽셀로 변환하는 GPU 처리 과정입니다.
2. 역할 분리로 병렬성과 하드웨어 최적화를 하기 위해서입니다.

### ✅ 입력 단계

3. 위치, 노멀, UV 같은 정점 속성 데이터입니다.
4. 버텍스 버퍼를 통해 GPU 메모리로 전달됩니다.

### ✅ Vertex Shader

5. 정점을 클립 공간으로 변환하는 것입니다.
6. 입력은 정점 속성, 출력은 변환된 정점입니다.
7. 다른 정점 결과에 의존하는 작업입니다.

### ✅ Primitive Assembly / Clipping

8. 정점을 삼각형 같은 기본 도형으로 묶습니다.
9. 화면 밖에 있는 도형을 제거하기 위해서입니다.

### ✅ Rasterization

10. 도형을 픽셀 단위로 분해하는 단계입니다.
11. Fragment 후보 집합입니다.

### ✅ Fragment(Pixel) Shader

12. 각 픽셀의 최종 색상을 계산합니다.
13. 조명, 텍스처 샘플링, 머티리얼 계산입니다.

### ✅ Output Merger

14. 최종 픽셀을 프레임 버퍼에 기록합니다.
15. Output Merger 단계입니다.

### ✅ 고급 파이프라인 개념

16. 고정 로직과 셰이더로 작성 가능한 로직의 차이입니다.
17. Forward는 즉시 조명 계산, Deferred는 G-buffer 이후 계산입니다.

18. 렌더링 파이프라인은 “정점을 픽셀로 바꾸는 단계적 GPU 처리 흐름”입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 전체 개요

**질문 1: 렌더링 파이프라인이란 무엇인가요?**
- **현재 답변**: "하나의 물체를 그리기까지 거쳐야하는 gpu 함수들입니다."
- **피드백**:
  - ⚠️ **부정확**: "gpu 함수들"이라는 표현이 부정확합니다
  - ✅ **정확한 답변**: "3D 데이터를 화면의 픽셀로 변환하는 GPU 처리 과정입니다"
  - 렌더링 파이프라인은 여러 단계로 구성된 처리 과정이며, 일부는 고정 함수(fixed-function) 단계입니다

**질문 2: 렌더링 파이프라인은 왜 여러 단계로 나뉘어 있나요?**
- **현재 답변**: "가공 단계에 따라 갈아끼울 수 있는 구조를 선택했기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 맞지만 핵심 이유가 누락되었습니다
  - ✅ **정확한 답변**: "역할 분리로 병렬성과 하드웨어 최적화를 하기 위해서입니다"
  - 각 단계를 독립적으로 최적화하고 병렬 처리할 수 있어 성능 향상이 가능합니다

### ✅ 입력 단계

**질문 1: Vertex Data란 무엇인가요?**
- **현재 답변**: "정점 데이터입니다. 모델 좌표 기준의 정점 위치와 색상, normal, tangent 등의 정보를 가집니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하게 표현할 수 있습니다
  - ✅ **정확한 답변**: "위치, 노멀, UV 같은 정점 속성 데이터입니다"
  - 정점 데이터는 위치(position), 노멀(normal), UV 좌표, 색상, 탄젠트(tangent) 등의 속성 정보를 포함합니다

**질문 2: 정점 데이터는 GPU로 어떻게 전달되나요?**
- **현재 답변**: "const 버퍼를 통해 전달됩니다."
- **피드백**:
  - ❌ **오개념**: 정점 데이터는 constant buffer가 아니라 vertex buffer를 통해 전달됩니다
  - ✅ **정확한 답변**: "버텍스 버퍼를 통해 GPU 메모리로 전달됩니다"
  - constant buffer는 셰이더 상수(행렬 등)를 전달하는 데 사용되고, vertex buffer는 정점 데이터를 전달합니다

### ✅ Vertex Shader

**질문 1: Vertex Shader의 역할은 무엇인가요?**
- **현재 답변**: "모델의 정점 데이터를 전달 받고, 모델 -> 월드 -> 뷰 -> 투영 순의 행렬변환을 수행합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하고 정확한 표현이 있습니다
  - ✅ **정확한 답변**: "정점을 클립 공간으로 변환하는 것입니다"
  - 모델 공간 → 월드 공간 → 뷰 공간 → 클립 공간으로 변환하는 것이 핵심입니다

**질문 2: Vertex Shader의 입력과 출력은 무엇인가요?**
- **현재 답변**: "입력은 정점정보이고, 출력으로는 행렬변환 된 정점 정보입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "입력은 정점 속성, 출력은 변환된 정점입니다"
  - 입력은 정점 속성(위치, 노멀, UV 등), 출력은 클립 공간 좌표와 보간될 속성들입니다

**질문 3: Vertex Shader에서 수행하면 안 되는 작업은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "다른 정점 결과에 의존하는 작업입니다"
  - Vertex Shader는 각 정점을 독립적으로 처리하므로, 다른 정점의 결과를 참조하는 작업은 불가능합니다
  - 예: 정점 간 통신, 정점 순서에 의존하는 작업 등

### ✅ Primitive Assembly / Clipping

**질문 1: Primitive Assembly 단계에서는 무엇을 하나요?**
- **현재 답변**: "레이아웃과 토폴로지를 세팅합니다."
- **피드백**:
  - ⚠️ **부정확**: "레이아웃과 토폴로지를 세팅"이라는 표현이 부정확합니다
  - ✅ **정확한 답변**: "정점을 삼각형 같은 기본 도형으로 묶습니다"
  - Vertex Shader에서 나온 정점들을 기본 도형(primitive, 주로 삼각형)으로 조립합니다
  - 레이아웃과 토폴로지는 입력 어셈블러(Input Assembler) 단계에서 설정됩니다

**질문 2: Clipping은 왜 필요한가요?**
- **현재 답변**: "최적화의 일환입니다. 화면에 출력되지 않을 공간을 계산할 필요는 없기 때문입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "화면 밖에 있는 도형을 제거하기 위해서입니다"
  - 클립 공간 밖에 있는 primitive를 제거하여 불필요한 연산을 줄입니다

### ✅ Rasterization

**질문 1: Rasterization 단계란 무엇인가요?**
- **현재 답변**: "geometry shader 단계를 거친 후의 정점 정보들을 토대로 클리핑, 재구성, 픽셀 결정, 보간 등이 이루어집니다."
- **피드백**:
  - ⚠️ **부정확**: "geometry shader 단계를 거친 후"라는 표현이 부정확합니다. Geometry Shader는 선택적 단계입니다
  - ✅ **정확한 답변**: "도형을 픽셀 단위로 분해하는 단계입니다"
  - Rasterization은 primitive를 fragment(픽셀 후보)로 변환하고, 정점 속성을 보간합니다
  - 클리핑은 이미 이전 단계에서 수행되었습니다

**질문 2: Rasterization의 결과물은 무엇인가요?**
- **현재 답변**: "그리기로 결정된 픽셀 입니다."
- **피드백**:
  - ⚠️ **부정확**: "그리기로 결정된 픽셀"보다는 "fragment"가 더 정확한 용어입니다
  - ✅ **정확한 답변**: "Fragment 후보 집합입니다"
  - Rasterization의 결과는 fragment이며, 이후 Fragment Shader와 Depth Test를 거쳐 최종 픽셀이 결정됩니다

### ✅ Fragment(Pixel) Shader

**질문 1: Fragment Shader의 역할은 무엇인가요?**
- **현재 답변**: "하나 하나의 픽셀에 대한 함수입니다. 주로 픽셀의 색상을 결정하며 조명 계산도 합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하게 표현할 수 있습니다
  - ✅ **정확한 답변**: "각 픽셀의 최종 색상을 계산합니다"
  - Fragment Shader는 각 fragment의 색상을 계산하며, 조명, 텍스처, 머티리얼 등을 고려합니다

**질문 2: Fragment Shader에서 주로 어떤 계산을 하나요?**
- **현재 답변**: "조명 계산을 합니다."
- **피드백**:
  - ⚠️ **부정확**: 조명 계산 외에도 다른 중요한 계산들이 있습니다
  - ✅ **정확한 답변**: "조명, 텍스처 샘플링, 머티리얼 계산입니다"
  - 텍스처 샘플링, 머티리얼 속성 계산, 조명 계산 등이 주요 작업입니다

### ✅ Output Merger

**질문 1: Output Merger 단계에서는 무엇이 처리되나요?**
- **현재 답변**: "depthstencilstate를 통해 현재 픽셀의 z값을 토대로 그릴지 버릴지 결정하고, 블랜딩 state로 최종 렌더타겟 색상을 결정합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 간결하게 표현할 수 있습니다
  - ✅ **정확한 답변**: "최종 픽셀을 프레임 버퍼에 기록합니다"
  - Depth Test, Stencil Test, Blending을 수행하여 최종 픽셀을 결정하고 프레임 버퍼에 기록합니다

**질문 2: Depth Test와 Blending은 어느 단계에서 수행되나요?**
- **현재 답변**: "OM 에서 수행됩니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "Output Merger 단계입니다"
  - OM(Output Merger) 단계에서 Depth Test, Stencil Test, Blending이 수행됩니다

### ✅ 고급 파이프라인 개념

**질문 1: Fixed-function 단계와 Programmable 단계의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "고정 로직과 셰이더로 작성 가능한 로직의 차이입니다"
  - Fixed-function은 하드웨어에 고정된 로직(예: Rasterization, Depth Test), Programmable은 셰이더로 작성 가능한 단계(예: Vertex Shader, Fragment Shader)입니다

**질문 2: Forward Rendering과 Deferred Rendering의 파이프라인 차이는 무엇인가요?**
- **현재 답변**: "조명을 계산하는 시점에 대한 차이가 있습니다. Forward Rendering은 물체를 그릴 때 마다 해당 물체와 모든 조명을 계산합니다. Deferred Rendering은 모든 조명의 계산을 진행 후 해당 물체와 합치게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "모든 조명의 계산을 진행 후 해당 물체와 합치게 됩니다"라는 표현이 부정확합니다
  - ✅ **정확한 답변**: "Forward는 즉시 조명 계산, Deferred는 G-buffer 이후 계산입니다"
  - Forward Rendering은 Fragment Shader에서 직접 조명을 계산하고, Deferred Rendering은 먼저 G-buffer에 기하 정보를 저장한 후 별도 패스에서 조명을 계산합니다

### ✅ 요약 질문

**질문 1: 렌더링 파이프라인 전체 흐름을 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 요약 질문입니다
  - ✅ **정확한 답변**: "렌더링 파이프라인은 '정점을 픽셀로 바꾸는 단계적 GPU 처리 흐름'입니다"
  - 정점 데이터 입력 → 변환 → 래스터화 → 픽셀 색상 계산 → 최종 출력의 흐름입니다

### 📊 전체 평가

**강점:**
- ✅ 렌더링 파이프라인의 기본 개념을 이해함
- ✅ Vertex Shader의 행렬 변환 순서를 정확히 알고 있음
- ✅ Output Merger 단계에서 Depth Test와 Blending이 수행된다는 것을 이해함
- ✅ Forward와 Deferred Rendering의 기본적인 차이를 이해함

**개선 필요:**
- ❌ **오개념**: 정점 데이터 전달 방법 (constant buffer → vertex buffer)
- ❌ **답변 누락**: Vertex Shader에서 수행하면 안 되는 작업, Fixed-function과 Programmable의 차이, 요약 질문
- ⚠️ **부정확**: 렌더링 파이프라인 정의가 부정확 ("gpu 함수들")
- ⚠️ **부정확**: Rasterization 설명에 Geometry Shader 언급 (선택적 단계)
- ⚠️ **부정확**: Rasterization 결과물 표현 ("픽셀" → "fragment")
- ⚠️ **부정확**: Primitive Assembly 설명 ("레이아웃과 토폴로지 세팅")
- ⚠️ **부정확**: Fragment Shader 계산 설명이 부족 (조명만 언급)
- ⚠️ **부정확**: Deferred Rendering 설명이 부정확

**우선순위:**
1. **높음**: 
   - 정점 데이터 전달 방법 오개념 수정 (constant buffer → vertex buffer)
   - Vertex Shader에서 수행하면 안 되는 작업
   - Fixed-function과 Programmable의 차이
2. **중간**: 
   - 렌더링 파이프라인 정의 정확화
   - Rasterization 설명 정정 (Geometry Shader 언급 제거)
   - Fragment Shader 계산 보완 (텍스처, 머티리얼)
   - Deferred Rendering 설명 정확화
3. **낮음**: 
   - Rasterization 결과물 용어 정정 (fragment)
   - Primitive Assembly 설명 보완
   - 요약 질문 답변

**특별 주의사항:**
- **Vertex Buffer vs Constant Buffer**: 정점 데이터는 vertex buffer를 통해 전달되고, 셰이더 상수(행렬 등)는 constant buffer를 통해 전달됩니다. 면접에서 자주 나오는 질문입니다.
- **Rasterization**: Geometry Shader는 선택적 단계이므로 Rasterization 설명에서 필수 단계로 언급하면 안 됩니다. Rasterization은 primitive를 fragment로 변환하는 단계입니다.
- **Fragment vs Pixel**: Rasterization의 결과는 fragment(픽셀 후보)이며, Depth Test와 Fragment Shader를 거쳐 최종 픽셀이 결정됩니다.
- **Fixed-function vs Programmable**: Fixed-function은 하드웨어에 고정된 단계(Rasterization, Depth Test 등), Programmable은 셰이더로 작성 가능한 단계(Vertex Shader, Fragment Shader 등)입니다.
- **Deferred Rendering**: G-buffer에 기하 정보를 먼저 저장하고, 이후 별도 패스에서 조명을 계산하는 방식입니다. Forward Rendering과의 차이를 명확히 이해해야 합니다.


