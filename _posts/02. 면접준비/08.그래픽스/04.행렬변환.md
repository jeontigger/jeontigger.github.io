# 🧠 행렬 변환 순서(Matrix Transformation Order) 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 행렬 변환 순서란 무엇인가요?

    - 행렬 계산을 할 때 변환하는 순서를 의미합니다.

2. 행렬 곱에서 순서가 중요한 이유는 무엇인가요?

    - 계산 순서에 따라 결과값이 달라지기 때문입니다. 행렬은 곱셈의 교환법칙이 성립하지 않습니다.

## ✅ 기본 변환 요소

1. 이동(Translation), 회전(Rotation), 스케일(Scale)의 역할은 무엇인가요?

    - 오브젝트의 이동, 회전, 크기 정보를 담습니다.

2. 이 세 변환은 교환 가능(commutative)한가요?

    - 교환 불가능입니다. 계산 순서에 따라 결과값이 달라집니다.

## ✅ 로컬 → 월드 변환 순서 (핵심)

1. 일반적인 로컬 변환 순서는 어떻게 되나요?

    - 크기, 회전, 이동 순서대로 이뤄집니다.

2. 왜 Scale → Rotation → Translation 순서인가요?

    - 스케일과 회전 변환이 원점에서 이뤄지기 때문입니다.

3. Translation을 먼저 적용하면 어떤 문제가 발생하나요?

    - 스케일과 회전 변환이 의도하지 않은 방향으로 퍼져나갑니다.

## ✅ 회전 중심 문제

1. 회전의 기준점(pivot)은 어디인가요?

    - 원점입니다.

2. 회전 중심을 바꾸려면 어떻게 해야 하나요?

    - 회전축을 이동시키면됩니다.

## ✅ 행렬 곱 관점

1. M = T *R* S 와 M = S *R* T 의 차이는 무엇인가요?

    - 이동, 회전, 크기 순으로 계산하는 것과 크기 회전 이동 순으로 계산하는 것입니다. 두 결과는 다릅니다.

2. 벡터에 행렬을 적용할 때 어느 쪽부터 곱해지나요?

    - 오른쪽부터 곱해집니다.

## ✅ 좌표계 / API 차이

1. 행 우선(row-major)과 열 우선(column-major)의 차이는 무엇인가요?

    - row 순서대로 읽거나 column 순서대로 읽는 차이가 있습니다. 사람이 읽기엔 column 순서대로 읽지만 gpu가 읽기엔 row 순서대로 읽는 것이 편하기 때문입니다.

2. OpenGL과 DirectX에서 행렬 곱 해석이 다른 이유는 무엇인가요?

    - 좌표계가 다릅니다. directX는 왼손좌표계, opengl은 오른손 좌표계를 사용합니다.

## ✅ 실무 / 셰이더 관점

1. Vertex Shader에서 좌표 변환은 어떤 행렬 순서로 적용되나요?

    - W, V, P 순서대로 적용됩니다.

2. 행렬 변환 순서를 잘못 잡으면 어떤 버그가 발생하나요?

    - 정점의 위치가 의도하지 않은 위치로 설정됩니다.

## ✅ 요약 질문

1. 행렬 변환 순서를 한 문장으로 요약해보세요.

    - 순서에 따라 결과값이 달라져서 일관성을 유지해야합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

1. 여러 변환 행렬을 어떤 순서로 곱해 적용할지에 대한 규칙입니다.
2. 행렬 곱은 교환 법칙이 성립하지 않기 때문입니다.

3. 크기 변경, 방향 변경, 위치 변경입니다.
4. 아니요, 순서에 따라 결과가 달라집니다.

5. Scale → Rotation → Translation 입니다.
6. 로컬 기준에서 크기와 방향을 정한 뒤 위치를 옮기기 때문입니다.
7. 월드 원점 기준으로 회전하거나 스케일됩니다.

8. 로컬 좌표계의 원점입니다.
9. 이동 → 회전 → 역이동을 조합합니다.

10. 적용되는 변환의 순서가 완전히 달라집니다.
11. 보통 오른쪽에서 왼쪽 순으로 적용됩니다.

12. 메모리 배치와 수학적 표기 차이입니다.
13. 벡터를 행/열로 취급하는 관점 차이입니다.

14. 보통 MVP = P *V* M 순서입니다.
15. 물체가 이상한 축으로 회전하거나 위치가 틀어집니다.

16. 행렬 변환 순서는 “로컬 기준 변환 후 월드로 이동”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 행렬 변환 순서란 무엇인가요?**
- **현재 답변**: "행렬 계산을 할 때 변환하는 순서를 의미합니다."
- **피드백**:
  - 💡 **보완**: "여러 변환 행렬을 어떤 순서로 곱해 적용할지에 대한 규칙입니다"
  - 현재 답변은 너무 모호합니다. "행렬 변환 순서"는 구체적으로 여러 변환 행렬을 곱하는 순서에 대한 규칙을 의미합니다.

### ✅ 기본 변환 요소

(정확한 답변 - 피드백 생략)

### ✅ 로컬 → 월드 변환 순서 (핵심)

(정확한 답변 - 피드백 생략)

### ✅ 회전 중심 문제

**질문 2: 회전 중심을 바꾸려면 어떻게 해야 하나요?**
- **현재 답변**: "회전축을 이동시키면됩니다."
- **피드백**:
  - ❌ **오개념**: "회전축을 이동시킨다"는 표현이 부정확합니다
  - ✅ **정확한 답변**: "이동 → 회전 → 역이동을 조합합니다"
  - 회전 중심을 바꾸려면: 1) 원하는 회전 중심으로 이동(T), 2) 회전(R), 3) 역이동(T⁻¹)을 순서대로 적용합니다. 즉, T⁻¹ * R * T 형태입니다.

### ✅ 행렬 곱 관점

(정확한 답변 - 피드백 생략)

### ✅ 좌표계 / API 차이

**질문 1: 행 우선(row-major)과 열 우선(column-major)의 차이는 무엇인가요?**
- **현재 답변**: "row 순서대로 읽거나 column 순서대로 읽는 차이가 있습니다. 사람이 읽기엔 column 순서대로 읽지만 gpu가 읽기엔 row 순서대로 읽는 것이 편하기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 행 우선/열 우선은 단순히 읽는 순서의 차이가 아닙니다
  - ✅ **정확한 답변**: "메모리 배치와 수학적 표기 차이입니다"
  - 행 우선(row-major)은 메모리에 행 단위로 연속 저장되고, 열 우선(column-major)은 열 단위로 연속 저장됩니다. 수학적으로는 벡터를 행 벡터로 취급하는지 열 벡터로 취급하는지의 차이입니다.

**질문 2: OpenGL과 DirectX에서 행렬 곱 해석이 다른 이유는 무엇인가요?**
- **현재 답변**: "좌표계가 다릅니다. directX는 왼손좌표계, opengl은 오른손 좌표계를 사용합니다."
- **피드백**:
  - ⚠️ **부분적 오개념**: 좌표계 차이는 맞지만, 행렬 곱 해석의 차이의 핵심 이유는 아닙니다
  - ✅ **정확한 답변**: "벡터를 행/열로 취급하는 관점 차이입니다"
  - OpenGL은 벡터를 열 벡터로 취급하므로 v' = M * v 형태이고, DirectX는 행 벡터로 취급하므로 v' = v * M 형태입니다. 좌표계(왼손/오른손)는 별개의 개념입니다.

### ✅ 실무 / 셰이더 관점

**질문 1: Vertex Shader에서 좌표 변환은 어떤 행렬 순서로 적용되나요?**
- **현재 답변**: "W, V, P 순서대로 적용됩니다."
- **피드백**:
  - ❌ **오개념**: "W, V, P 순서"는 잘못된 표현입니다
  - ✅ **정확한 답변**: "보통 MVP = P * V * M 순서입니다"
  - Vertex Shader에서는 일반적으로 Model → View → Projection 순서로 변환이 이루어지며, 행렬 곱셈은 P * V * M 순서로 계산됩니다. "W, V, P"는 표준적인 표현이 아닙니다.

**질문 2: 행렬 변환 순서를 잘못 잡으면 어떤 버그가 발생하나요?**
- **현재 답변**: "정점의 위치가 의도하지 않은 위치로 설정됩니다."
- **피드백**:
  - 💡 **보완**: "물체가 이상한 축으로 회전하거나 위치가 틀어집니다"
  - 현재 답변은 맞지만, 구체적인 현상(이상한 축으로 회전, 위치 틀어짐)을 언급하면 더 좋습니다.

### ✅ 요약 질문

**질문 1: 행렬 변환 순서를 한 문장으로 요약해보세요.**
- **현재 답변**: "순서에 따라 결과값이 달라져서 일관성을 유지해야합니다."
- **피드백**:
  - 💡 **보완**: "행렬 변환 순서는 '로컬 기준 변환 후 월드로 이동'입니다"
  - 현재 답변은 행렬 곱의 일반적 특성을 설명하는 수준입니다. 행렬 변환 순서의 핵심 개념(로컬 → 월드 변환)을 포함하면 더 좋습니다.

### 📊 전체 평가

**강점:**
- ✅ 행렬 곱의 비가환성 이해
- ✅ 로컬 변환 순서(Scale → Rotation → Translation) 이해
- ✅ Translation 먼저 적용 시 문제점 이해
- ✅ 행렬 곱에서 벡터 적용 순서 이해

**개선 필요:**
- ❌ 회전 중심 변경 방법의 오개념 (회전축 이동 → 이동-회전-역이동 조합)
- ❌ Vertex Shader 변환 순서 오개념 (W, V, P → MVP = P * V * M)
- ⚠️ 행 우선/열 우선 개념 부정확 (읽는 순서 → 메모리 배치/수학적 표기 차이)
- ⚠️ OpenGL/DirectX 차이 부정확 (좌표계 차이 → 벡터 행/열 취급 차이)
- 💡 행렬 변환 순서 정의가 모호함 (구체적인 규칙 설명 필요)
- 💡 버그 설명이 일반적임 (구체적 현상 설명 필요)
- 💡 요약이 핵심 개념을 포함하지 않음 (로컬 → 월드 변환 개념 필요)

**우선순위:**
1. **높음**: Vertex Shader 변환 순서 (실무에서 매우 중요), 회전 중심 변경 방법
2. **중간**: 행 우선/열 우선 개념, OpenGL/DirectX 차이
3. **낮음**: 답변의 구체성 개선

**특별 주의사항:**
- MVP 행렬 곱셈 순서는 Vertex Shader에서 매우 중요하며 면접에서 자주 질문됩니다
- 행 우선/열 우선은 메모리 레이아웃과 관련된 중요한 개념입니다
- OpenGL과 DirectX의 차이는 벡터를 행/열로 취급하는 관점 차이가 핵심이며, 좌표계 차이와는 구분되어야 합니다

