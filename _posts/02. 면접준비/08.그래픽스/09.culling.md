# 🧠 Culling 개념 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. Culling이란 무엇인가요?

    - 컬링이란 렌더타겟에 그리는데 불필요한 부분들을 잘라내는 최적화 기법입니다.

2. Culling은 어떤 성능 문제를 해결하기 위한 기법인가요?

    - GPU 성능 문제를 해결하기 위함입니다.

## ✅ 종류 구분 (핵심)

1. Frustum Culling이란 무엇인가요?

    - 카메라의 시선인 절두체를 벗어나는 정점들을 자르는 최적화입니다.

2. Occlusion Culling이란 무엇인가요?

    - 

3. Backface Culling이란 무엇인가요?

    - 뒷면으로 그려져있는 토폴로지에 대해 draw 하지 않는 최적화입니다.

## ✅ Frustum Culling

1. Frustum Culling은 언제 수행되나요?

    - Rasterizer에서 수행됩니다.

2. Frustum Culling이 성능에 미치는 영향은 무엇인가요?

    - 
    
3. Frustum Culling의 한계는 무엇인가요?

## ✅ Occlusion Culling

1. Occlusion Culling은 왜 필요한가요?
2. Occlusion Culling은 어떻게 동작하나요?
3. Occlusion Culling의 구현 비용은 어떻게 되나요?

## ✅ Backface Culling

1. Backface Culling이란 무엇인가요?
2. Backface Culling은 어느 단계에서 수행되나요?
3. Backface Culling을 비활성화해야 하는 경우는 언제인가요?

## ✅ 성능 관점

1. Culling이 Draw Call 수에 영향을 주나요?
2. Culling이 GPU 연산량에 영향을 주나요?
3. Culling 자체의 비용은 어떻게 되나요?

## ✅ 실무 / 게임 엔진

1. 게임 엔진에서 Culling은 어떻게 구현되나요?
2. 대규모 오픈 월드에서 Culling이 중요한 이유는 무엇인가요?

## ✅ 요약 질문

1. Culling 개념을 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

1. 화면에 보이지 않는 객체를 렌더링에서 제외하는 기법입니다.
2. 불필요한 렌더링 연산을 줄여 성능을 향상시키기 위한 기법입니다.

3. 카메라 시야 밖의 객체를 제외하는 기법입니다.
4. 다른 객체에 가려진 객체를 제외하는 기법입니다.
5. 카메라를 향하지 않은 면을 제외하는 기법입니다.

6. 렌더링 전에 카메라의 시야 절두체와 객체의 경계를 비교합니다.
7. Draw Call과 GPU 연산량을 크게 줄입니다.
8. 시야 안에 있지만 가려진 객체는 제외하지 못합니다.

9. Frustum 안에 있어도 가려진 객체를 제외하기 위해서입니다.
10. 깊이 버퍼나 사전 계산된 가시성 정보를 사용합니다.
11. CPU 비용이 크고 구현이 복잡합니다.

12. 카메라를 향하지 않은 삼각형 면을 제외하는 기법입니다.
13. Rasterization 단계에서 수행됩니다.
14. 양면 렌더링이 필요한 경우(투명, 와이어프레임 등)입니다.

15. 네, Culling된 객체는 Draw Call에서 제외됩니다.
16. 네, GPU에서 처리할 픽셀 수가 줄어듭니다.
17. CPU에서 경계 체크 비용이 발생하지만 렌더링 비용 절감이 더 큽니다.

18. 공간 분할 구조(Octree, BSP)와 경계 볼륨(Bounding Box/Sphere)을 사용합니다.
19. 객체 수가 많아 Culling 없이는 렌더링이 불가능하기 때문입니다.

20. Culling은 "보이지 않는 객체를 렌더링에서 제외하는 최적화 기법"입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: Culling이란 무엇인가요?**
- **현재 답변**: "컬링이란 렌더타겟에 그리는데 불필요한 부분들을 잘라내는 최적화 기법입니다."
- **피드백**:
  - 💡 **보완**: "화면에 보이지 않는 객체를 렌더링에서 제외하는 기법입니다"
  - 현재 답변은 맞지만, "불필요한 부분들을 잘라내는"보다 "보이지 않는 객체를 제외하는"이라는 표현이 더 정확하고 명확합니다.

**질문 2: Culling은 어떤 성능 문제를 해결하기 위한 기법인가요?**
- **현재 답변**: "GPU 성능 문제를 해결하기 위함입니다."
- **피드백**:
  - 💡 **보완**: "불필요한 렌더링 연산을 줄여 성능을 향상시키기 위한 기법입니다"
  - "GPU 성능 문제"보다는 "불필요한 렌더링 연산"이라는 표현이 더 구체적입니다. Culling은 CPU와 GPU 모두에 도움이 됩니다.

### ✅ 종류 구분 (핵심)

**질문 1: Frustum Culling이란 무엇인가요?**
- **현재 답변**: "카메라의 시선인 절두체를 벗어나는 정점들을 자르는 최적화입니다."
- **피드백**:
  - ⚠️ **부정확**: "정점들을 자르는"보다는 "객체를 제외하는"이 정확합니다
  - ✅ **정확한 답변**: "카메라 시야 밖의 객체를 제외하는 기법입니다"
  - Frustum Culling은 정점 단위가 아닌 객체 단위로 수행됩니다. 객체의 경계 볼륨(Bounding Volume)과 Frustum을 비교하여 객체 전체를 제외합니다.

**질문 2: Occlusion Culling이란 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Culling의 주요 종류 중 하나입니다
  - ✅ **정확한 답변**: "다른 객체에 가려진 객체를 제외하는 기법입니다"
  - Frustum Culling으로 시야 안에 들어온 객체 중에서도 다른 객체에 의해 가려진 객체를 제외하는 기법입니다.

(정확한 답변 - 피드백 생략)

### ✅ Frustum Culling

**질문 1: Frustum Culling은 언제 수행되나요?**
- **현재 답변**: "Rasterizer에서 수행됩니다."
- **피드백**:
  - ❌ **오개념**: Frustum Culling은 Rasterizer가 아닌 CPU에서 수행됩니다
  - ✅ **정확한 답변**: "렌더링 전에 카메라의 시야 절두체와 객체의 경계를 비교합니다"
  - Frustum Culling은 CPU에서 렌더링 전에 수행됩니다. 객체의 경계 볼륨(Bounding Box/Sphere)과 카메라의 Frustum을 비교하여 제외할 객체를 결정합니다. Rasterization은 GPU에서 수행되는 다른 단계입니다.

**질문 2: Frustum Culling이 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Frustum Culling의 효과를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "Draw Call과 GPU 연산량을 크게 줄입니다"
  - Frustum Culling은 시야 밖의 객체를 제외하여 Draw Call 수를 줄이고, GPU에서 처리할 픽셀 수를 줄여 성능을 향상시킵니다.

**질문 3: Frustum Culling의 한계는 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Frustum Culling의 한계를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "시야 안에 있지만 가려진 객체는 제외하지 못합니다"
  - Frustum Culling은 시야 안에 있는 객체는 모두 렌더링하므로, 다른 객체에 가려진 객체도 렌더링됩니다. 이는 Occlusion Culling으로 해결합니다.

### ✅ Occlusion Culling

**질문 1: Occlusion Culling은 왜 필요한가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Occlusion Culling의 필요성을 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "Frustum 안에 있어도 가려진 객체를 제외하기 위해서입니다"
  - Frustum Culling만으로는 시야 안에 있지만 다른 객체에 가려진 객체를 제외할 수 없습니다. Occlusion Culling은 이러한 객체를 추가로 제외합니다.

**질문 2: Occlusion Culling은 어떻게 동작하나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Occlusion Culling의 동작 원리를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "깊이 버퍼나 사전 계산된 가시성 정보를 사용합니다"
  - Occlusion Culling은 깊이 버퍼(Depth Buffer)를 사용하여 가려진 객체를 판단하거나, 사전 계산된 가시성 정보(Precomputed Visibility)를 사용합니다.

**질문 3: Occlusion Culling의 구현 비용은 어떻게 되나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Occlusion Culling의 트레이드오프를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "CPU 비용이 크고 구현이 복잡합니다"
  - Occlusion Culling은 추가적인 CPU 연산(가시성 계산)이 필요하고, 구현이 복잡합니다. 따라서 모든 상황에서 항상 사용되는 것은 아닙니다.

### ✅ Backface Culling

**질문 1: Backface Culling이란 무엇인가요?**
- **현재 답변**: (질문 중복 - 종류 구분 섹션에 이미 있음)
- **피드백**:
  - ⚠️ **참고**: 이 질문은 "종류 구분" 섹션의 질문 3과 중복입니다
  - 종류 구분 섹션에서 이미 답변이 있으므로, 이 섹션의 질문 1은 제거하거나 다른 내용으로 변경하는 것이 좋습니다.

**질문 2: Backface Culling은 어느 단계에서 수행되나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Backface Culling의 수행 단계를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "Rasterization 단계에서 수행됩니다"
  - Backface Culling은 GPU의 Rasterization 단계에서 수행됩니다. 삼각형의 법선 벡터와 카메라 방향을 비교하여 뒷면을 판단합니다.

**질문 3: Backface Culling을 비활성화해야 하는 경우는 언제인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Backface Culling의 제한사항을 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "양면 렌더링이 필요한 경우(투명, 와이어프레임 등)입니다"
  - 투명 객체나 와이어프레임 렌더링, 양면이 모두 보여야 하는 경우(예: 나뭇잎)에는 Backface Culling을 비활성화해야 합니다.

### ✅ 성능 관점

**질문 1: Culling이 Draw Call 수에 영향을 주나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Culling의 효과를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "네, Culling된 객체는 Draw Call에서 제외됩니다"
  - Culling으로 제외된 객체는 Draw Call이 발생하지 않으므로, Draw Call 수가 줄어듭니다.

**질문 2: Culling이 GPU 연산량에 영향을 주나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Culling의 효과를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "네, GPU에서 처리할 픽셀 수가 줄어듭니다"
  - Culling으로 제외된 객체는 GPU에서 처리하지 않으므로, GPU 연산량(특히 픽셀 셰이딩)이 줄어듭니다.

**질문 3: Culling 자체의 비용은 어떻게 되나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Culling의 트레이드오프를 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "CPU에서 경계 체크 비용이 발생하지만 렌더링 비용 절감이 더 큽니다"
  - Culling은 CPU에서 경계 볼륨과 Frustum 등을 비교하는 비용이 발생하지만, 렌더링 비용 절감이 더 크므로 전체적으로 성능 향상을 가져옵니다.

### ✅ 실무 / 게임 엔진

**질문 1: 게임 엔진에서 Culling은 어떻게 구현되나요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: 실무 구현 방법을 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "공간 분할 구조(Octree, BSP)와 경계 볼륨(Bounding Box/Sphere)을 사용합니다"
  - 게임 엔진에서는 공간 분할 구조(Octree, BSP Tree 등)를 사용하여 효율적으로 Culling을 수행하고, 각 객체의 경계 볼륨을 사용하여 빠르게 판단합니다.

**질문 2: 대규모 오픈 월드에서 Culling이 중요한 이유는 무엇인가요?**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: Culling의 필요성을 이해하는 중요한 질문입니다
  - ✅ **정확한 답변**: "객체 수가 많아 Culling 없이는 렌더링이 불가능하기 때문입니다"
  - 대규모 오픈 월드에서는 수천, 수만 개의 객체가 존재하므로, Culling 없이는 모든 객체를 렌더링할 수 없습니다. Culling은 필수적입니다.

### ✅ 요약 질문

**질문 1: Culling 개념을 한 문장으로 요약해보세요.**
- **현재 답변**: (답변 누락)
- **피드백**:
  - ❌ **답변 필요**: 핵심 개념을 요약하는 중요한 질문입니다
  - ✅ **정확한 답변**: "Culling은 '보이지 않는 객체를 렌더링에서 제외하는 최적화 기법'입니다"
  - 또는 "화면에 보이지 않는 객체를 렌더링 전에 제외하여 성능을 향상시키는 기법"이라고 설명할 수 있습니다.

### 📊 전체 평가

**강점:**
- ✅ Backface Culling의 기본 개념 이해

**개선 필요:**
- ❌ Frustum Culling 수행 위치 오개념 (Rasterizer → CPU에서 렌더링 전)
- ❌ Frustum Culling 정의 부정확 (정점 → 객체)
- ❌ 답변 누락 다수 (Occlusion Culling 3개, Frustum Culling 2개, Backface Culling 2개, 성능 관점 3개, 실무 2개, 요약 1개)
- ⚠️ Culling 정의 보완 필요
- ⚠️ Culling이 해결하는 성능 문제 보완 필요
- ⚠️ Backface Culling 질문 중복

**우선순위:**
1. **높음**: Frustum Culling 수행 위치 오개념, 답변 누락 다수 (특히 Occlusion Culling, Frustum Culling, 성능 관점)
2. **중간**: Frustum Culling 정의, Culling 정의 및 성능 문제
3. **낮음**: Backface Culling 질문 중복 해결

**특별 주의사항:**
- Frustum Culling은 CPU에서 렌더링 전에 수행됩니다. Rasterization은 GPU 단계입니다
- Frustum Culling은 정점 단위가 아닌 객체 단위(Bounding Volume)로 수행됩니다
- Occlusion Culling은 Frustum Culling의 한계를 보완하는 기법으로, 구현 비용이 크지만 대규모 씬에서 중요합니다
- Culling은 CPU 비용이 발생하지만, 렌더링 비용 절감이 더 크므로 전체적으로 성능 향상을 가져옵니다
