---
title: 
date: 2026-01-10 21:33:01 +09:00
categories: [면접준비, STL]
published: false
tags:
    [면접준비]
---

# 🧠 C++ erase–remove idiom 면접 질문 리스트

## ✅ 기본 개념

1. erase–remove idiom이란 무엇인가요?
2. 왜 remove와 erase를 함께 사용해야 하나요?

## ✅ remove 동작 이해 (핵심)

1. std::remove는 실제로 무엇을 하나요?
2. std::remove의 반환값은 무엇을 의미하나요?

## ✅ erase 역할

1. erase는 어떤 역할을 하나요?
2. remove 결과를 erase에 넘기지 않으면 어떤 문제가 생기나요?

## ✅ 적용 대상 / 제약

1. erase–remove idiom은 어떤 컨테이너에서 주로 사용하나요?
2. list에서도 erase–remove idiom을 사용하나요?

## ✅ 변형 패턴

1. erase–remove_if 패턴은 언제 사용하나요?
2. remove_if의 조건식은 어떤 의미를 가지나요?

## ✅ 성능 / 설계 관점

1. erase–remove idiom의 시간 복잡도는 어떻게 되나요?
2. 이 패턴이 vector에 적합한 이유는 무엇인가요?

## ✅ 실무 / 버그 포인트

1. erase–remove idiom을 잘못 사용하면 어떤 버그가 발생하나요?
2. erase–remove idiom을 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. std::remove로 논리적 삭제를 한 뒤 erase로 실제 삭제하는 패턴입니다.
2. 알고리즘과 컨테이너의 역할이 분리되어 있기 때문입니다.

3. 삭제 대상이 아닌 원소들을 앞으로 이동시킵니다.
4. 삭제 후 유효한 구간의 끝 iterator입니다.

5. 컨테이너에서 실제로 원소를 제거합니다.
6. size가 줄지 않고 쓰레기 값이 남습니다.

7. vector, deque처럼 연속 메모리 컨테이너입니다.
8. 아니요, list는 자체 remove가 실제 삭제까지 수행합니다.

9. 조건 기반으로 삭제해야 할 때입니다.
10. true를 반환하는 원소가 삭제 대상입니다.

11. remove가 O(N), erase가 O(N)입니다.
12. 중간 삭제가 불가능한 연속 메모리 구조이기 때문입니다.

13. 원소가 남아 있거나 size가 줄지 않는 논리적 버그입니다.
14. erase–remove는 “이동 후 삭제” 패턴입니다.

</div>
</details>

