---
title: 
date: 2026-01-10 21:33:01 +09:00
categories: [면접준비, STL]
published: false
tags:
    [면접준비]
---

# 🧠 C++ std::set / std::multiset 사용 사례 면접 질문 리스트

## ✅ 기본 개념

1. std::set과 std::multiset의 차이는 무엇인가요?

    - set은 같은 key를 중복해서 가질 수 없지만, multiset은 같은 key를 중복해서 저장할 수 있습니다.

2. 두 컨테이너의 내부 자료구조는 무엇인가요?

    - set은 레드블랙트리, multiset 또한 레드블랙트리로 예상됩니다.

## ✅ 중복 허용 여부

1. std::set은 중복 원소를 어떻게 처리하나요?

    - 존재한다면 insert하려는 요소를 버립니다.

2. std::multiset은 어떤 경우에 필요한가요?

    - 정렬된 상태에서 중복된 값들을 관리해야 할 때 사용합니다.

## ✅ 정렬 / 탐색 특성

1. set과 multiset은 어떤 기준으로 정렬되나요?

    - key를 기준으로 오버로딩 된 비교 연산자로 정렬됩니다.

2. lower_bound / upper_bound는 어떤 상황에서 유용한가요?

    - 정렬된 상태에서 탐색하고자 하는 원소에 가장 가까운 낮은/높은 부분을 반환해줍니다. 

## ✅ 대표적인 사용 사례

1. std::set을 사용하는 대표적인 상황은 언제인가요?

    - 중복된 원소를 제거하는데 사용합니다.

2. std::multiset을 사용하는 대표적인 상황은 언제인가요?

    - 정렬된 상태에서 중복된 값들을 관리해야 할 때 사용합니다.

3. 빈도(count)가 중요한 경우 어떤 컨테이너가 더 적절한가요?

    - muliset이 적절합니다.

## ✅ 성능 특성

1. 삽입·삭제·탐색의 시간 복잡도는 어떻게 되나요?

    - O(logN)입니다.

2. set/multiset이 vector보다 느린 이유는 무엇인가요?

    - vector는 임의 접근이 가능하며 연속된 메모리이기 때문에 빠르지만, 내부적으로 정렬된 상태를 유지해야하는 set/과 multiset은 부과적인 동작과 포인터 순회때문에 느립니다.

## ✅ iterator / 삭제 동작

1. set과 multiset에서 erase 동작의 차이는 무엇인가요?

    - set은 erase(key)로 해당 키 하나만 삭제합니다. multiset은 erase(key)로 해당 키의 모든 인스턴스를 삭제하고, erase(iterator)로 하나만 삭제할 수 있습니다.

2. multiset에서 특정 값 하나만 삭제하려면 어떻게 하나요?

    - iterator를 사용해 하나만 erase합니다. 예: `auto it = ms.find(value); if (it != ms.end()) ms.erase(it);`

## ✅ 설계 판단

1. set 대신 unordered_set을 쓰는 것이 더 좋은 경우는 언제인가요?

    - 더빠른 삽입, 삭제, 접근이 필요하고 메모리가 여유롭다면 unordered_set을 사용하는것이 좋습니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. set은 중복을 허용하지 않고, multiset은 중복을 허용합니다.
2. 둘 다 보통 레드-블랙 트리 기반입니다.

3. 동일한 값의 삽입을 거부합니다.
4. 동일한 값이 여러 번 등장하는 데이터를 정렬 상태로 관리해야 할 때입니다.

5. key 비교 연산자(`<`) 기준으로 자동 정렬됩니다.
6. 특정 값 범위 탐색이 필요할 때 유용합니다.

7. 유일한 값 집합을 정렬된 상태로 유지해야 할 때입니다.
8. 정렬된 상태에서 값의 중복 개수가 의미를 가질 때입니다.
9. multiset이 더 적절합니다.

10. 삽입·삭제·탐색 모두 O(log N)입니다.
11. 연속 메모리가 아니고 포인터 기반 구조이기 때문입니다.

12. set은 erase(key)로 해당 키 하나만 삭제합니다. multiset은 erase(key)로 해당 키의 모든 인스턴스를 삭제하고, erase(iterator)로 하나만 삭제할 수 있습니다.
13. iterator를 사용해 하나만 erase합니다. 예: `auto it = ms.find(value); if (it != ms.end()) ms.erase(it);`

14. 순서가 필요 없고 평균 성능이 중요할 때입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 대표적인 사용 사례

**질문 1: std::set을 사용하는 대표적인 상황은 언제인가요?**
- **현재 답변**: "중복된 원소를 제거하는데 사용합니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 포괄적인 사용 사례를 제시할 수 있습니다.
  - ✅ **정확한 답변**: "유일한 값 집합을 정렬된 상태로 유지해야 할 때입니다."
  - 중복 제거뿐만 아니라 정렬된 상태 유지가 중요한 사용 사례입니다.

### ✅ 성능 특성

**질문 2: set/multiset이 vector보다 느린 이유는 무엇인가요?**
- **현재 답변**: "vector는 임의 접근이 가능하며 연속된 메모리이기 때문에 빠르지만, 내부적으로 정렬된 상태를 유지해야하는 set/과 multiset은 부과적인 동작과 포인터 순회때문에 느립니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 정확한 표현이 가능합니다.
  - ✅ **정확한 답변**: "연속 메모리가 아니고 포인터 기반 구조이기 때문입니다."
  - "부과적인 동작"보다는 "포인터 기반 구조"가 더 정확한 표현입니다.

### ✅ iterator / 삭제 동작

**질문 1: set과 multiset에서 erase 동작의 차이는 무엇인가요?**
- **현재 답변**: "set은 erase(key)로 해당 키 하나만 삭제합니다. multiset은 erase(key)로 해당 키의 모든 인스턴스를 삭제하고, erase(iterator)로 하나만 삭제할 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 맞지만 iterator erase와 key erase의 차이를 더 명확히 설명해야 합니다.
  - ✅ **정확한 답변**: "set은 erase(key)로 해당 키 하나만 삭제합니다. multiset은 erase(key)로 해당 키의 모든 인스턴스를 삭제하고, erase(iterator)로 하나만 삭제할 수 있습니다."
  - iterator erase는 해당 요소 하나만 삭제하고, key erase는 해당 키의 모든 인스턴스를 삭제합니다.

**질문 2: multiset에서 특정 값 하나만 삭제하려면 어떻게 하나요?**
- **현재 답변**: "iterator를 사용해 하나만 erase합니다. 예: `auto it = ms.find(value); if (it != ms.end()) ms.erase(it);`"
- **피드백**: (정확한 답변 - 피드백 없음)

### 📊 전체 평가

**강점:**
- ✅ set과 multiset의 기본 차이를 정확히 이해하고 있습니다.
- ✅ 내부 자료구조를 정확히 이해하고 있습니다.
- ✅ 중복 처리 방식을 정확히 이해하고 있습니다.
- ✅ 시간 복잡도를 정확히 이해하고 있습니다.
- ✅ erase 동작의 차이를 기본적으로 이해하고 있습니다.

**개선 필요:**
- ⚠️ **부정확한 부분**:
  - set/multiset이 vector보다 느린 이유 설명이 부정확함 ("부과적인 동작" → "포인터 기반 구조")
- 💡 **개선이 필요한 부분**:
  - set 사용 사례의 포괄성 (중복 제거뿐만 아니라 정렬된 상태 유지)
  - erase 동작 차이 설명의 명확성 (iterator erase vs key erase)

**우선순위:**
1. **중간**: set/multiset이 vector보다 느린 이유 설명 보완 - 포인터 기반 구조로 인한 캐시 미스가 주요 원인입니다.
2. **중간**: erase 동작 차이 설명 보완 - iterator erase는 하나만 삭제하고, key erase는 모든 인스턴스를 삭제합니다.
3. **낮음**: set 사용 사례의 포괄성 - 정렬된 상태 유지가 중요한 사용 사례를 언급하면 좋습니다.

**특별 주의사항:**
- multiset에서 erase(key)는 해당 키의 모든 인스턴스를 삭제하고, erase(iterator)는 해당 요소 하나만 삭제합니다.
- set/multiset은 연속 메모리가 아니고 포인터 기반 구조이기 때문에 vector보다 느립니다.
- set은 유일한 값 집합을 정렬된 상태로 유지해야 할 때 사용합니다.
