# 🧠 Race Condition(경쟁 상태) 사례 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. Race Condition이란 무엇인가요?

    - 여러 스레드가 공유 자원에 대해 경합하여 잘못된 정보를 얻을 수 있는 상태를 말합니다.

2. Race Condition은 언제 발생하나요?

    - 상호 배제, 동기화를 하지 않았을 때 발생합니다.

## ✅ 대표적인 발생 사례 (핵심)

1. 공유 변수 증가 연산에서 Race Condition이 발생하는 이유는 무엇인가요?

    - 변수에 대한 증가 연산이 원자적이지 않기 때문입니다. 주소 접근, 값 증가, 저장의 순서 중 경합하면 race condition이 발생합니다.

2. 멀티스레드 환경에서 로그 카운터가 틀어지는 이유는 무엇인가요?

    - 로그 카운터를 증가시키기가 원자적 연산이 아니기 때문입니다.

3. 은행 계좌 잔액 예제가 Race Condition 사례로 자주 쓰이는 이유는 무엇인가요?

    - 계좌 인출이 하나의 연산처럼 느껴지지만 사실 잔액확인, 예금인출, 값 저장으로 나눠져있는 것이 race condition의 상황과 매우 닮았기 때문에 사용됩니다.

## ✅ 메모리 / 연산 단위 관점

1. 읽기-수정-쓰기(read-modify-write) 패턴이 위험한 이유는 무엇인가요?

    - 읽기는 위험요소가 없지만 쓰기가 동시에 여러 스레드가 접근한다면 동기화가 되어있지 않을 때 문제가 발생할 수 있습니다.

## ✅ 체크-후-사용(Time-of-Check to Time-of-Use)

1. TOCTOU 문제란 무엇인가요?

2. 파일 존재 여부 확인 후 생성하는 코드가 위험한 이유는 무엇인가요?

    - 파일 존재 여부 확인 후에 다른 스레드에서 이미 파일을 생성했을 수 있습니다. 따라서 파일 존재 여부 확인부터 생성까지 critical section으로 동기화가 필요합니다.

## ✅ 예방 / 해결

1. Race Condition과 Deadlock의 차이는 무엇인가요?

    - race condition은 공통된 자원을 경합하여 의도하지 않은 동작을 하는 경우입니다. 이를 해결하기 위해 동기화가 필요한데, 데드락이 동기화를 할 때 동기화 객체를 잘못 설계했을 때 발생하는 무한대기 상태를 의미합니ㅏㄷ.

2. Race Condition을 방지하는 기본적인 방법은 무엇인가요?

    - 동기화를 합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 실행 순서에 따라 결과가 달라지는 동시성 버그입니다.
2. 여러 실행 흐름이 공유 자원에 동시 접근할 때입니다.

3. 증가 연산이 원자적이지 않기 때문입니다.
4. 여러 스레드가 동시에 값을 갱신하기 때문입니다.
5. 읽기와 쓰기가 분리되어 있기 때문입니다.

6. 내부적으로 load → add → store로 나뉘기 때문입니다.
7. 중간에 다른 스레드가 끼어들 수 있기 때문입니다.

8. 검사 시점과 사용 시점이 분리된 경쟁 상태입니다.
9. 상태가 바뀔 수 있기 때문입니다.

12. Race Condition은 잘못된 결과, Deadlock은 진행 불가 상태입니다.
13. mutex, atomic, lock-free 구조 사용입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: Race Condition이란 무엇인가요?**
- **현재 답변**: "여러 스레드가 공유 자원에 대해 경합하여 잘못된 정보를 얻을 수 있는 상태를 말합니다."
- **피드백**:
  - ⚠️ **부정확**: "잘못된 정보를 얻을 수 있는 상태"보다는 "실행 순서에 따라 결과가 달라지는 동시성 버그"가 더 정확합니다.
  - ✅ **정확한 답변**: "실행 순서에 따라 결과가 달라지는 동시성 버그입니다."
  - 💡 **보완**: Race Condition은 여러 스레드가 공유 자원에 동시 접근할 때, 실행 순서에 따라 결과가 달라지는 동시성 버그입니다. "잘못된 정보"뿐만 아니라 예상치 못한 동작이나 데이터 불일치를 유발할 수 있습니다.

**질문 2: Race Condition은 언제 발생하나요?**
- **현재 답변**: "상호 배제, 동기화를 하지 않았을 때 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "상호 배제, 동기화를 하지 않았을 때"보다는 "여러 실행 흐름이 공유 자원에 동시 접근할 때"가 더 정확합니다.
  - ✅ **정확한 답변**: "여러 실행 흐름이 공유 자원에 동시 접근할 때입니다."
  - 💡 **보완**: Race Condition은 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때 발생합니다. 동기화 메커니즘(mutex, semaphore 등)을 사용하지 않으면 발생할 수 있습니다.

### ✅ 대표적인 발생 사례 (핵심)

**질문 1: 공유 변수 증가 연산에서 Race Condition이 발생하는 이유는 무엇인가요?**
- **현재 답변**: "변수에 대한 증가 연산이 원자적이지 않기 때문입니다. 주소 접근, 값 증가, 저장의 순서 중 경합하면 race condition이 발생합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "내부적으로 load → add → store로 나뉘기 때문입니다"라고 표현하면 더 명확합니다.

**질문 2: 멀티스레드 환경에서 로그 카운터가 틀어지는 이유는 무엇인가요?**
- **현재 답변**: "로그 카운터를 증가시키기가 원자적 연산이 아니기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: "원자적 연산이 아니기 때문"만 언급했지만, "여러 스레드가 동시에 값을 갱신"하는 것이 핵심입니다.
  - ✅ **정확한 답변**: "여러 스레드가 동시에 값을 갱신하기 때문입니다."
  - 💡 **보완**: 로그 카운터 증가 연산이 원자적이지 않아 여러 스레드가 동시에 값을 읽고 수정하고 쓰는 과정에서 경합이 발생합니다.

**질문 3: 은행 계좌 잔액 예제가 Race Condition 사례로 자주 쓰이는 이유는 무엇인가요?**
- **현재 답변**: "계좌 인출이 하나의 연산처럼 느껴지지만 사실 잔액확인, 예금인출, 값 저장으로 나눠져있는 것이 race condition의 상황과 매우 닮았기 때문에 사용됩니다."
- **피드백**:
  - ⚠️ **부정확**: "예금인출"은 오타이며, "읽기와 쓰기가 분리되어 있기 때문"이 더 정확합니다.
  - ✅ **정확한 답변**: "읽기와 쓰기가 분리되어 있기 때문입니다."
  - 💡 **보완**: 은행 계좌 잔액 확인과 인출이 하나의 연산처럼 보이지만, 실제로는 잔액 읽기와 잔액 쓰기가 분리되어 있어 Race Condition이 발생하기 쉽습니다.

### ✅ 메모리 / 연산 단위 관점

**질문 1: 읽기-수정-쓰기(read-modify-write) 패턴이 위험한 이유는 무엇인가요?**
- **현재 답변**: "읽기는 위험요소가 없지만 쓰기가 동시에 여러 스레드가 접근한다면 동기화가 되어있지 않을 때 문제가 발생할 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "읽기는 위험요소가 없다"는 설명이 부정확합니다. 읽기-수정-쓰기 패턴 전체가 위험한 이유는 중간에 다른 스레드가 끼어들 수 있기 때문입니다.
  - ✅ **정확한 답변**: "내부적으로 load → add → store로 나뉘기 때문입니다." / "중간에 다른 스레드가 끼어들 수 있기 때문입니다."
  - 💡 **보완**: 읽기-수정-쓰기 패턴은 내부적으로 load(읽기) → modify(수정) → store(쓰기)로 나뉩니다. 이 과정 중간에 다른 스레드가 끼어들어 같은 자원을 수정하면 이전 값이 덮어씌워질 수 있습니다.

### ✅ 체크-후-사용(Time-of-Check to Time-of-Use)

**질문 1: TOCTOU 문제란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다.
  - ✅ **정확한 답변**: "검사 시점과 사용 시점이 분리된 경쟁 상태입니다."
  - 💡 **보완**: TOCTOU(Time-of-Check to Time-of-Use)는 검사 시점과 사용 시점 사이에 상태가 변경될 수 있는 경쟁 상태입니다. 예: 파일 존재 여부를 확인한 후 사용하기 전에 다른 프로세스가 파일을 삭제하거나 생성할 수 있습니다.

**질문 2: 파일 존재 여부 확인 후 생성하는 코드가 위험한 이유는 무엇인가요?**
- **현재 답변**: "파일 존재 여부 확인 후에 다른 스레드에서 이미 파일을 생성했을 수 있습니다. 따라서 파일 존재 여부 확인부터 생성까지 critical section으로 동기화가 필요합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "상태가 바뀔 수 있기 때문입니다"라고 간결하게 표현할 수 있습니다.

### ✅ 예방 / 해결

**질문 1: Race Condition과 Deadlock의 차이는 무엇인가요?**
- **현재 답변**: "race condition은 공통된 자원을 경합하여 의도하지 않은 동작을 하는 경우입니다. 이를 해결하기 위해 동기화가 필요한데, 데드락이 동기화를 할 때 동기화 객체를 잘못 설계했을 때 발생하는 무한대기 상태를 의미합니ㅏㄷ."
- **피드백**:
  - ⚠️ **부정확**: "합니ㅏㄷ"는 오타입니다. 또한 핵심 차이를 명확히 제시해야 합니다.
  - ✅ **정확한 답변**: "Race Condition은 잘못된 결과, Deadlock은 진행 불가 상태입니다."
  - 💡 **보완**: 
    - Race Condition: 공유 자원에 동시 접근하여 잘못된 결과나 예상치 못한 동작이 발생. 프로그램은 진행되지만 결과가 잘못됨.
    - Deadlock: 여러 프로세스가 서로의 자원을 기다리며 영원히 진행하지 못하는 상태. 프로그램이 멈춤.

**질문 2: Race Condition을 방지하는 기본적인 방법은 무엇인가요?**
- **현재 답변**: "동기화를 합니다."
- **피드백**:
  - ⚠️ **부정확**: 너무 모호합니다. 구체적인 방법을 명시해야 합니다.
  - ✅ **정확한 답변**: "mutex, atomic, lock-free 구조 사용입니다."
  - 💡 **보완**: Race Condition을 방지하는 방법:
    - mutex: 임계 구역에 대한 상호 배제 보장
    - atomic 연산: 원자적 연산을 사용하여 읽기-수정-쓰기를 원자적으로 수행
    - lock-free 구조: 락 없이 동시성을 보장하는 자료구조 사용

### 📊 전체 평가

**강점:**
- Race Condition의 기본 개념을 이해하고 있습니다.
- 공유 변수 증가 연산에서 Race Condition이 발생하는 이유를 알고 있습니다.
- 읽기-수정-쓰기 패턴의 위험성을 이해하고 있습니다.

**개선 필요:**
- ❌ TOCTOU 문제 답변 누락
- ⚠️ Race Condition 정의 설명 부정확 ("잘못된 정보" vs "실행 순서에 따라 결과가 달라짐")
- ⚠️ Race Condition 발생 시점 설명 부정확 ("동기화 안함" vs "공유 자원에 동시 접근")
- ⚠️ 로그 카운터 문제 설명 부족 ("여러 스레드가 동시에 갱신")
- ⚠️ 은행 계좌 예제 설명 오타 및 표현 부정확
- ⚠️ 읽기-수정-쓰기 패턴 위험성 설명 부정확 ("읽기는 위험 없음" vs "중간에 끼어들 수 있음")
- ⚠️ Race Condition과 Deadlock 차이 설명 오타 및 부정확
- ⚠️ Race Condition 방지 방법 설명 모호 (구체적 방법 명시 필요)

**우선순위:**
1. **높음**: TOCTOU 문제 답변 작성
2. **높음**: Race Condition 정의 명확화 (실행 순서에 따라 결과가 달라짐)
3. **높음**: Race Condition 방지 방법 구체화 (mutex, atomic, lock-free)
4. **중간**: Race Condition과 Deadlock 차이 명확화
5. **중간**: 읽기-수정-쓰기 패턴 위험성 설명 수정
6. **낮음**: 표현 정확성 개선 (오타 수정)

**특별 주의사항:**
- Race Condition은 "실행 순서에 따라 결과가 달라지는 동시성 버그"입니다. 여러 실행 흐름이 공유 자원에 동시 접근할 때 발생합니다.
- 읽기-수정-쓰기 패턴은 내부적으로 load → modify → store로 나뉘어 중간에 다른 스레드가 끼어들 수 있어 위험합니다.
- TOCTOU(Time-of-Check to Time-of-Use)는 검사 시점과 사용 시점 사이에 상태가 변경될 수 있는 경쟁 상태입니다.
- Race Condition과 Deadlock의 차이: Race Condition은 잘못된 결과를 유발하지만 프로그램은 진행되고, Deadlock은 진행 불가 상태입니다.
- Race Condition 방지 방법: mutex(상호 배제), atomic 연산(원자적 연산), lock-free 구조(락 없이 동시성 보장)를 사용합니다.
