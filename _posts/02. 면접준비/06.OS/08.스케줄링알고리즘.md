# 🧠 스케줄링 알고리즘 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 프로세스 스케줄링이란 무엇인가요?

    - cpu의 코어에 프로세스를 할당하는 순서를 결정하는 시스템입니다.

2. 스케줄링 알고리즘이 필요한 이유는 무엇인가요?

    - 빠르게 cpu가 필요한 작업과, 오래 걸려도 상관없는 작업이 분리되는 최적화 측면도 존재하고, 프로세스는 상태를 가지기 때문에 프로세스의 대기 상태 중 어떤 프로세스를 cpu에 점유시킬지 결정해야 합니다.

## ✅ FCFS (First Come First Served)

1. FCFS 알고리즘이란 무엇인가요?

    - FCFS는 가장 먼저 들어온 프로세스를 가장 먼저 cpu에 할당합니다.

2. FCFS의 장단점은 무엇인가요?

    - 장점으로는 순서대로 할당되기 때문에 구현이 쉽고, 어떻게 보면 프로세스 관점에서 공평하다고 볼 수도 있지만, 단점으로 너무 구현이 단순하여 급하게 cpu를 필요로 하는 프로세스가 늦게 할당받게 되며 선점형 스케줄링이라서 악의적인 프로세스로 다른 프로세스들이 기아상태가 될 수 있습니다.

3. FCFS에서 발생할 수 있는 문제는 무엇인가요?

    - 하나의 프로세스가 cpu점유를 놓지 않으면 계속 점유하여 다른 프로세스들이 기아상태가 됩니다.

## ✅ SJF (Shortest Job First)

1. SJF 알고리즘이란 무엇인가요?

    - 가장 끝나는데 짧게 걸리는 프로세스를 먼저 점유시키는 스케줄링 알고리즘입니다.

2. SJF의 장단점은 무엇인가요?

    - 장점은 비선점형 알고리즘이며 금방 끝날 수 있는 프로세스들은 항상 cpu를 할당받을 수 있습니다. 그러나 단점으로 지속적인 짧은 점유 프로세스가 들어온다면 오래걸리는 프로세스는 기아상태가 되는 문제가 존재합니다.

3. SJF의 구현 난이도는 어떻게 되나요?

    - 구현할 수 없습니다. 끝나는데 걸리는 시간을 예측할 수 없기 때문입니다.

## ✅ Round Robin

1. Round Robin 알고리즘이란 무엇인가요?

    - 비선점형 알고리즘을 타임슬라이스라는 변수를 두고, cpu를 점유하고 있는 프로세스가 점유하고 있는 시간이 타임슬라이스보다 커지는 순간 ready 상태로 돌립니다. 

2. 타임 슬라이스(Time Slice)란 무엇인가요?

    - 하나의 프로세스가 최대로 cpu에게 할당받을 수 있는 시간입니다.

3. 타임 슬라이스 크기가 성능에 미치는 영향은 무엇인가요?

    - 타임 슬라이스가 너무 커진다면 FCFS 알고리즘과 같아지고, 타임 슬라이스가 너무 작아진다면 지속적인 컨텍스트 스위칭이 발생하여 제대로된 진행이 어렵습니다. 따라서 적절한 크기 설정이 성능에 많은 영향을 미칩니다.

## ✅ Priority Scheduling

1. Priority Scheduling이란 무엇인가요?

    - 우선순위 큐를 두고, 프로세스별로 우선순위를 매겨 높은 우선순위 큐에 프로세스가 들어있다면 해당 큐에선 FIFO순서로 cpu를 점유하게 됩니다.

2. 우선순위가 높은 프로세스만 실행되면 어떤 문제가 발생하나요?

    - 우선순위가 낮은 프로세스들이 기아상태가 됩니다. 이를 해결하기위해 aging 기법이 나왔습니다.

3. Aging이란 무엇이며 왜 필요한가요?

    - 우선순위가 낮은 프로세스의 기아 상태를 방지하기 위해 등장한 개념입니다. 프로세스가 run이 되지 못하고 대기 queue에 일정시간 대기하고 있다면 우선순위를 높이는 시스템입니다. 이로써 기아 상태를 방지합니다.

## ✅ 실무 / 현대 OS

1. 현대 OS는 주로 어떤 스케줄링 알고리즘을 사용하나요?

    - 현재는 멀티레벨 큐를 사용합니다.

2. 멀티레벨 큐(Multi-level Queue)란 무엇인가요?

    - 우선순위 큐 알고리즘에서 우선순위를 여러 단계로 분할하여 관리하는 것입니다.

## ✅ 요약 질문

1. 스케줄링 알고리즘을 한 문장으로 요약해보세요.

    - 프로세스를 cpu에 할당하는 방법론입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. CPU를 사용할 프로세스를 선택하는 OS의 작업입니다.
2. 여러 프로세스가 CPU를 공유할 때 공정하고 효율적으로 배분하기 위해서입니다.

### ✅ FCFS (First Come First Served)

3. 도착 순서대로 실행하는 비선점 스케줄링입니다.
4. 장점: 구현이 간단하고 공정함. 단점: 긴 작업이 짧은 작업을 블로킹함.
5. Convoy Effect로 평균 대기 시간이 길어질 수 있습니다.

### ✅ SJF (Shortest Job First)

6. 실행 시간이 짧은 작업을 우선 실행하는 알고리즘입니다.
7. 장점: 평균 대기 시간 최소. 단점: 긴 작업이 기아 상태가 될 수 있음.
8. 실행 시간을 미리 알아야 하므로 구현이 어렵습니다.

### ✅ Round Robin

9. 각 프로세스에 동일한 시간을 할당하고 순환 실행하는 선점 스케줄링입니다.
10. 프로세스가 CPU를 사용할 수 있는 최대 시간입니다.
11. 작으면 컨텍스트 스위칭이 많아지고, 크면 응답성이 떨어집니다.

### ✅ Priority Scheduling

12. 우선순위가 높은 프로세스를 먼저 실행하는 알고리즘입니다.
13. 낮은 우선순위 프로세스가 영원히 실행되지 않는 기아 상태가 발생합니다.
14. 오래 대기한 프로세스의 우선순위를 점진적으로 높이는 기법입니다.

### ✅ 실무 / 현대 OS

18. 멀티레벨 피드백 큐나 CFS(Completely Fair Scheduler) 같은 복합 알고리즘입니다.
19. 프로세스 특성에 따라 여러 큐로 분류해 각각 다른 스케줄링을 적용하는 방식입니다.

### ✅ 요약 질문

20. 스케줄링 알고리즘은 "CPU를 사용할 프로세스를 선택하는 방법"입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 프로세스 스케줄링이란 무엇인가요?**
- **현재 답변**: "cpu의 코어에 프로세스를 할당하는 순서를 결정하는 시스템입니다."
- **피드백**:
  - ⚠️ **부정확**: "순서를 결정하는 시스템"보다는 "CPU를 사용할 프로세스를 선택하는 OS의 작업"이 더 정확합니다.
  - ✅ **정확한 답변**: "CPU를 사용할 프로세스를 선택하는 OS의 작업입니다."
  - 💡 **보완**: 프로세스 스케줄링은 운영체제가 여러 프로세스 중에서 CPU를 사용할 프로세스를 선택하는 작업입니다. 순서뿐만 아니라 우선순위, 공정성, 효율성 등을 고려합니다.

**질문 2: 스케줄링 알고리즘이 필요한 이유는 무엇인가요?**
- **현재 답변**: "빠르게 cpu가 필요한 작업과, 오래 걸려도 상관없는 작업이 분리되는 최적화 측면도 존재하고, 프로세스는 상태를 가지기 때문에 프로세스의 대기 상태 중 어떤 프로세스를 cpu에 점유시킬지 결정해야 합니다."
- **피드백**:
  - ⚠️ **부정확**: 핵심인 "여러 프로세스가 CPU를 공유할 때 공정하고 효율적으로 배분"이 누락되었습니다.
  - ✅ **정확한 답변**: "여러 프로세스가 CPU를 공유할 때 공정하고 효율적으로 배분하기 위해서입니다."
  - 💡 **보완**: 스케줄링 알고리즘이 필요한 이유는 여러 프로세스가 CPU를 공유할 때 공정하고 효율적으로 배분하기 위함입니다. 빠른 응답성, 높은 처리량, 공정성 등을 달성하기 위해 필요합니다.

### ✅ FCFS (First Come First Served)

**질문 1: FCFS 알고리즘이란 무엇인가요?**
- **현재 답변**: "FCFS는 가장 먼저 들어온 프로세스를 가장 먼저 cpu에 할당합니다."
- **피드백**:
  - ⚠️ **부정확**: "비선점 스케줄링"이라는 특성이 누락되었습니다.
  - ✅ **정확한 답변**: "도착 순서대로 실행하는 비선점 스케줄링입니다."
  - 💡 **보완**: FCFS는 도착 순서대로 실행하는 비선점 스케줄링입니다. 먼저 도착한 프로세스가 완료될 때까지 CPU를 점유합니다.

**질문 2: FCFS의 장단점은 무엇인가요?**
- **현재 답변**: "장점으로는 순서대로 할당되기 때문에 구현이 쉽고, 어떻게 보면 프로세스 관점에서 공평하다고 볼 수도 있지만, 단점으로 너무 구현이 단순하여 급하게 cpu를 필요로 하는 프로세스가 늦게 할당받게 되며 선점형 스케줄링이라서 악의적인 프로세스로 다른 프로세스들이 기아상태가 될 수 있습니다."
- **피드백**:
  - ❌ **오개념**: "선점형 스케줄링"이라는 설명이 잘못되었습니다. FCFS는 비선점 스케줄링입니다.
  - ⚠️ **부정확**: "급하게 cpu를 필요로 하는 프로세스"보다는 "긴 작업이 짧은 작업을 블로킹"이 더 정확합니다.
  - ✅ **정확한 답변**: "장점: 구현이 간단하고 공정함. 단점: 긴 작업이 짧은 작업을 블로킹함."
  - 💡 **보완**: FCFS의 장점은 구현이 간단하고 공정하다는 것입니다. 단점은 긴 작업이 짧은 작업을 블로킹하여 평균 대기 시간이 길어질 수 있다는 것입니다(Convoy Effect).

**질문 3: FCFS에서 발생할 수 있는 문제는 무엇인가요?**
- **현재 답변**: "하나의 프로세스가 cpu점유를 놓지 않으면 계속 점유하여 다른 프로세스들이 기아상태가 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "기아상태"보다는 "Convoy Effect로 평균 대기 시간이 길어짐"이 더 정확합니다.
  - ✅ **정확한 답변**: "Convoy Effect로 평균 대기 시간이 길어질 수 있습니다."
  - 💡 **보완**: FCFS에서 긴 작업이 먼저 실행되면 짧은 작업들이 오래 기다려야 하는 Convoy Effect가 발생합니다. 이로 인해 평균 대기 시간이 길어집니다.

### ✅ SJF (Shortest Job First)

**질문 1: SJF 알고리즘이란 무엇인가요?**
- **현재 답변**: "가장 끝나는데 짧게 걸리는 프로세스를 먼저 점유시키는 스케줄링 알고리즘입니다."
- **피드백**:
  - ⚠️ **부정확**: "가장 끝나는데 짧게 걸리는"보다는 "실행 시간이 짧은 작업을 우선 실행"이 더 정확합니다.
  - ✅ **정확한 답변**: "실행 시간이 짧은 작업을 우선 실행하는 알고리즘입니다."
  - 💡 **보완**: SJF는 실행 시간이 짧은 작업을 우선 실행하는 알고리즘입니다. 평균 대기 시간을 최소화할 수 있습니다.

**질문 2: SJF의 장단점은 무엇인가요?**
- **현재 답변**: "장점은 비선점형 알고리즘이며 금방 끝날 수 있는 프로세스들은 항상 cpu를 할당받을 수 있습니다. 그러나 단점으로 지속적인 짧은 점유 프로세스가 들어온다면 오래걸리는 프로세스는 기아상태가 되는 문제가 존재합니다."
- **피드백**:
  - ⚠️ **부정확**: "비선점형 알고리즘"이라는 설명이 부정확합니다. SJF는 비선점형과 선점형(SRTF) 모두 가능합니다. 또한 "금방 끝날 수 있는 프로세스들은 항상 cpu를 할당받을 수 있습니다"보다는 "평균 대기 시간 최소"가 더 정확합니다.
  - ✅ **정확한 답변**: "장점: 평균 대기 시간 최소. 단점: 긴 작업이 기아 상태가 될 수 있음."
  - 💡 **보완**: SJF의 장점은 평균 대기 시간을 최소화할 수 있다는 것입니다. 단점은 지속적으로 짧은 작업이 들어오면 긴 작업이 영원히 실행되지 못하는 기아 상태가 발생할 수 있습니다.

**질문 3: SJF의 구현 난이도는 어떻게 되나요?**
- **현재 답변**: "구현할 수 없습니다. 끝나는데 걸리는 시간을 예측할 수 없기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: "구현할 수 없습니다"보다는 "구현이 어렵습니다"가 더 정확합니다. 실행 시간을 미리 알아야 하므로 실제로는 예측 기반으로 구현합니다.
  - ✅ **정확한 답변**: "실행 시간을 미리 알아야 하므로 구현이 어렵습니다."
  - 💡 **보완**: SJF는 실행 시간을 미리 알아야 하므로 실제 구현이 어렵습니다. 과거 실행 시간을 기반으로 예측하거나, 사용자 입력을 기반으로 추정해야 합니다.

### ✅ Round Robin

**질문 1: Round Robin 알고리즘이란 무엇인가요?**
- **현재 답변**: "비선점형 알고리즘을 타임슬라이스라는 변수를 두고, cpu를 점유하고 있는 프로세스가 점유하고 있는 시간이 타임슬라이스보다 커지는 순간 ready 상태로 돌립니다."
- **피드백**:
  - ❌ **오개념**: "비선점형 알고리즘"이라는 설명이 잘못되었습니다. Round Robin은 선점형 스케줄링입니다.
  - ⚠️ **부정확**: "ready 상태로 돌립니다"보다는 "순환 실행"이 더 정확합니다.
  - ✅ **정확한 답변**: "각 프로세스에 동일한 시간을 할당하고 순환 실행하는 선점 스케줄링입니다."
  - 💡 **보완**: Round Robin은 각 프로세스에 동일한 타임 슬라이스를 할당하고 순환 실행하는 선점 스케줄링입니다. 타임 슬라이스가 만료되면 다음 프로세스로 전환됩니다.

**질문 2: 타임 슬라이스(Time Slice)란 무엇인가요?**
- **현재 답변**: "하나의 프로세스가 최대로 cpu에게 할당받을 수 있는 시간입니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "프로세스가 CPU를 사용할 수 있는 최대 시간입니다"라고 표현하면 더 명확합니다.

**질문 3: 타임 슬라이스 크기가 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: "타임 슬라이스가 너무 커진다면 FCFS 알고리즘과 같아지고, 타임 슬라이스가 너무 작아진다면 지속적인 컨텍스트 스위칭이 발생하여 제대로된 진행이 어렵습니다. 따라서 적절한 크기 설정이 성능에 많은 영향을 미칩니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "작으면 컨텍스트 스위칭이 많아지고, 크면 응답성이 떨어집니다"라고 간결하게 표현할 수 있습니다.

### ✅ Priority Scheduling

**질문 1: Priority Scheduling이란 무엇인가요?**
- **현재 답변**: "우선순위 큐를 두고, 프로세스별로 우선순위를 매겨 높은 우선순위 큐에 프로세스가 들어있다면 해당 큐에선 FIFO순서로 cpu를 점유하게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "우선순위 큐를 두고"보다는 "우선순위가 높은 프로세스를 먼저 실행"이 더 간결하고 정확합니다.
  - ✅ **정확한 답변**: "우선순위가 높은 프로세스를 먼저 실행하는 알고리즘입니다."
  - 💡 **보완**: Priority Scheduling은 우선순위가 높은 프로세스를 먼저 실행하는 알고리즘입니다. 같은 우선순위 내에서는 FIFO 순서로 실행할 수 있습니다.

**질문 2: 우선순위가 높은 프로세스만 실행되면 어떤 문제가 발생하나요?**
- **현재 답변**: "우선순위가 낮은 프로세스들이 기아상태가 됩니다. 이를 해결하기위해 aging 기법이 나왔습니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "낮은 우선순위 프로세스가 영원히 실행되지 않는 기아 상태가 발생합니다"라고 표현하면 더 명확합니다.

**질문 3: Aging이란 무엇이며 왜 필요한가요?**
- **현재 답변**: "우선순위가 낮은 프로세스의 기아 상태를 방지하기 위해 등장한 개념입니다. 프로세스가 run이 되지 못하고 대기 queue에 일정시간 대기하고 있다면 우선순위를 높이는 시스템입니다. 이로써 기아 상태를 방지합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "오래 대기한 프로세스의 우선순위를 점진적으로 높이는 기법입니다"라고 간결하게 표현할 수 있습니다.

### ✅ 실무 / 현대 OS

**질문 1: 현대 OS는 주로 어떤 스케줄링 알고리즘을 사용하나요?**
- **현재 답변**: "현재는 멀티레벨 큐를 사용합니다."
- **피드백**:
  - ⚠️ **부정확**: "멀티레벨 큐"만 언급했지만, "멀티레벨 피드백 큐"나 "CFS(Completely Fair Scheduler)" 같은 복합 알고리즘을 사용합니다.
  - ✅ **정확한 답변**: "멀티레벨 피드백 큐나 CFS(Completely Fair Scheduler) 같은 복합 알고리즘입니다."
  - 💡 **보완**: 현대 OS는 단일 알고리즘이 아닌 멀티레벨 피드백 큐(Multi-level Feedback Queue)나 CFS(Completely Fair Scheduler) 같은 복합 알고리즘을 사용합니다. 프로세스 특성에 따라 동적으로 조정됩니다.

**질문 2: 멀티레벨 큐(Multi-level Queue)란 무엇인가요?**
- **현재 답변**: "우선순위 큐 알고리즘에서 우선순위를 여러 단계로 분할하여 관리하는 것입니다."
- **피드백**:
  - ⚠️ **부정확**: "우선순위를 여러 단계로 분할"보다는 "프로세스 특성에 따라 여러 큐로 분류해 각각 다른 스케줄링을 적용"이 더 정확합니다.
  - ✅ **정확한 답변**: "프로세스 특성에 따라 여러 큐로 분류해 각각 다른 스케줄링을 적용하는 방식입니다."
  - 💡 **보완**: 멀티레벨 큐는 프로세스를 특성(대화형, 배치 작업 등)에 따라 여러 큐로 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용하는 방식입니다. 멀티레벨 피드백 큐는 프로세스가 큐 간 이동할 수 있는 확장 버전입니다.

### ✅ 요약 질문

**질문 1: 스케줄링 알고리즘을 한 문장으로 요약해보세요.**
- **현재 답변**: "프로세스를 cpu에 할당하는 방법론입니다."
- **피드백**:
  - ⚠️ **부정확**: "할당하는 방법론"보다는 "CPU를 사용할 프로세스를 선택하는 방법"이 더 정확합니다.
  - ✅ **정확한 답변**: "스케줄링 알고리즘은 'CPU를 사용할 프로세스를 선택하는 방법'입니다."
  - 💡 **보완**: 스케줄링 알고리즘은 여러 프로세스 중에서 CPU를 사용할 프로세스를 선택하는 방법입니다. 공정성, 효율성, 응답성 등을 고려합니다.

### 📊 전체 평가

**강점:**
- 스케줄링 알고리즘의 기본 개념을 이해하고 있습니다.
- 각 알고리즘의 특징을 알고 있습니다.
- Aging 기법을 이해하고 있습니다.

**개선 필요:**
- ❌ FCFS가 선점형 스케줄링이라는 오개념
- ❌ Round Robin이 비선점형 스케줄링이라는 오개념
- ⚠️ 프로세스 스케줄링 정의 설명 부정확 ("순서 결정" vs "프로세스 선택")
- ⚠️ 스케줄링 알고리즘 필요성 설명 부족 (공정하고 효율적 배분)
- ⚠️ FCFS 정의 설명 부족 (비선점 스케줄링)
- ⚠️ FCFS 장단점 설명 오개념 및 부정확
- ⚠️ FCFS 문제 설명 부정확 ("기아상태" vs "Convoy Effect")
- ⚠️ SJF 정의 설명 부정확
- ⚠️ SJF 장단점 설명 부정확 (비선점형 언급, 평균 대기 시간 최소 누락)
- ⚠️ SJF 구현 난이도 설명 부정확 ("구현 불가" vs "구현 어려움")
- ⚠️ Round Robin 정의 설명 오개념 (비선점형 vs 선점형)
- ⚠️ Priority Scheduling 정의 설명 모호
- ⚠️ 현대 OS 스케줄링 알고리즘 설명 부족 (멀티레벨 피드백 큐, CFS)
- ⚠️ 멀티레벨 큐 정의 설명 부정확
- ⚠️ 요약 질문 표현 부정확

**우선순위:**
1. **높음**: FCFS와 Round Robin의 선점/비선점 오개념 수정
2. **높음**: 프로세스 스케줄링 정의 명확화
3. **높음**: FCFS 장단점 및 문제 설명 수정
4. **중간**: SJF 정의 및 장단점 설명 수정
5. **중간**: 현대 OS 스케줄링 알고리즘 설명 보완
6. **중간**: 멀티레벨 큐 정의 명확화
7. **낮음**: 표현 정확성 개선

**특별 주의사항:**
- FCFS는 비선점 스케줄링입니다. 선점형이 아닙니다.
- Round Robin은 선점 스케줄링입니다. 비선점형이 아닙니다.
- 프로세스 스케줄링은 "CPU를 사용할 프로세스를 선택하는 OS의 작업"입니다.
- FCFS의 주요 문제는 Convoy Effect로 평균 대기 시간이 길어지는 것입니다.
- SJF는 실행 시간을 미리 알아야 하므로 구현이 어렵지만, 평균 대기 시간을 최소화할 수 있습니다.
- 현대 OS는 멀티레벨 피드백 큐나 CFS 같은 복합 알고리즘을 사용합니다. 단순한 멀티레벨 큐가 아닙니다.
