# 🧠 컨텍스트 스위칭(Context Switching) 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 컨텍스트 스위칭이란 무엇인가요?

    - 컨텍스트 스위칭은 cpu 코어가 작업을 수행하는 프로세스나 스레드를 동시성을 제공하기 위해 상태를 저장하고 불러오는 것을 말합니다.

2. 컨텍스트 스위칭은 언제 발생하나요?

    - CPU 스케줄링의 time slice가 만료됐거나, I/O 호출, 예외, 모든 작업을 완료했을 경우 등 다른 실행 흐름을 로드할 때 발생합니다.
 
## ✅ 저장/복원 대상 (핵심)

1. 컨텍스트란 구체적으로 무엇을 의미하나요?

    - 레지스트 상태, 프로그램 카운터, 등의 정보를 의미합니다.

2. 컨텍스트 스위칭 시 어떤 정보가 저장되고 복원되나요?

    - 프로세스간의 스위칭시 PCB를, 스레드간 스위칭시 TCB를 저장하고 복원합니다. 둘 다 현재의 실행흐름을 기록하기 위한 정보들을 가집니다.

## ✅ 프로세스 vs 스레드

1. 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이는 무엇인가요?

    - 프로세스 컨텍스트 스위칭은 TLB를 초기화하고, PCB를 변경합니다. 스레드 컨텍스트 스위칭은 TLB를 초기화 할 필요 없이 TCB만 변경합니다.

2. 왜 프로세스 컨텍스트 스위칭이 더 비싼가요?

    - TLB를 플러시하고 다시 로드해야하기 때문에 프로세스 컨텍스트 스위칭이 비용이 비쌉니다.

## ✅ OS / 스케줄링 연계

1. 컨텍스트 스위칭은 누가 수행하나요?

    - os가 수행합니다.

2. 타임 슬라이스(Time Slice)와 컨텍스트 스위칭의 관계는 무엇인가요?

    - 선점형 정책 os에서 타임 슬라이스 기간만큼 cpu를 점유한다면 다른 실행흐름으로 변경시켜주는 컨텍스트 스위칭이 발생합니다.

## ✅ 성능 관점

1. 캐시 관점에서 컨텍스트 스위칭이 느려지는 이유는 무엇인가요?

    - 프로세스 컨텍스트 스위칭이 TLB를 플러시하기 때문에 캐시관점에서 스위칭이 느려집니다.

## ✅ 동기화 / 블로킹

1. 락 대기나 I/O 대기에서도 컨텍스트 스위칭이 발생하나요?

    - 발생합니다. 락과 IO 대기는 장기간의 대기가 필요하기 때문에 sleep 상태로 전환하며 컨텍스트 스위칭이 발생합니다.

2. busy-wait와 컨텍스트 스위칭의 관계는 무엇인가요?

    - 락 시스템을 구현할 때 key를 얻을 것으로 예측되는 시간이 컨텍스트 스위칭의 비용과 sleep 상태로 가는 것보다 빠르게 획득할 수 있다고 판단된다면 busy-wait을 사용하는 것을 권장합니다.

## ✅ 설계 판단

1. 컨텍스트 스위칭을 줄이기 위한 방법에는 무엇이 있나요?

    - 너무 많은 스레드를 사용하지 않는 것과, IO 요청 등의 최적화를 하는 방법이 있습니다.

2. 컨텍스트 스위칭이 너무 잦으면 어떤 문제가 발생하나요?

    - 캐시 성능이 떨어집니다.

## ✅ 요약 질문

1. 컨텍스트 스위칭을 한 문장으로 요약해보세요.

    - 컨텍스트 스위칭이란 실행 흐름을 다른 실행 흐름으로 변경하기 위해 PCB나 TCB를 변경하는 작업을 의미합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. CPU가 실행 중인 작업을 다른 작업으로 전환하는 과정입니다.
2. 타임 슬라이스 만료, I/O 대기, 락 대기, 우선순위 변경 시 발생합니다.

3. 실행을 재개하기 위해 필요한 CPU 상태 정보입니다.
4. 레지스터, 프로그램 카운터, 스택 포인터, 스케줄링 정보입니다.

5. 프로세스는 주소 공간까지 전환하고, 스레드는 실행 상태만 전환합니다.
6. 주소 공간 전환과 TLB 플러시가 필요하기 때문입니다.

7. 운영체제 커널의 스케줄러가 수행합니다.
8. 타임 슬라이스가 끝나면 스위칭이 발생할 수 있습니다.

9. 상태 저장/복원과 캐시 무효화 비용 때문입니다.
10. 캐시와 TLB가 비워져 캐시 미스가 증가하기 때문입니다.

11. 네, 블로킹 시 다른 작업으로 전환됩니다.
12. busy-wait는 스위칭을 줄이지만 CPU를 낭비합니다.

13. 작업 묶기, 스레드 수 제한, 락 경합 감소입니다.
14. CPU 시간을 실제 작업이 아닌 전환에 소비하게 됩니다.

15. 컨텍스트 스위칭은 "CPU 실행 주체를 바꾸는 비용 있는 전환"입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 컨텍스트 스위칭이란 무엇인가요?**
- **현재 답변**: "컨텍스트 스위칭은 cpu 코어가 작업을 수행하는 프로세스나 스레드를 동시성을 제공하기 위해 상태를 저장하고 불러오는 것을 말합니다."
- **피드백**:
  - ⚠️ **부정확**: "동시성을 제공하기 위해"라는 표현이 부정확합니다. 컨텍스트 스위칭은 멀티태스킹을 가능하게 하는 것이지, 동시성 자체를 제공하는 것은 아닙니다.
  - ✅ **정확한 답변**: "CPU가 실행 중인 작업을 다른 작업으로 전환하는 과정입니다."
  - 💡 **보완**: 컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 복원하여 실행을 전환하는 과정입니다.

**질문 2: 컨텍스트 스위칭은 언제 발생하나요?**
- **현재 답변**: "CPU 스케줄링의 time slice가 만료됐거나, I/O 호출, 예외, 모든 작업을 완료했을 경우 등 다른 실행 흐름을 로드할 때 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "예외"는 일반적인 발생 원인이 아닙니다. "우선순위 변경"이 더 중요한 원인입니다.
  - ✅ **정확한 답변**: "타임 슬라이스 만료, I/O 대기, 락 대기, 우선순위 변경 시 발생합니다."
  - 💡 **보완**: 컨텍스트 스위칭은 타임 슬라이스 만료, I/O 대기로 인한 블로킹, 락 대기, 우선순위 변경 등으로 발생합니다.

### ✅ 저장/복원 대상 (핵심)

**질문 1: 컨텍스트란 구체적으로 무엇을 의미하나요?**
- **현재 답변**: "레지스트 상태, 프로그램 카운터, 등의 정보를 의미합니다."
- **피드백**:
  - ⚠️ **부정확**: "레지스트"는 오타이며, "레지스터"가 정확합니다. 또한 스택 포인터, 스케줄링 정보 등도 포함해야 합니다.
  - ✅ **정확한 답변**: "실행을 재개하기 위해 필요한 CPU 상태 정보입니다."
  - 💡 **보완**: 컨텍스트는 실행을 재개하기 위해 필요한 CPU 상태 정보로, 레지스터, 프로그램 카운터, 스택 포인터, 스케줄링 정보 등을 포함합니다.

**질문 2: 컨텍스트 스위칭 시 어떤 정보가 저장되고 복원되나요?**
- **현재 답변**: "프로세스간의 스위칭시 PCB를, 스레드간 스위칭시 TCB를 저장하고 복원합니다. 둘 다 현재의 실행흐름을 기록하기 위한 정보들을 가집니다."
- **피드백**:
  - ⚠️ **부정확**: PCB/TCB에 저장되는 구체적인 정보를 명시해야 합니다.
  - ✅ **정확한 답변**: "레지스터, 프로그램 카운터, 스택 포인터, 스케줄링 정보입니다."
  - 💡 **보완**: 프로세스 컨텍스트 스위칭 시에는 PCB에 레지스터, 프로그램 카운터, 스택 포인터, 메모리 관리 정보, 스케줄링 정보 등이 저장됩니다. 스레드 컨텍스트 스위칭 시에는 TCB에 레지스터, 프로그램 카운터, 스택 포인터 등이 저장됩니다.

### ✅ 프로세스 vs 스레드

**질문 1: 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이는 무엇인가요?**
- **현재 답변**: "프로세스 컨텍스트 스위칭은 TLB를 초기화하고, PCB를 변경합니다. 스레드 컨텍스트 스위칭은 TLB를 초기화 할 필요 없이 TCB만 변경합니다."
- **피드백**:
  - ⚠️ **부정확**: "TLB를 초기화"보다는 "주소 공간 전환"이 더 정확한 표현입니다. TLB 플러시는 주소 공간 전환의 결과입니다.
  - ✅ **정확한 답변**: "프로세스는 주소 공간까지 전환하고, 스레드는 실행 상태만 전환합니다."
  - 💡 **보완**: 프로세스 컨텍스트 스위칭은 주소 공간(페이지 테이블)을 전환하고 TLB를 플러시합니다. 스레드 컨텍스트 스위칭은 같은 주소 공간을 사용하므로 주소 공간 전환이 필요 없고 실행 상태만 전환합니다.

**질문 2: 왜 프로세스 컨텍스트 스위칭이 더 비싼가요?**
- **현재 답변**: "TLB를 플러시하고 다시 로드해야하기 때문에 프로세스 컨텍스트 스위칭이 비용이 비쌉니다."
- **피드백**:
  - ⚠️ **부정확**: TLB 플러시만 언급했지만, 주소 공간 전환이 핵심입니다.
  - ✅ **정확한 답변**: "주소 공간 전환과 TLB 플러시가 필요하기 때문입니다."
  - 💡 **보완**: 프로세스 컨텍스트 스위칭은 주소 공간(페이지 테이블)을 전환해야 하므로 TLB를 플러시하고 새로운 주소 공간의 페이지 테이블을 로드해야 합니다. 이는 메모리 접근 비용을 증가시킵니다.

### ✅ OS / 스케줄링 연계

**질문 1: 컨텍스트 스위칭은 누가 수행하나요?**
- **현재 답변**: "os가 수행합니다."
- **피드백**:
  - 💡 **보완**: 정확하지만 "운영체제 커널의 스케줄러가 수행합니다"라고 표현하면 더 명확합니다.

**질문 2: 타임 슬라이스(Time Slice)와 컨텍스트 스위칭의 관계는 무엇인가요?**
- **현재 답변**: "선점형 정책 os에서 타임 슬라이스 기간만큼 cpu를 점유한다면 다른 실행흐름으로 변경시켜주는 컨텍스트 스위칭이 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "타임 슬라이스 기간만큼 cpu를 점유한다면"이라는 표현이 부정확합니다. "타임 슬라이스가 끝나면"이 정확합니다.
  - ✅ **정확한 답변**: "타임 슬라이스가 끝나면 스위칭이 발생할 수 있습니다."
  - 💡 **보완**: 선점형 스케줄링에서 타임 슬라이스(quantum)가 만료되면 스케줄러가 현재 실행 중인 프로세스를 선점하고 다른 프로세스로 컨텍스트 스위칭을 수행합니다.

### ✅ 성능 관점

**질문 1: 캐시 관점에서 컨텍스트 스위칭이 느려지는 이유는 무엇인가요?**
- **현재 답변**: "프로세스 컨텍스트 스위칭이 TLB를 플러시하기 때문에 캐시관점에서 스위칭이 느려집니다."
- **피드백**:
  - ⚠️ **부정확**: TLB 플러시만 언급했지만, 일반적인 캐시(L1, L2, L3) 무효화와 캐시 미스 증가도 중요합니다.
  - ✅ **정확한 답변**: "상태 저장/복원과 캐시 무효화 비용 때문입니다." / "캐시와 TLB가 비워져 캐시 미스가 증가하기 때문입니다."
  - 💡 **보완**: 컨텍스트 스위칭 시 상태를 저장/복원하는 비용과, 새로운 프로세스/스레드로 전환되면서 기존 캐시와 TLB가 무효화되어 캐시 미스가 증가합니다. 이로 인해 메모리 접근이 느려집니다.

### ✅ 동기화 / 블로킹

**질문 1: 락 대기나 I/O 대기에서도 컨텍스트 스위칭이 발생하나요?**
- **현재 답변**: "발생합니다. 락과 IO 대기는 장기간의 대기가 필요하기 때문에 sleep 상태로 전환하며 컨텍스트 스위칭이 발생합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "블로킹 시 다른 작업으로 전환됩니다"라고 표현하면 더 명확합니다.

**질문 2: busy-wait와 컨텍스트 스위칭의 관계는 무엇인가요?**
- **현재 답변**: "락 시스템을 구현할 때 key를 얻을 것으로 예측되는 시간이 컨텍스트 스위칭의 비용과 sleep 상태로 가는 것보다 빠르게 획득할 수 있다고 판단된다면 busy-wait을 사용하는 것을 권장합니다."
- **피드백**:
  - ⚠️ **부정확**: "key를 얻을 것으로 예측되는 시간"이라는 표현이 모호합니다. 핵심은 "락을 빠르게 획득할 수 있을 때"입니다.
  - ✅ **정확한 답변**: "busy-wait는 스위칭을 줄이지만 CPU를 낭비합니다."
  - 💡 **보완**: busy-wait(스핀락)는 컨텍스트 스위칭 없이 CPU를 계속 사용하며 락을 기다립니다. 락을 빠르게 획득할 수 있을 때는 컨텍스트 스위칭 비용을 피할 수 있지만, 그렇지 않으면 CPU를 낭비합니다.

### ✅ 설계 판단

**질문 1: 컨텍스트 스위칭을 줄이기 위한 방법에는 무엇이 있나요?**
- **현재 답변**: "너무 많은 스레드를 사용하지 않는 것과, IO 요청 등의 최적화를 하는 방법이 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "IO 요청 등의 최적화"가 너무 모호합니다. 구체적인 방법을 명시해야 합니다.
  - ✅ **정확한 답변**: "작업 묶기, 스레드 수 제한, 락 경합 감소입니다."
  - 💡 **보완**: 컨텍스트 스위칭을 줄이기 위한 방법:
    - 작업 묶기: 관련 작업을 묶어서 처리
    - 스레드 수 제한: 과도한 스레드 생성 방지
    - 락 경합 감소: 락 사용 최소화, 락 그레인 최적화
    - I/O 최적화: 비동기 I/O, 배치 처리

**질문 2: 컨텍스트 스위칭이 너무 잦으면 어떤 문제가 발생하나요?**
- **현재 답변**: "캐시 성능이 떨어집니다."
- **피드백**:
  - ⚠️ **부정확**: 캐시 성능 저하만 언급했지만, 더 중요한 문제는 CPU 시간 낭비입니다.
  - ✅ **정확한 답변**: "CPU 시간을 실제 작업이 아닌 전환에 소비하게 됩니다."
  - 💡 **보완**: 컨텍스트 스위칭이 너무 잦으면:
    - CPU 시간이 실제 작업이 아닌 전환에 소비됨 (thrashing)
    - 캐시 성능 저하 (캐시 미스 증가)
    - 전체 시스템 성능 저하

### ✅ 요약 질문

**질문 1: 컨텍스트 스위칭을 한 문장으로 요약해보세요.**
- **현재 답변**: "컨텍스트 스위칭이란 실행 흐름을 다른 실행 흐름으로 변경하기 위해 PCB나 TCB를 변경하는 작업을 의미합니다."
- **피드백**:
  - ⚠️ **부정확**: "PCB나 TCB를 변경"보다는 "CPU 실행 주체를 바꾸는 비용 있는 전환"이 더 정확합니다.
  - ✅ **정확한 답변**: "컨텍스트 스위칭은 'CPU 실행 주체를 바꾸는 비용 있는 전환'입니다."
  - 💡 **보완**: 컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스나 스레드에서 다른 프로세스나 스레드로 전환하는 과정으로, 상태 저장/복원과 주소 공간 전환 등의 비용이 발생합니다.

### 📊 전체 평가

**강점:**
- 컨텍스트 스위칭의 기본 개념을 이해하고 있습니다.
- 프로세스와 스레드 컨텍스트 스위칭의 차이를 알고 있습니다.
- TLB 플러시가 비용에 영향을 준다는 것을 알고 있습니다.

**개선 필요:**
- ⚠️ 컨텍스트 스위칭 정의 설명 부정확 ("동시성 제공" vs "작업 전환")
- ⚠️ 컨텍스트 스위칭 발생 시점 설명 부정확 ("예외" vs "우선순위 변경")
- ⚠️ 컨텍스트 정의 설명 부정확 (오타, 구체적 정보 누락)
- ⚠️ 저장/복원 정보 설명 부족 (구체적 정보 명시 필요)
- ⚠️ 프로세스/스레드 스위칭 차이 설명 부정확 ("TLB 초기화" vs "주소 공간 전환")
- ⚠️ 프로세스 스위칭 비용 설명 부족 (주소 공간 전환)
- ⚠️ 타임 슬라이스 관계 설명 부정확
- ⚠️ 캐시 관점 성능 저하 설명 부족 (일반 캐시 무효화)
- ⚠️ busy-wait 관계 설명 모호
- ⚠️ 컨텍스트 스위칭 감소 방법 설명 모호
- ⚠️ 컨텍스트 스위칭 과다 시 문제 설명 부족 (CPU 시간 낭비)
- ⚠️ 요약 질문 표현 부정확

**우선순위:**
1. **높음**: 컨텍스트 스위칭 정의 명확화 (작업 전환)
2. **높음**: 프로세스/스레드 스위칭 차이 수정 (주소 공간 전환)
3. **높음**: 프로세스 스위칭 비용 설명 보완 (주소 공간 전환)
4. **중간**: 컨텍스트 정의 및 저장/복원 정보 구체화
5. **중간**: 캐시 관점 성능 저하 설명 보완
6. **중간**: 컨텍스트 스위칭 감소 방법 구체화
7. **낮음**: 표현 정확성 개선

**특별 주의사항:**
- 컨텍스트 스위칭은 "CPU 실행 주체를 바꾸는 비용 있는 전환"입니다. 멀티태스킹을 가능하게 하지만, 동시성 자체를 제공하는 것은 아닙니다.
- 프로세스 컨텍스트 스위칭은 주소 공간(페이지 테이블)을 전환하므로 TLB 플러시가 발생하고 비용이 큽니다. 스레드 컨텍스트 스위칭은 같은 주소 공간을 사용하므로 비용이 적습니다.
- 컨텍스트 스위칭 시 상태 저장/복원 비용과 캐시/TLB 무효화로 인한 캐시 미스 증가가 성능에 영향을 줍니다.
- 컨텍스트 스위칭이 너무 잦으면 CPU 시간이 실제 작업이 아닌 전환에 소비되어 시스템 성능이 저하됩니다(thrashing).
