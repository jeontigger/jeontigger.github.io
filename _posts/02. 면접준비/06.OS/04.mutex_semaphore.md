# 🧠 Mutex / Semaphore 차이 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. mutex란 무엇인가요?

    - mutex란 멀티스레드 환경에서 동기화를 위한 객체입니다. 락을 하는데 실패하면 sleep 상태로 갑니다. 락을 획득 후 unlock을 꼭 호출해야 합니다. 단일 책임 원칙입니다. 락을 획득한 스레드에서 락을 해제해야만 합니다.

2. semaphore란 무엇인가요?

    - 세마포어 또한 멀티스레드 환경의 동기화를 위한 객체입니다. 다중 책임 원칙으로 여러 스레드가 접근할 수 있는 카운트로 관리됩니다. 카운트가 0이 되면 더이상 접근할 수 없습니다. mutex와는 다르게 세마포어는 다른 스레드에서 카운트를 조절할 수 있어서, reader writer 패턴에 사용 가능합니다.

3. mutex와 semaphore의 핵심 차이는 무엇인가요?

    - 카운트를 증가시키는 책임이 누구에게 있는가가 가장 핵심 차이라고 생각합니다.

## ✅ 소유권 / 잠금 규칙

1. mutex는 어떤 소유권 규칙을 가지나요?

    - mutex는 단일 소유권 원칙을 가지고있습니다.

2. semaphore는 소유권 개념이 있나요?

    - semaphore는 소유권 개념이라기 보단 카운트 개념이 존재합니다.

## ✅ 카운트 개념

1. binary semaphore와 mutex의 차이는 무엇인가요?

    - mutex는 lock을 잡은 스레드에서 unlock을 해야만 하지만, binary semaphore는 lock을 하는 스레드와 unlock을 하는 스레드가 전혀 달라도 상관없습니다.

2. counting semaphore는 어떤 상황에서 사용되나요?

    - 주로 reader writer 패턴이나, producer consumer 패턴에 사용됩니다.

## ✅ 동작 방식

1. mutex lock/unlock은 어떻게 동작하나요?

    - lock을 획득할 수 있다면 획득 후 critical section에 접근할 수 있습니다. lock을 하고 있는 다른 스레드가 존재한다면 sleep 상태가 되어 대기합니다. unlock은 lock을 한 스레드가 critical section의 로직을 수행하고 난 후 호출하게 됩니다.

2. semaphore wait/signal은 어떻게 동작하나요?

    - wait()이 muetx의 lock처럼 count가 0보다 크기 전까지를 기다리는 것이고, signal은 count를 증가시키는 함수입니다.

## ✅ 사용 목적

1. mutex는 주로 어떤 문제를 해결하나요?

    - 주로 하나의 스레드만 접근할 수 있도록 합니다.

2. semaphore는 주로 어떤 문제를 해결하나요?

    - 주로 정해진 개수의 여러 스레드가 동시에 접근할 수 있도록 합니다.

## ✅ 오류 / 위험 요소

1. mutex 사용 시 발생할 수 있는 대표적인 문제는 무엇인가요?

    - deadlock이 발생할 수 있습니다. unlock을 안한다거나, 데드락의 발생조건 4가지를 만족한다면 deadlock이 발생하여 문제가 됩니다.

2. semaphore 사용 시 발생할 수 있는 대표적인 문제는 무엇인가요?

    - semaphore 또한 데드락이 발생하여 signal 호출을 못하는 구조가 될 수 있습니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 하나의 스레드만 임계 구역에 접근하도록 보장하는 락입니다.
2. 접근 가능한 개수를 카운트로 관리하는 동기화 도구입니다.
3. mutex는 소유권 기반, semaphore는 카운트 기반입니다.

4. 잠근 스레드만 unlock할 수 있습니다.
5. 없습니다.

6. binary semaphore는 소유권이 없고 mutex는 있습니다.
7. 제한된 자원 풀 접근을 제어할 때입니다.

8. lock 시 진입, unlock 시 해제합니다.
9. wait 시 감소, signal 시 증가합니다.

10. 공유 데이터 보호(상호 배제)입니다.
11. 자원 개수 제한과 작업 순서 제어입니다.

12. 데드락과 우선순위 역전입니다.
13. signal 누락이나 과도한 signal입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: mutex란 무엇인가요?**
- **현재 답변**: "mutex란 멀티스레드 환경에서 동기화를 위한 객체입니다. 락을 하는데 실패하면 sleep 상태로 갑니다. 락을 획득 후 unlock을 꼭 호출해야 합니다. 단일 책임 원칙입니다. 락을 획득한 스레드에서 락을 해제해야만 합니다."
- **피드백**:
  - ⚠️ **부정확**: "단일 책임 원칙"이라는 표현이 부정확합니다. "단일 소유권"이 정확합니다. 또한 핵심인 "하나의 스레드만 임계 구역에 접근"이 명확하지 않습니다.
  - ✅ **정확한 답변**: "하나의 스레드만 임계 구역에 접근하도록 보장하는 락입니다."
  - 💡 **보완**: mutex는 상호 배제(mutual exclusion)를 제공하는 락으로, 하나의 스레드만 임계 구역에 접근할 수 있도록 보장합니다. 락을 획득한 스레드만 unlock할 수 있습니다.

**질문 2: semaphore란 무엇인가요?**
- **현재 답변**: "세마포어 또한 멀티스레드 환경의 동기화를 위한 객체입니다. 다중 책임 원칙으로 여러 스레드가 접근할 수 있는 카운트로 관리됩니다. 카운트가 0이 되면 더이상 접근할 수 없습니다. mutex와는 다르게 세마포어는 다른 스레드에서 카운트를 조절할 수 있어서, reader writer 패턴에 사용 가능합니다."
- **피드백**:
  - ⚠️ **부정확**: "다중 책임 원칙"이라는 표현이 부정확합니다. "카운트 기반"이 정확합니다. 또한 "카운트가 0이 되면 더이상 접근할 수 없습니다"는 정확하지만, "카운트가 0보다 클 때까지 기다린다"가 더 정확합니다.
  - ✅ **정확한 답변**: "접근 가능한 개수를 카운트로 관리하는 동기화 도구입니다."
  - 💡 **보완**: semaphore는 접근 가능한 개수를 카운트로 관리하는 동기화 도구입니다. wait()는 카운트를 감소시키고, 카운트가 0보다 클 때까지 기다립니다. signal()은 카운트를 증가시킵니다.

**질문 3: mutex와 semaphore의 핵심 차이는 무엇인가요?**
- **현재 답변**: "카운트를 증가시키는 책임이 누구에게 있는가가 가장 핵심 차이라고 생각합니다."
- **피드백**:
  - ⚠️ **부정확**: "책임"이라는 표현이 모호합니다. 핵심 차이는 소유권 개념의 유무입니다.
  - ✅ **정확한 답변**: "mutex는 소유권 기반, semaphore는 카운트 기반입니다."
  - 💡 **보완**: mutex는 소유권 기반으로, 락을 획득한 스레드만 unlock할 수 있습니다. semaphore는 카운트 기반으로, 소유권 개념이 없어 어떤 스레드든 signal()을 호출할 수 있습니다.

### ✅ 소유권 / 잠금 규칙

**질문 1: mutex는 어떤 소유권 규칙을 가지나요?**
- **현재 답변**: "mutex는 단일 소유권 원칙을 가지고있습니다."
- **피드백**:
  - ⚠️ **부정확**: "단일 소유권 원칙"보다는 "잠근 스레드만 unlock할 수 있습니다"가 더 구체적입니다.
  - ✅ **정확한 답변**: "잠근 스레드만 unlock할 수 있습니다."
  - 💡 **보완**: mutex는 소유권 개념이 있어, lock()을 호출한 스레드만 unlock()을 호출할 수 있습니다. 다른 스레드가 unlock()을 시도하면 오류가 발생합니다.

**질문 2: semaphore는 소유권 개념이 있나요?**
- **현재 답변**: "semaphore는 소유권 개념이라기 보단 카운트 개념이 존재합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "없습니다"라고 간결하게 표현할 수 있습니다.

### ✅ 카운트 개념

**질문 1: binary semaphore와 mutex의 차이는 무엇인가요?**
- **현재 답변**: "mutex는 lock을 잡은 스레드에서 unlock을 해야만 하지만, binary semaphore는 lock을 하는 스레드와 unlock을 하는 스레드가 전혀 달라도 상관없습니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "binary semaphore는 소유권이 없고 mutex는 있습니다"라고 간결하게 표현할 수 있습니다.

**질문 2: counting semaphore는 어떤 상황에서 사용되나요?**
- **현재 답변**: "주로 reader writer 패턴이나, producer consumer 패턴에 사용됩니다."
- **피드백**:
  - ⚠️ **부정확**: reader writer 패턴은 보통 read-write lock을 사용합니다. counting semaphore는 주로 제한된 자원 풀 접근 제어에 사용됩니다.
  - ✅ **정확한 답변**: "제한된 자원 풀 접근을 제어할 때입니다."
  - 💡 **보완**: counting semaphore는 제한된 개수의 자원(예: 연결 풀, 스레드 풀)에 대한 접근을 제어할 때 사용됩니다. producer-consumer 패턴에서 버퍼 크기 제한에도 사용됩니다.

### ✅ 동작 방식

**질문 1: mutex lock/unlock은 어떻게 동작하나요?**
- **현재 답변**: "lock을 획득할 수 있다면 획득 후 critical section에 접근할 수 있습니다. lock을 하고 있는 다른 스레드가 존재한다면 sleep 상태가 되어 대기합니다. unlock은 lock을 한 스레드가 critical section의 로직을 수행하고 난 후 호출하게 됩니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "lock 시 진입, unlock 시 해제합니다"라고 간결하게 표현할 수 있습니다.

**질문 2: semaphore wait/signal은 어떻게 동작하나요?**
- **현재 답변**: "wait()이 muetx의 lock처럼 count가 0보다 크기 전까지를 기다리는 것이고, signal은 count를 증가시키는 함수입니다."
- **피드백**:
  - ⚠️ **부정확**: "muetx"는 오타입니다. 또한 wait()는 카운트를 감소시키는 것이 핵심입니다.
  - ✅ **정확한 답변**: "wait 시 감소, signal 시 증가합니다."
  - 💡 **보완**: semaphore의 wait()는 카운트를 1 감소시키고, 카운트가 0보다 클 때까지 기다립니다. signal()은 카운트를 1 증가시킵니다.

### ✅ 사용 목적

**질문 1: mutex는 주로 어떤 문제를 해결하나요?**
- **현재 답변**: "주로 하나의 스레드만 접근할 수 있도록 합니다."
- **피드백**:
  - ⚠️ **부정확**: "하나의 스레드만 접근"보다는 "공유 데이터 보호(상호 배제)"가 더 정확합니다.
  - ✅ **정확한 답변**: "공유 데이터 보호(상호 배제)입니다."
  - 💡 **보완**: mutex는 공유 데이터에 대한 동시 접근을 방지하여 데이터 일관성을 보장합니다. 상호 배제(mutual exclusion)를 제공합니다.

**질문 2: semaphore는 주로 어떤 문제를 해결하나요?**
- **현재 답변**: "주로 정해진 개수의 여러 스레드가 동시에 접근할 수 있도록 합니다."
- **피드백**:
  - ⚠️ **부정확**: "정해진 개수의 여러 스레드가 동시에 접근"보다는 "자원 개수 제한과 작업 순서 제어"가 더 포괄적입니다.
  - ✅ **정확한 답변**: "자원 개수 제한과 작업 순서 제어입니다."
  - 💡 **보완**: semaphore는 제한된 자원에 대한 접근을 제어하거나, 작업 간 순서를 제어할 때 사용됩니다(예: producer-consumer 패턴).

### ✅ 오류 / 위험 요소

**질문 1: mutex 사용 시 발생할 수 있는 대표적인 문제는 무엇인가요?**
- **현재 답변**: "deadlock이 발생할 수 있습니다. unlock을 안한다거나, 데드락의 발생조건 4가지를 만족한다면 deadlock이 발생하여 문제가 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "unlock을 안한다"는 것은 데드락이 아니라 락 누수입니다. 또한 우선순위 역전도 중요한 문제입니다.
  - ✅ **정확한 답변**: "데드락과 우선순위 역전입니다."
  - 💡 **보완**: mutex 사용 시 발생할 수 있는 문제:
    - 데드락: 여러 락을 순환 대기하는 경우
    - 우선순위 역전: 낮은 우선순위 스레드가 락을 잡고 있을 때 높은 우선순위 스레드가 대기하는 경우
    - 락 누수: unlock을 호출하지 않는 경우

**질문 2: semaphore 사용 시 발생할 수 있는 대표적인 문제는 무엇인가요?**
- **현재 답변**: "semaphore 또한 데드락이 발생하여 signal 호출을 못하는 구조가 될 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: 데드락만 언급했지만, signal 누락이나 과도한 signal도 중요한 문제입니다.
  - ✅ **정확한 답변**: "signal 누락이나 과도한 signal입니다."
  - 💡 **보완**: semaphore 사용 시 발생할 수 있는 문제:
    - signal 누락: wait() 후 signal()을 호출하지 않아 다른 스레드가 영구 대기
    - 과도한 signal: signal()을 너무 많이 호출하여 카운트가 예상보다 커지는 경우
    - 데드락: 순환 대기 상황

### 📊 전체 평가

**강점:**
- mutex와 semaphore의 기본 개념을 이해하고 있습니다.
- 소유권 개념의 차이를 알고 있습니다.
- binary semaphore와 mutex의 차이를 이해하고 있습니다.

**개선 필요:**
- ⚠️ mutex 정의 설명 부정확 ("단일 책임 원칙" vs "단일 소유권", 핵심 기능 명확화)
- ⚠️ semaphore 정의 설명 부정확 ("다중 책임 원칙" vs "카운트 기반")
- ⚠️ mutex/semaphore 핵심 차이 설명 모호 ("책임" vs "소유권 기반/카운트 기반")
- ⚠️ mutex 소유권 규칙 설명 부정확 ("단일 소유권 원칙" vs "잠근 스레드만 unlock")
- ⚠️ counting semaphore 사용 상황 설명 부정확 (reader writer 패턴)
- ⚠️ semaphore wait/signal 동작 설명 부정확 (오타, 카운트 감소 누락)
- ⚠️ mutex 사용 목적 설명 부정확 ("하나의 스레드만" vs "공유 데이터 보호")
- ⚠️ semaphore 사용 목적 설명 부정확 ("정해진 개수 접근" vs "자원 개수 제한과 순서 제어")
- ⚠️ mutex 문제 설명 부정확 ("unlock 안함"은 락 누수, 우선순위 역전 누락)
- ⚠️ semaphore 문제 설명 부족 (signal 누락, 과도한 signal)

**우선순위:**
1. **높음**: mutex/semaphore 정의 명확화 (소유권 vs 카운트)
2. **높음**: mutex/semaphore 핵심 차이 명확화
3. **높음**: mutex 문제 설명 수정 (우선순위 역전 추가)
4. **중간**: semaphore wait/signal 동작 설명 수정 (카운트 감소)
5. **중간**: counting semaphore 사용 상황 수정
6. **중간**: mutex/semaphore 사용 목적 명확화
7. **낮음**: 표현 정확성 개선 (오타 수정)

**특별 주의사항:**
- mutex는 "소유권 기반"이고, semaphore는 "카운트 기반"입니다. 이는 핵심 차이입니다.
- mutex는 잠근 스레드만 unlock할 수 있지만, semaphore는 어떤 스레드든 signal()을 호출할 수 있습니다.
- binary semaphore는 mutex와 유사하지만 소유권 개념이 없어 다른 스레드가 signal()을 호출할 수 있습니다.
- counting semaphore는 제한된 자원 풀 접근 제어에 주로 사용됩니다.
- mutex 사용 시 우선순위 역전 문제가 발생할 수 있으며, 우선순위 상속이나 우선순위 상한 프로토콜로 해결할 수 있습니다.
- semaphore 사용 시 signal 누락이나 과도한 signal로 인한 문제가 발생할 수 있습니다.
