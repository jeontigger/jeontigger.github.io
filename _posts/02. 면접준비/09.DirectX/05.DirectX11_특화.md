# 🧠 DirectX 11 특화 면접 질문 리스트

## ✅ 기본 개념

1. DirectX 11의 핵심 특징은 무엇인가요?

    - 

2. DirectX 11에서 Device와 Context가 분리된 이유는 무엇인가요?

    - 자원 생성과 해제의 권한을 분리하고 immediate context와 deferred context를 제공하기 위해서입니다.

3. DirectX 11의 주요 개선사항은 무엇인가요?

    - 

## ✅ Device Context

1. Device Context의 역할은 무엇인가요?

    - CPU에서 GPU로 데이터를 전달하기 위한 자원들의 생명주기를 관리하는 역할입니다.

2. Immediate Context와 Deferred Context의 차이는 무엇인가요?

    - 즉시 그리기를 명령하거나, 지연해서 그리기를 명령할 수 있는 차이가 있습니다.

3. Deferred Context를 사용하는 이유는 무엇인가요?

    - 멀티스레딩 환경에서 렌더스레드를 병렬적으로 진행시켜서 drawcall을 모았다가 한꺼번에 그리기 위함입니다.

4. Deferred Context를 사용할 때 주의해야 할 사항은 무엇인가요?

    - 모든 객체에 대한 렌더가 준비되었을 때 draw 명령을 해야합니다.

## ✅ Compute Shader

1. Compute Shader란 무엇인가요?

    - GPU의 코어를 단순계산에 사용하는 셰이더입니다.

2. Compute Shader를 사용하는 이유는 무엇인가요?

    - 단순한 계산을 CPU 코어로 많은 양을 계산하면 느리기 때문에 최적화되어있는 GPU의 코어를 사용합니다.

3. Compute Shader의 주요 활용 분야는 무엇인가요?

    - 요즘에는 AI의 LLM을 위한 계산, 파티클 계산, 행렬계산 등에서 사용됩니다.

4. Compute Shader를 실행하는 방법은 무엇인가요?

    - 

5. Compute Shader에서 사용하는 리소스는 무엇인가요?

    - UAV를 사용합니다. 목적이 계산된 결과를 얻기 위한 것이기 때문에 쓰기 버퍼가 필요합니다.

## ✅ Geometry Shader

1. Geometry Shader란 무엇인가요?

    - 정점을 생성할 수 있는 셰이더입니다.

2. Geometry Shader의 역할은 무엇인가요?

    - 정점을 생성하기 위해 사용합니다.

3. Geometry Shader를 사용하는 경우는 언제인가요?

    - 저는 빌보드를 구현하려고 할 때 사용했습니다. dot 매쉬를 input으로 하고, 정점 4개와 인덱스 6개를 만들고 2개의 토폴로지로 묶어서 rect를 구성했었습니다.

4. Geometry Shader의 성능 특성은 어떠한가요?

    - 

## ✅ Tessellation

1. Tessellation이란 무엇인가요?

    - 정점을 일정한 규칙을 기반으로 해서 정점을 생성해주는 파이프라인입니다.

2. Hull Shader와 Domain Shader의 역할은 무엇인가요?

    - 헐 셰이더는 테셀레이션 단계에서 생성되는 규칙을 정의하는 단계입니다. 도메인 셰이더는 테셀레이션 단계에서 생성된 정점들을 토폴로지로 묶는 단계입니다.

3. Tessellation을 사용하는 이유는 무엇인가요?

    - 메모리 최적화 기법 중 하나입니다. 모든 정점을 메모리에 갖고 있기 부담스럽지만 디테일을 올리기 위해 사용할 수 있습니다.

4. Tessellation의 성능 영향은 어떠한가요?

    - 

## ✅ 멀티스레딩

1. DirectX 11에서 멀티스레딩을 어떻게 활용하나요?

    - Deferred Context를 사용하면 됩니다.

2. Deferred Context를 멀티스레드에서 사용하는 방법은 무엇인가요?

    - deferred draw로 그릴 객체들을 모아두고, draw로 모은 객체들을 한꺼번에 그립니다.

3. 멀티스레드 렌더링의 장단점은 무엇인가요?

    - 렌더를 하기 위한 작업을 병렬적으로 세팅할 수 있습니다.

4. Command List를 생성하고 실행하는 방법은 무엇인가요?

    - 

## ✅ 고급 기능

1. DirectX 11에서 추가된 고급 렌더링 기능은 무엇인가요?

    - 

2. Multi-Render Target(MRT)이란 무엇인가요?

    - 렌더타겟을 여러개를 사용하는 방법입니다. Deferred Rendering에서 조명 계산을 위해 사용하기도 합니다.

3. UAV(Unordered Access View)란 무엇인가요?

    - GPU에서 쓰기가 가능한 버퍼입니다. Compute Shader에서 주로 사용합니다.

4. Structured Buffer란 무엇인가요?

    - 크기가 매우 큰 버퍼입니다. 주로 조명계산 등의 큰 사이즈에서 사용됩니다. UAV로 바인딩해서 컴퓨트 셰이더에서 사용합니다.

## ✅ 성능 / 최적화

1. DirectX 11의 성능 특성은 어떠한가요?

    - 

2. Deferred Context를 효율적으로 사용하는 방법은 무엇인가요?

    - 렌더 작업을 멀티스레딩 환경에서 수행합니다.

3. Compute Shader의 성능을 최적화하는 방법은 무엇인가요?

    - 

4. 멀티스레드 렌더링의 성능 이점을 극대화하는 방법은 무엇인가요?

    - 

## ✅ 실무 / 설계 판단

1. DirectX 11의 어떤 기능을 프로젝트에 활용해야 할지 판단하는 기준은 무엇인가요?

    - 

2. Compute Shader를 사용해야 하는 경우는 언제인가요?

    - 

3. Deferred Context를 사용해야 하는 경우는 언제인가요?

    - 

4. DirectX 11에서 DirectX 12로 마이그레이션을 고려해야 하는 시점은 언제인가요?

    - 

## ✅ 요약 질문

1. DirectX 11의 핵심 특징과 주요 기능을 요약해주세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. Device와 Context 분리, Compute Shader 추가, 멀티스레딩 지원 강화, Tessellation 지원이 핵심 특징입니다.

2. 멀티스레딩 환경에서 여러 스레드가 동시에 렌더링 명령을 기록할 수 있도록 하여 성능을 향상시키기 위함입니다.

3. Compute Shader 추가, 멀티스레딩 지원 강화, Tessellation 지원, 고급 렌더링 기능 추가가 주요 개선사항입니다.

### ✅ Device Context

1. 렌더링 명령을 기록하고 실행하는 객체로, 리소스 바인딩, 셰이더 설정, Draw 호출 등을 담당합니다.

2. Immediate Context는 즉시 실행되는 명령을 기록하고, Deferred Context는 나중에 실행될 명령을 기록합니다.

3. 멀티스레드 환경에서 렌더링 명령을 병렬로 기록하여 CPU 활용도를 높이고 성능을 향상시키기 위함입니다.

4. Deferred Context는 특정 리소스만 사용 가능하고, Immediate Context와 동기화가 필요하며, 오버헤드가 있어 항상 이점이 있는 것은 아닙니다.

### ✅ Compute Shader

1. GPU에서 범용 계산을 수행할 수 있는 셰이더로, 그래픽스 파이프라인 외부에서 실행됩니다.

2. GPU의 병렬 처리 능력을 활용하여 물리 시뮬레이션, 이미지 처리, AI 계산 등을 빠르게 수행하기 위함입니다.

3. 파티클 시스템, 이미지 필터링, 물리 시뮬레이션, AI 추론, 암호화 등이 주요 활용 분야입니다.

4. Dispatch() 함수를 사용하여 스레드 그룹의 개수를 지정하여 실행합니다.

5. Structured Buffer, Unordered Access View(UAV), Shader Resource View(SRV) 등을 사용합니다.

### ✅ Geometry Shader

1. Vertex Shader와 Pixel Shader 사이에서 실행되는 셰이더로, 기하 도형을 생성하거나 변형할 수 있습니다.

2. 정점을 추가하거나 제거하고, 프리미티브 타입을 변경하며, 기하 도형을 변형하는 역할을 합니다.

3. 파티클 생성, 실시간 그림자 생성, 지형 변형, 볼륨 렌더링 등에 사용됩니다.

4. 성능 오버헤드가 크므로 신중하게 사용해야 하며, 모든 정점에서 실행되므로 비용이 높습니다.

### ✅ Tessellation

1. GPU에서 기하 도형을 세분화하여 더 많은 정점을 생성하는 기술입니다.

2. Hull Shader는 제어점을 처리하고 테셀레이션 팩터를 결정하며, Domain Shader는 생성된 정점의 최종 위치를 계산합니다.

3. 적은 수의 정점으로 시작하여 필요한 곳만 세분화하여 메모리와 대역폭을 절약하면서도 높은 품질을 얻기 위함입니다.

4. GPU 연산량이 증가하므로 성능에 영향을 주며, 적절한 테셀레이션 팩터 설정이 중요합니다.

### ✅ 멀티스레딩

1. Deferred Context를 여러 스레드에서 사용하여 렌더링 명령을 병렬로 기록하고, Command List로 수집하여 Immediate Context에서 실행합니다.

2. 각 스레드에서 Deferred Context를 생성하고, 렌더링 명령을 기록한 후, FinishCommandList()로 Command List를 생성하고, Immediate Context에서 ExecuteCommandList()로 실행합니다.

3. 장점: CPU 활용도 향상, 렌더링 명령 기록 병렬화. 단점: 동기화 오버헤드, 복잡도 증가, 항상 성능 향상이 보장되지 않음.

4. Deferred Context에서 FinishCommandList()로 생성하고, Immediate Context에서 ExecuteCommandList()로 실행합니다.

### ✅ 고급 기능

1. Multi-Render Target, Unordered Access View, Structured Buffer, 고급 셰이더 모델 등이 추가되었습니다.

2. 여러 개의 Render Target에 동시에 렌더링하는 기능으로, Deferred Rendering 등에 활용됩니다.

3. Compute Shader나 Pixel Shader에서 읽기/쓰기가 가능한 리소스 뷰로, 순서가 보장되지 않는 접근을 허용합니다.

4. 구조화된 데이터를 저장하는 버퍼로, Compute Shader에서 주로 사용됩니다.

### ✅ 성능 / 최적화

1. DirectX 11은 중간 수준의 CPU 오버헤드를 가지며, 멀티스레딩을 통해 성능을 향상시킬 수 있습니다.

2. 독립적인 렌더링 작업을 Deferred Context로 분리하고, Command List를 효율적으로 생성하며, 불필요한 동기화를 피합니다.

3. 스레드 그룹 크기를 최적화하고, 공유 메모리를 활용하며, 리소스 접근 패턴을 최적화합니다.

4. 독립적인 렌더링 작업을 잘 분리하고, Command List 생성 비용을 고려하며, CPU 코어 수에 맞게 스레드 수를 조정합니다.

### ✅ 실무 / 설계 판단

1. 프로젝트 요구사항, 성능 목표, 개발 복잡도, 팀의 경험 수준을 종합적으로 고려해야 합니다.

2. GPU 병렬 처리가 필요한 계산(물리, 이미지 처리, AI 등)이 있고, CPU에서 처리하기 어려운 경우에 사용합니다.

3. 멀티코어 CPU를 활용할 수 있고, 독립적인 렌더링 작업이 많으며, CPU 병목이 발생하는 경우에 사용합니다.

4. CPU 오버헤드가 심각한 병목이 되고, 최대 성능이 필요하며, 개발 복잡도를 감수할 수 있을 때 고려합니다.

### ✅ 요약 질문

1. DirectX 11은 Device와 Context 분리로 멀티스레딩을 지원하고, Compute Shader로 GPU 범용 계산을 가능하게 하며, Tessellation과 Geometry Shader로 고급 렌더링을 제공합니다. Deferred Context를 활용한 멀티스레드 렌더링으로 CPU 활용도를 높일 수 있지만, 항상 성능 향상을 보장하지는 않으므로 신중하게 사용해야 합니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: DirectX 11의 핵심 특징은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "Device와 Context 분리, Compute Shader 추가, 멀티스레딩 지원 강화, Tessellation 지원이 핵심 특징입니다"

**질문 2: DirectX 11에서 Device와 Context가 분리된 이유는 무엇인가요?**
- **현재 답변**: "자원 생성과 해제의 권한을 분리하고 immediate context와 deferred context를 제공하기 위해서입니다"
- **피드백**:
  - ⚠️ **부정확**: Device와 Context 분리의 주된 이유는 멀티스레딩 지원입니다
  - ✅ **정확한 답변**: "멀티스레딩 환경에서 여러 스레드가 동시에 렌더링 명령을 기록할 수 있도록 하여 성능을 향상시키기 위함입니다"
  - Device는 리소스 생성/관리, Context는 렌더링 명령 기록/실행을 담당하며, 이 분리를 통해 Deferred Context를 통한 멀티스레드 렌더링이 가능해집니다

**질문 3: DirectX 11의 주요 개선사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 11의 핵심 내용입니다
  - ✅ **정확한 답변**: "Compute Shader 추가, 멀티스레딩 지원 강화, Tessellation 지원, 고급 렌더링 기능 추가가 주요 개선사항입니다"

### ✅ Device Context

**질문 1: Device Context의 역할은 무엇인가요?**
- **현재 답변**: "CPU에서 GPU로 데이터를 전달하기 위한 자원들의 생명주기를 관리하는 역할입니다"
- **피드백**:
  - ❌ **오개념**: Device Context는 자원 생명주기 관리가 아니라 렌더링 명령 기록/실행을 담당합니다
  - ✅ **정확한 답변**: "렌더링 명령을 기록하고 실행하는 객체로, 리소스 바인딩, 셰이더 설정, Draw 호출 등을 담당합니다"
  - 자원 생명주기 관리는 Device의 역할이며, Context는 렌더링 파이프라인 제어를 담당합니다

**질문 2: Immediate Context와 Deferred Context의 차이는 무엇인가요?**
- **현재 답변**: "즉시 그리기를 명령하거나, 지연해서 그리기를 명령할 수 있는 차이가 있습니다"
- **피드백**:
  - ⚠️ **부정확**: "그리기 명령"보다는 "명령 실행 시점"이 핵심입니다
  - ✅ **정확한 답변**: "Immediate Context는 즉시 실행되는 명령을 기록하고, Deferred Context는 나중에 실행될 명령을 기록합니다"
  - Deferred Context는 Command List로 명령을 기록한 후, Immediate Context에서 ExecuteCommandList()로 실행합니다

**질문 3: Deferred Context를 사용하는 이유는 무엇인가요?**
- **현재 답변**: "멀티스레딩 환경에서 렌더스레드를 병렬적으로 진행시켜서 drawcall을 모았다가 한꺼번에 그리기 위함입니다"
- **피드백**:
  - ⚠️ **부정확**: "렌더스레드"라는 표현이 부정확합니다. 렌더링 명령 기록을 병렬화하는 것입니다
  - ✅ **정확한 답변**: "멀티스레드 환경에서 렌더링 명령을 병렬로 기록하여 CPU 활용도를 높이고 성능을 향상시키기 위함입니다"
  - 여러 스레드에서 Deferred Context를 사용해 명령을 기록하고, Command List로 수집한 후 Immediate Context에서 실행합니다

**질문 4: Deferred Context를 사용할 때 주의해야 할 사항은 무엇인가요?**
- **현재 답변**: "모든 객체에 대한 렌더가 준비되었을 때 draw 명령을 해야합니다"
- **피드백**:
  - ⚠️ **부정확**: 더 구체적인 제약사항들이 있습니다
  - ✅ **정확한 답변**: "Deferred Context는 특정 리소스만 사용 가능하고, Immediate Context와 동기화가 필요하며, 오버헤드가 있어 항상 이점이 있는 것은 아닙니다"
  - 동적 리소스 생성이 제한되고, Command List 생성 비용이 있어 항상 성능 향상을 보장하지 않습니다

### ✅ Compute Shader

**질문 1: Compute Shader란 무엇인가요?**
- **현재 답변**: "GPU의 코어를 단순계산에 사용하는 셰이더입니다"
- **피드백**:
  - ⚠️ **부정확**: "단순계산"보다는 "범용 계산"이 더 정확하며, 그래픽스 파이프라인 외부 실행도 중요한 특징입니다
  - ✅ **정확한 답변**: "GPU에서 범용 계산을 수행할 수 있는 셰이더로, 그래픽스 파이프라인 외부에서 실행됩니다"
  - 그래픽스 렌더링과 독립적으로 실행되어 다양한 계산 작업에 활용됩니다

**질문 2: Compute Shader를 사용하는 이유는 무엇인가요?**
- **현재 답변**: "단순한 계산을 CPU 코어로 많은 양을 계산하면 느리기 때문에 최적화되어있는 GPU의 코어를 사용합니다"
- **피드백**:
  - ⚠️ **부정확**: 핵심은 GPU의 병렬 처리 능력입니다
  - ✅ **정확한 답변**: "GPU의 병렬 처리 능력을 활용하여 물리 시뮬레이션, 이미지 처리, AI 계산 등을 빠르게 수행하기 위함입니다"
  - GPU는 수천 개의 코어를 병렬로 활용할 수 있어 대량의 데이터 처리에 유리합니다

**질문 3: Compute Shader의 주요 활용 분야는 무엇인가요?**
- **현재 답변**: "요즘에는 AI의 LLM을 위한 계산, 파티클 계산, 행렬계산 등에서 사용됩니다"
- **피드백**:
  - 💡 **보완**: 더 구체적인 활용 분야를 추가하면 좋습니다
  - ✅ **정확한 답변**: "파티클 시스템, 이미지 필터링, 물리 시뮬레이션, AI 추론, 암호화 등이 주요 활용 분야입니다"
  - LLM은 AI 추론의 한 예시이며, 이미지 처리와 물리 시뮬레이션도 중요한 활용 분야입니다

**질문 4: Compute Shader를 실행하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Compute Shader 사용의 기본 지식입니다
  - ✅ **정확한 답변**: "Dispatch() 함수를 사용하여 스레드 그룹의 개수를 지정하여 실행합니다"
  - Dispatch(x, y, z)로 스레드 그룹의 개수를 지정하며, 각 스레드 그룹은 다수의 스레드를 포함합니다

**질문 5: Compute Shader에서 사용하는 리소스는 무엇인가요?**
- **현재 답변**: "UAV를 사용합니다. 목적이 계산된 결과를 얻기 위한 것이기 때문에 쓰기 버퍼가 필요합니다"
- **피드백**:
  - ⚠️ **부정확**: UAV만 사용하는 것이 아니라 SRV(읽기)와 Structured Buffer도 사용합니다
  - ✅ **정확한 답변**: "Structured Buffer, Unordered Access View(UAV), Shader Resource View(SRV) 등을 사용합니다"
  - 입력 데이터는 SRV로 읽고, 출력 데이터는 UAV로 씁니다. Structured Buffer는 구조화된 대용량 데이터에 사용됩니다

### ✅ Geometry Shader

**질문 1: Geometry Shader란 무엇인가요?**
- **현재 답변**: "정점을 생성할 수 있는 셰이더입니다"
- **피드백**:
  - ⚠️ **부정확**: 파이프라인에서의 위치와 더 넓은 역할을 설명해야 합니다
  - ✅ **정확한 답변**: "Vertex Shader와 Pixel Shader 사이에서 실행되는 셰이더로, 기하 도형을 생성하거나 변형할 수 있습니다"
  - 정점 생성뿐만 아니라 제거, 프리미티브 타입 변경, 기하 도형 변형도 가능합니다

**질문 2: Geometry Shader의 역할은 무엇인가요?**
- **현재 답변**: "정점을 생성하기 위해 사용합니다"
- **피드백**:
  - 💡 **보완**: 더 구체적인 역할을 설명하면 좋습니다
  - ✅ **정확한 답변**: "정점을 추가하거나 제거하고, 프리미티브 타입을 변경하며, 기하 도형을 변형하는 역할을 합니다"
  - 빌보드 생성, 파티클 생성, 실시간 그림자 생성 등 다양한 활용이 가능합니다

**질문 4: Geometry Shader의 성능 특성은 어떠한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Geometry Shader 사용 시 중요한 고려사항입니다
  - ✅ **정확한 답변**: "성능 오버헤드가 크므로 신중하게 사용해야 하며, 모든 정점에서 실행되므로 비용이 높습니다"
  - 모든 프리미티브의 모든 정점에서 실행되므로 성능에 큰 영향을 미칩니다

### ✅ Tessellation

**질문 1: Tessellation이란 무엇인가요?**
- **현재 답변**: "정점을 일정한 규칙을 기반으로 해서 정점을 생성해주는 파이프라인입니다"
- **피드백**:
  - ⚠️ **부정확**: "세분화" 개념이 더 정확합니다
  - ✅ **정확한 답변**: "GPU에서 기하 도형을 세분화하여 더 많은 정점을 생성하는 기술입니다"
  - 기존 정점을 기반으로 새로운 정점을 생성하여 디테일을 높입니다

**질문 2: Hull Shader와 Domain Shader의 역할은 무엇인가요?**
- **현재 답변**: "헐 셰이더는 테셀레이션 단계에서 생성되는 규칙을 정의하는 단계입니다. 도메인 셰이더는 테셀레이션 단계에서 생성된 정점들을 토폴로지로 묶는 단계입니다"
- **피드백**:
  - ❌ **오개념**: Domain Shader는 토폴로지를 묶는 것이 아니라 정점의 최종 위치를 계산합니다
  - ✅ **정확한 답변**: "Hull Shader는 제어점을 처리하고 테셀레이션 팩터를 결정하며, Domain Shader는 생성된 정점의 최종 위치를 계산합니다"
  - Tessellator가 실제 정점을 생성하고, Domain Shader가 각 정점의 최종 위치를 계산합니다

**질문 3: Tessellation을 사용하는 이유는 무엇인가요?**
- **현재 답변**: "메모리 최적화 기법 중 하나입니다. 모든 정점을 메모리에 갖고 있기 부담스럽지만 디테일을 올리기 위해 사용할 수 있습니다"
- **피드백**:
  - 💡 **보완**: 더 구체적으로 설명하면 좋습니다
  - ✅ **정확한 답변**: "적은 수의 정점으로 시작하여 필요한 곳만 세분화하여 메모리와 대역폭을 절약하면서도 높은 품질을 얻기 위함입니다"
  - LOD(Level of Detail) 개념과 연계하여 거리나 중요도에 따라 동적으로 디테일을 조절할 수 있습니다

**질문 4: Tessellation의 성능 영향은 어떠한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Tessellation 사용 시 중요한 고려사항입니다
  - ✅ **정확한 답변**: "GPU 연산량이 증가하므로 성능에 영향을 주며, 적절한 테셀레이션 팩터 설정이 중요합니다"
  - 테셀레이션 팩터가 너무 높으면 성능이 저하되므로, 적절한 밸런스가 필요합니다

### ✅ 멀티스레딩

**질문 1: DirectX 11에서 멀티스레딩을 어떻게 활용하나요?**
- **현재 답변**: "Deferred Context를 사용하면 됩니다"
- **피드백**:
  - 💡 **보완**: 더 구체적인 프로세스를 설명하면 좋습니다
  - ✅ **정확한 답변**: "Deferred Context를 여러 스레드에서 사용하여 렌더링 명령을 병렬로 기록하고, Command List로 수집하여 Immediate Context에서 실행합니다"
  - 각 스레드에서 Deferred Context로 명령을 기록하고, Command List로 수집한 후 메인 스레드에서 실행합니다

**질문 2: Deferred Context를 멀티스레드에서 사용하는 방법은 무엇인가요?**
- **현재 답변**: "deferred draw로 그릴 객체들을 모아두고, draw로 모은 객체들을 한꺼번에 그립니다"
- **피드백**:
  - 💡 **보완**: 구체적인 API 호출을 언급하면 좋습니다
  - ✅ **정확한 답변**: "각 스레드에서 Deferred Context를 생성하고, 렌더링 명령을 기록한 후, FinishCommandList()로 Command List를 생성하고, Immediate Context에서 ExecuteCommandList()로 실행합니다"
  - FinishCommandList()와 ExecuteCommandList()가 핵심 API입니다

**질문 3: 멀티스레드 렌더링의 장단점은 무엇인가요?**
- **현재 답변**: "렌더를 하기 위한 작업을 병렬적으로 세팅할 수 있습니다"
- **피드백**:
  - ⚠️ **부정확**: 장점만 언급하고 단점이 누락되었습니다
  - ✅ **정확한 답변**: "장점: CPU 활용도 향상, 렌더링 명령 기록 병렬화. 단점: 동기화 오버헤드, 복잡도 증가, 항상 성능 향상이 보장되지 않음"
  - Command List 생성 비용과 동기화 오버헤드로 인해 항상 성능 향상을 보장하지 않습니다

**질문 4: Command List를 생성하고 실행하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 멀티스레드 렌더링의 핵심 개념입니다
  - ✅ **정확한 답변**: "Deferred Context에서 FinishCommandList()로 생성하고, Immediate Context에서 ExecuteCommandList()로 실행합니다"
  - FinishCommandList()는 ID3D11CommandList 포인터를 반환하며, ExecuteCommandList()로 실행합니다

### ✅ 고급 기능

**질문 1: DirectX 11에서 추가된 고급 렌더링 기능은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 11의 주요 기능들을 요약하는 질문입니다
  - ✅ **정확한 답변**: "Multi-Render Target, Unordered Access View, Structured Buffer, 고급 셰이더 모델 등이 추가되었습니다"

**질문 3: UAV(Unordered Access View)란 무엇인가요?**
- **현재 답변**: "GPU에서 쓰기가 가능한 버퍼입니다. Compute Shader에서 주로 사용합니다"
- **피드백**:
  - ⚠️ **부정확**: Pixel Shader에서도 사용 가능하며, "순서가 보장되지 않는 접근"이 중요한 특징입니다
  - ✅ **정확한 답변**: "Compute Shader나 Pixel Shader에서 읽기/쓰기가 가능한 리소스 뷰로, 순서가 보장되지 않는 접근을 허용합니다"
  - "Unordered"는 접근 순서가 보장되지 않음을 의미하며, 동시성 제어가 필요합니다

**질문 4: Structured Buffer란 무엇인가요?**
- **현재 답변**: "크기가 매우 큰 버퍼입니다. 주로 조명계산 등의 큰 사이즈에서 사용됩니다. UAV로 바인딩해서 컴퓨트 셰이더에서 사용합니다"
- **피드백**:
  - ⚠️ **부정확**: 크기보다는 "구조화된 데이터" 특성이 핵심입니다
  - ✅ **정확한 답변**: "구조화된 데이터를 저장하는 버퍼로, Compute Shader에서 주로 사용됩니다"
  - 구조화된 데이터 타입(구조체 배열 등)을 효율적으로 저장하고 접근할 수 있는 버퍼입니다

### ✅ 성능 / 최적화

**질문 1: DirectX 11의 성능 특성은 어떠한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 11의 성능 특성을 이해하는 것이 중요합니다
  - ✅ **정확한 답변**: "DirectX 11은 중간 수준의 CPU 오버헤드를 가지며, 멀티스레딩을 통해 성능을 향상시킬 수 있습니다"
  - DirectX 12보다는 높지만 DirectX 9보다는 낮은 CPU 오버헤드를 가집니다

**질문 2: Deferred Context를 효율적으로 사용하는 방법은 무엇인가요?**
- **현재 답변**: "렌더 작업을 멀티스레딩 환경에서 수행합니다"
- **피드백**:
  - 💡 **보완**: 더 구체적인 최적화 방법을 설명하면 좋습니다
  - ✅ **정확한 답변**: "독립적인 렌더링 작업을 Deferred Context로 분리하고, Command List를 효율적으로 생성하며, 불필요한 동기화를 피합니다"
  - 작업 분리, Command List 재사용, 동기화 최소화가 핵심입니다

**질문 3: Compute Shader의 성능을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Compute Shader 활용 시 중요한 지식입니다
  - ✅ **정확한 답변**: "스레드 그룹 크기를 최적화하고, 공유 메모리를 활용하며, 리소스 접근 패턴을 최적화합니다"
  - 스레드 그룹 크기는 하드웨어에 맞게 조정하고, 공유 메모리(Group Shared Memory)를 활용하여 성능을 향상시킵니다

**질문 4: 멀티스레드 렌더링의 성능 이점을 극대화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 최적화 기법입니다
  - ✅ **정확한 답변**: "독립적인 렌더링 작업을 잘 분리하고, Command List 생성 비용을 고려하며, CPU 코어 수에 맞게 스레드 수를 조정합니다"
  - 작업 분리, 오버헤드 고려, 하드웨어 특성에 맞는 스레드 수 조정이 중요합니다

### ✅ 실무 / 설계 판단

**질문 1: DirectX 11의 어떤 기능을 프로젝트에 활용해야 할지 판단하는 기준은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무 설계 능력을 평가하는 질문입니다
  - ✅ **정확한 답변**: "프로젝트 요구사항, 성능 목표, 개발 복잡도, 팀의 경험 수준을 종합적으로 고려해야 합니다"
  - 각 기능의 성능 특성과 개발 복잡도를 프로젝트 목표와 비교하여 판단합니다

**질문 2: Compute Shader를 사용해야 하는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 판단 기준입니다
  - ✅ **정확한 답변**: "GPU 병렬 처리가 필요한 계산(물리, 이미지 처리, AI 등)이 있고, CPU에서 처리하기 어려운 경우에 사용합니다"
  - 대량의 병렬 데이터 처리, 반복적인 계산, GPU 메모리 접근이 필요한 경우에 적합합니다

**질문 3: Deferred Context를 사용해야 하는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 멀티스레드 렌더링 설계 시 중요한 판단 기준입니다
  - ✅ **정확한 답변**: "멀티코어 CPU를 활용할 수 있고, 독립적인 렌더링 작업이 많으며, CPU 병목이 발생하는 경우에 사용합니다"
  - CPU 병목이 있고, 독립적인 렌더링 작업이 많을 때 효과적입니다

**질문 4: DirectX 11에서 DirectX 12로 마이그레이션을 고려해야 하는 시점은 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 기술 선택의 중요한 판단 기준입니다
  - ✅ **정확한 답변**: "CPU 오버헤드가 심각한 병목이 되고, 최대 성능이 필요하며, 개발 복잡도를 감수할 수 있을 때 고려합니다"
  - DirectX 12는 더 낮은 CPU 오버헤드를 제공하지만 개발 복잡도가 높습니다

### ✅ 요약 질문

**질문 1: DirectX 11의 핵심 특징과 주요 기능을 요약해주세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 전체적인 이해도를 평가하는 종합 질문입니다
  - ✅ **정확한 답변**: "DirectX 11은 Device와 Context 분리로 멀티스레딩을 지원하고, Compute Shader로 GPU 범용 계산을 가능하게 하며, Tessellation과 Geometry Shader로 고급 렌더링을 제공합니다. Deferred Context를 활용한 멀티스레드 렌더링으로 CPU 활용도를 높일 수 있지만, 항상 성능 향상을 보장하지는 않으므로 신중하게 사용해야 합니다"

### 📊 전체 평가

**강점:**
- ✅ Geometry Shader의 실무 활용 사례(빌보드 구현)를 구체적으로 설명
- ✅ MRT, Tessellation의 메모리 최적화 개념 이해
- ✅ Compute Shader의 활용 분야(LLM, 파티클 등) 언급

**개선 필요:**
- ❌ **오개념**: Device Context의 역할(자원 생명주기 관리가 아님), Hull/Domain Shader의 역할(도메인 셰이더는 토폴로지를 묶는 것이 아님)
- ⚠️ **부정확한 부분**: Device/Context 분리 이유(멀티스레딩이 주 목적), Immediate/Deferred Context 차이, Compute Shader 정의 및 리소스 사용, Geometry Shader 정의, Tessellation 정의, UAV 정의, Structured Buffer 정의, 멀티스레드 렌더링 장단점
- 💡 **개선 필요**: Compute Shader 활용 분야, Geometry Shader 역할, Tessellation 사용 이유, 멀티스레딩 활용 방법, Deferred Context 효율적 사용
- ❌ **답변 누락**: 기본 개념 2개, Compute Shader 실행 방법, Geometry Shader 성능 특성, Tessellation 성능 영향, Command List 생성/실행, 고급 기능 1개, 성능/최적화 3개, 실무/설계 판단 4개, 요약 질문 1개 (총 15개)

**우선순위:**
1. **높음**: 
   - Device Context의 역할 오개념 수정 (면접에서 자주 나오는 핵심 개념)
   - Hull/Domain Shader 역할 오개념 수정 (Tessellation 파이프라인 이해)
   - 답변 누락된 핵심 질문들 답변 작성 (특히 Compute Shader 실행 방법, Command List, 성능 특성 등)
2. **중간**: 
   - Device/Context 분리 이유 정확히 이해 (멀티스레딩이 주 목적)
   - Compute Shader 리소스 사용 정확히 이해 (UAV뿐만 아니라 SRV, Structured Buffer도 사용)
   - 멀티스레드 렌더링의 장단점 모두 이해
3. **낮음**: 
   - 각 기능의 구체적인 활용 사례 보완
   - 실무 판단 기준에 대한 답변 작성

**특별 주의사항:**
- Device와 Context의 역할 구분은 면접에서 매우 자주 나오는 질문입니다. Device는 리소스 생성/관리, Context는 렌더링 명령 기록/실행을 담당합니다
- Compute Shader는 UAV뿐만 아니라 SRV(읽기)와 Structured Buffer도 사용합니다
- Deferred Context는 항상 성능 향상을 보장하지 않으며, Command List 생성 비용과 동기화 오버헤드를 고려해야 합니다
- Tessellation 파이프라인에서 Hull Shader는 테셀레이션 팩터 결정, Domain Shader는 정점 위치 계산을 담당합니다
