# 🧠 DirectX API 기본 면접 질문 리스트

## ✅ 기본 개념

1. DirectX API의 핵심 객체는 무엇인가요?

    - Context와 Device입니다.

2. Device와 Context의 역할은 무엇인가요?

    - Device는 필요한 DirectX자원의 생성과 해제 를 담당하고, Context는 실제 그려질 Render를 담당합니다.

3. DirectX 초기화 과정은 어떻게 진행되나요?

    - 

## ✅ Device 생성

1. D3D11CreateDevice() 함수의 역할은 무엇인가요?

    - Device를 생성합니다.

2. Device를 생성할 때 고려해야 할 주요 파라미터는 무엇인가요?

    - 

3. Device 생성 실패 시 어떻게 처리해야 하나요?

    - 

4. Feature Level이란 무엇이고, 왜 중요한가요?

    - 

## ✅ Swap Chain

1. Swap Chain이란 무엇인가요?

    - 

2. Swap Chain을 생성하는 이유는 무엇인가요?

    - 

3. DXGI_SWAP_CHAIN_DESC 구조체의 주요 멤버는 무엇인가요?

    - 

4. Swap Chain의 Present() 함수는 무엇을 하나요?

    - 

## ✅ Render Target View

1. Render Target View(RTV)란 무엇인가요?

    - 렌더타겟입니다.

2. RTV를 생성하는 이유는 무엇인가요?

    - GPU의 렌더타겟을 설정해주기 위함입니다.

3. RTV를 설정하는 방법은 무엇인가요?

    - 

4. 여러 개의 Render Target을 동시에 사용할 수 있나요?

    - 멀티렌더타겟은 가능합니다.

## ✅ Depth Stencil View

1. Depth Stencil View(DSV)란 무엇인가요?

    - z-buffer와 stencil 값을 갖고있는 데이터 청크입니다.

2. DSV를 사용하는 이유는 무엇인가요?

    - OM시에 Depth Test나 Stencil 마스킹 등의 기능을 사용하기 위해 필요합니다.

3. Depth Buffer와 Stencil Buffer의 차이는 무엇인가요?

    - Depth 버퍼는 깊이값을 기록하고 0부터 1사이의 실수형으로 정규화 된 값이 들어갑니다. Stencil은 정수가 들어갑니다.

4. DSV를 생성하고 설정하는 방법은 무엇인가요?

    - 

## ✅ Viewport

1. Viewport란 무엇인가요?

    - 뷰포트와 렌더타겟이 헷갈립니다.

2. Viewport를 설정하는 이유는 무엇인가요?

    - 

3. Viewport의 주요 속성은 무엇인가요?

    - 

4. 여러 Viewport를 동시에 사용할 수 있나요?

    - 

## ✅ 기본 렌더링 루프

1. DirectX의 기본 렌더링 루프 구조는 어떻게 되나요?

    - 

2. ClearRenderTargetView()와 ClearDepthStencilView()의 역할은 무엇인가요?

    - 

3. DrawIndexed()와 Draw()의 차이는 무엇인가요?

    - index버퍼를 사용하여 그리는 것과, index버퍼 없이 정점버퍼만으로 그리는 것의 차이입니다.

4. Present()를 호출하는 시점은 언제인가요?

    - 

## ✅ 에러 처리

1. DirectX API 호출 시 에러를 처리하는 방법은 무엇인가요?

    - 

2. HRESULT의 의미와 확인 방법은 무엇인가요?

    - 핸들러입니다. E_FAIL 매크로가 아니면 성공입니다.

3. FAILED() 매크로의 역할은 무엇인가요?

    - 

4. 일반적인 DirectX 에러 코드는 무엇인가요?

    - 

## ✅ 성능 / 최적화

1. Device 생성 시 성능에 영향을 주는 요소는 무엇인가요?

    - 

2. Swap Chain 설정 시 성능을 고려해야 할 사항은 무엇인가요?

    - 

3. Render Target 변경이 성능에 미치는 영향은 무엇인가요?

    - 모든 렌더타겟의 크기를 맞춰서 변경해야 합니다.

## ✅ 실무 / 설계 판단

1. DirectX 초기화 코드를 작성할 때 가장 중요하게 고려해야 할 사항은 무엇인가요?

    - 

2. 여러 해상도와 화면 비율을 지원하려면 어떻게 해야 하나요?

    - 

3. DirectX 초기화 실패 시 사용자에게 어떻게 알려야 하나요?

    - 

## ✅ 요약 질문

1. DirectX API의 기본 사용 흐름(Device 생성부터 렌더링까지)을 요약해주세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: DirectX API의 핵심 객체는 무엇인가요?**
- **현재 답변**: "Context와 Device입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 Swap Chain도 핵심 객체입니다
  - ✅ **정확한 답변**: "Device(ID3D11Device), Context(ID3D11DeviceContext), Swap Chain(IDXGISwapChain)이 핵심 객체입니다"
  - Swap Chain은 화면 출력에 필수적인 객체입니다

**질문 2: Device와 Context의 역할은 무엇인가요?**
- **현재 답변**: "Device는 필요한 DirectX자원의 생성과 해제를 담당하고, Context는 실제 그려질 Render를 담당합니다."
- **피드백**:
  - ⚠️ **부정확**: "실제 그려질 Render를 담당"이라는 표현이 모호합니다
  - ✅ **정확한 답변**: "Device는 리소스를 생성하고, Context는 렌더링 명령을 기록하고 실행합니다"
  - Context는 렌더링 명령을 기록하고 실행하는 역할입니다

**질문 3: DirectX 초기화 과정은 어떻게 진행되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "D3D11CreateDevice()로 Device와 Context 생성 → Swap Chain 생성 → Render Target View 생성 → Depth Stencil View 생성 → Viewport 설정 순서로 진행됩니다"
  - 초기화 순서를 정확히 이해하는 것이 중요합니다

### ✅ Device 생성

**질문 1: D3D11CreateDevice() 함수의 역할은 무엇인가요?**
- **현재 답변**: "Device를 생성합니다."
- **피드백**:
  - 💡 **보완**: Context도 함께 생성한다는 점을 추가하면 좋습니다
  - ✅ **정확한 답변**: "Direct3D 11 Device와 Immediate Context를 생성하는 함수입니다"
  - Device와 Context를 동시에 생성합니다

**질문 2: Device를 생성할 때 고려해야 할 주요 파라미터는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 설정입니다
  - ✅ **정확한 답변**: "드라이버 타입(D3D_DRIVER_TYPE), Feature Level 배열, 디버그 플래그, 생성할 Device 버전 등이 주요 파라미터입니다"
  - 각 파라미터의 의미를 이해해야 합니다

**질문 3: Device 생성 실패 시 어떻게 처리해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 에러 처리는 실무에서 매우 중요합니다
  - ✅ **정확한 답변**: "HRESULT를 확인하고, 실패 시 에러 메시지를 출력하거나 대체 방법을 시도합니다"
  - Feature Level 폴백 등 대체 방법을 시도해야 합니다

**질문 4: Feature Level이란 무엇이고, 왜 중요한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 호환성과 관련된 중요한 개념입니다
  - ✅ **정확한 답변**: "하드웨어가 지원하는 DirectX 기능 수준을 나타내며, 낮은 Feature Level을 선택하면 더 많은 하드웨어에서 동작합니다"
  - 다양한 하드웨어 지원을 위해 중요합니다

### ✅ Swap Chain

**질문 1: Swap Chain이란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 화면 출력의 핵심 개념입니다
  - ✅ **정확한 답변**: "백 버퍼와 프론트 버퍼를 관리하여 화면에 이미지를 표시하는 객체입니다"
  - 더블 버퍼링의 핵심입니다

**질문 2: Swap Chain을 생성하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 더블 버퍼링의 목적을 이해해야 합니다
  - ✅ **정확한 답변**: "더블 버퍼링을 구현하여 화면 깜빡임을 방지하고 부드러운 렌더링을 제공하기 위함입니다"
  - 화면 깜빡임 방지가 주요 목적입니다

**질문 3: DXGI_SWAP_CHAIN_DESC 구조체의 주요 멤버는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Swap Chain 생성 시 필수 설정입니다
  - ✅ **정확한 답변**: "BufferDesc(해상도, 포맷), SampleDesc(멀티샘플링), BufferUsage, SwapEffect, Windowed 등이 주요 멤버입니다"
  - 각 멤버의 역할을 이해해야 합니다

**질문 4: Swap Chain의 Present() 함수는 무엇을 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 렌더링 루프의 마지막 단계입니다
  - ✅ **정확한 답변**: "백 버퍼와 프론트 버퍼를 교체하여 화면에 렌더링된 결과를 표시합니다"
  - 버퍼 교체가 핵심입니다

### ✅ Render Target View

**질문 1: Render Target View(RTV)란 무엇인가요?**
- **현재 답변**: "렌더타겟입니다."
- **피드백**:
  - ⚠️ **부정확**: "렌더타겟"이라는 표현이 너무 단순합니다
  - ✅ **정확한 답변**: "렌더링 결과를 저장할 텍스처를 GPU에 바인딩하는 뷰 객체입니다"
  - View 객체로서의 역할을 명확히 해야 합니다

**질문 2: RTV를 생성하는 이유는 무엇인가요?**
- **현재 답변**: "GPU의 렌더타겟을 설정해주기 위함입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 더 구체적으로 설명하면 좋습니다
  - ✅ **정확한 답변**: "렌더링할 대상을 GPU에 알려주기 위해 필요합니다"
  - GPU가 어디에 렌더링할지 알려주는 것이 목적입니다

**질문 3: RTV를 설정하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 자주 사용하는 API입니다
  - ✅ **정확한 답변**: "CreateRenderTargetView()로 생성하고, OMSetRenderTargets()로 Context에 설정합니다"
  - 생성과 설정의 두 단계를 이해해야 합니다

**질문 4: 여러 개의 Render Target을 동시에 사용할 수 있나요?**
- **현재 답변**: "멀티렌더타겟은 가능합니다."
- **피드백**:
  - 💡 **보완**: 최대 개수를 명시하면 더 좋습니다
  - ✅ **정확한 답변**: "네, DirectX 11에서는 최대 8개의 Render Target을 동시에 사용할 수 있습니다(MRT)"
  - MRT(Multiple Render Target)의 최대 개수를 알면 좋습니다

### ✅ Depth Stencil View

**질문 1: Depth Stencil View(DSV)란 무엇인가요?**
- **현재 답변**: "z-buffer와 stencil 값을 갖고있는 데이터 청크입니다."
- **피드백**:
  - ⚠️ **부정확**: "데이터 청크"라는 표현이 부정확합니다
  - ✅ **정확한 답변**: "깊이 테스트와 스텐실 테스트를 위한 뷰 객체입니다"
  - View 객체로서의 역할을 명확히 해야 합니다

**질문 2: DSV를 사용하는 이유는 무엇인가요?**
- **현재 답변**: "OM시에 Depth Test나 Stencil 마스킹 등의 기능을 사용하기 위해 필요합니다."
- **피드백**:
  - 💡 **보완**: "OM"은 Output Merger의 약자이며, 더 구체적으로 설명하면 좋습니다
  - ✅ **정확한 답변**: "3D 장면에서 가려진 객체를 올바르게 렌더링하기 위해 필요합니다"
  - 가려진 객체 처리의 핵심입니다

**질문 3: Depth Buffer와 Stencil Buffer의 차이는 무엇인가요?**
- **현재 답변**: "Depth 버퍼는 깊이값을 기록하고 0부터 1사이의 실수형으로 정규화 된 값이 들어갑니다. Stencil은 정수가 들어갑니다."
- **피드백**:
  - 💡 **보완**: 각각의 용도를 추가로 설명하면 더 좋습니다
  - ✅ **정확한 답변**: "Depth Buffer는 깊이 정보를 저장하고, Stencil Buffer는 특정 영역을 마스킹하는 데 사용됩니다"
  - 용도 차이를 명확히 이해해야 합니다

**질문 4: DSV를 생성하고 설정하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 필수적인 작업입니다
  - ✅ **정확한 답변**: "CreateDepthStencilView()로 생성하고, OMSetRenderTargets()의 두 번째 파라미터로 설정합니다"
  - RTV와 함께 설정하는 방법을 이해해야 합니다

### ✅ Viewport

**질문 1: Viewport란 무엇인가요?**
- **현재 답변**: "뷰포트와 렌더타겟이 헷갈립니다."
- **피드백**:
  - ❌ **답변 필요**: 개념을 명확히 이해해야 합니다
  - ✅ **정확한 답변**: "렌더링 결과가 화면의 어느 영역에 표시될지를 정의하는 영역입니다"
  - Render Target은 렌더링할 텍스처, Viewport는 화면 표시 영역입니다

**질문 2: Viewport를 설정하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 다양한 렌더링 기법에 필요합니다
  - ✅ **정확한 답변**: "화면의 일부 영역에만 렌더링하거나, 여러 카메라 뷰를 동시에 표시하기 위해 사용합니다"
  - 분할 화면, 미니맵 등에 활용됩니다

**질문 3: Viewport의 주요 속성은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Viewport 설정 시 필수 정보입니다
  - ✅ **정확한 답변**: "TopLeftX, TopLeftY(시작 위치), Width, Height(크기), MinDepth, MaxDepth(깊이 범위)가 주요 속성입니다"
  - 위치, 크기, 깊이 범위를 설정합니다

**질문 4: 여러 Viewport를 동시에 사용할 수 있나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 고급 렌더링 기법에 사용됩니다
  - ✅ **정확한 답변**: "네, DirectX 11에서는 여러 Viewport를 동시에 사용할 수 있습니다"
  - 분할 화면 렌더링 등에 활용 가능합니다

### ✅ 기본 렌더링 루프

**질문 1: DirectX의 기본 렌더링 루프 구조는 어떻게 되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 렌더링의 핵심 흐름입니다
  - ✅ **정확한 답변**: "Clear → Set Render Target → Set Shaders → Set Buffers → Draw → Present 순서로 진행됩니다"
  - 순서를 정확히 이해하는 것이 중요합니다

**질문 2: ClearRenderTargetView()와 ClearDepthStencilView()의 역할은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 매 프레임마다 호출하는 중요한 함수입니다
  - ✅ **정확한 답변**: "ClearRenderTargetView()는 Render Target을 특정 색상으로 초기화하고, ClearDepthStencilView()는 Depth/Stencil Buffer를 초기화합니다"
  - 이전 프레임의 잔상 제거가 목적입니다

**질문 3: DrawIndexed()와 Draw()의 차이는 무엇인가요?**
- **현재 답변**: "index버퍼를 사용하여 그리는 것과, index버퍼 없이 정점버퍼만으로 그리는 것의 차이입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 각각의 장단점을 추가하면 더 좋습니다
  - ✅ **정확한 답변**: "DrawIndexed()는 Index Buffer를 사용하여 그리며, Draw()는 Index Buffer 없이 직접 그립니다"
  - Index Buffer 사용 시 메모리 효율성이 좋습니다

**질문 4: Present()를 호출하는 시점은 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 렌더링 루프의 마지막 단계입니다
  - ✅ **정확한 답변**: "모든 렌더링이 완료된 후, 한 프레임의 마지막에 호출하여 화면에 결과를 표시합니다"
  - 프레임의 마지막에 호출해야 합니다

### ✅ 에러 처리

**질문 1: DirectX API 호출 시 에러를 처리하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 매우 중요한 부분입니다
  - ✅ **정확한 답변**: "모든 API 호출의 HRESULT 반환값을 확인하고, FAILED() 매크로로 실패 여부를 판단합니다"
  - 모든 API 호출에 에러 처리가 필요합니다

**질문 2: HRESULT의 의미와 확인 방법은 무엇인가요?**
- **현재 답변**: "핸들러입니다. E_FAIL 매크로가 아니면 성공입니다."
- **피드백**:
  - ❌ **오개념**: HRESULT는 핸들러가 아닙니다. 또한 E_FAIL이 아니면 성공이라는 것도 부정확합니다
  - ✅ **정확한 답변**: "HRESULT는 함수 호출 결과를 나타내는 32비트 값이며, SUCCEEDED() 또는 FAILED() 매크로로 확인합니다"
  - HRESULT는 반환값이며, 매크로로 확인해야 합니다

**질문 3: FAILED() 매크로의 역할은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 에러 처리의 기본 도구입니다
  - ✅ **정확한 답변**: "HRESULT가 실패 코드인지 확인하는 매크로입니다"
  - 실패 여부를 간단히 확인할 수 있습니다

**질문 4: 일반적인 DirectX 에러 코드는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 디버깅에 유용한 정보입니다
  - ✅ **정확한 답변**: "E_INVALIDARG(잘못된 인자), E_OUTOFMEMORY(메모리 부족), DXGI_ERROR_DEVICE_REMOVED(디바이스 제거) 등이 있습니다"
  - 주요 에러 코드를 알아두면 디버깅이 쉬워집니다

### ✅ 성능 / 최적화

**질문 1: Device 생성 시 성능에 영향을 주는 요소는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 기본입니다
  - ✅ **정확한 답변**: "디버그 모드 사용 여부, Feature Level 선택, 드라이버 타입 선택이 성능에 영향을 줍니다"
  - 디버그 모드는 성능에 큰 영향을 줍니다

**질문 2: Swap Chain 설정 시 성능을 고려해야 할 사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 프레임레이트에 직접적인 영향을 줍니다
  - ✅ **정확한 답변**: "버퍼 개수, VSync 사용 여부, 멀티샘플링 설정이 성능에 영향을 줍니다"
  - VSync는 입력 지연과 프레임레이트에 영향을 줍니다

**질문 3: Render Target 변경이 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: "모든 렌더타겟의 크기를 맞춰서 변경해야 합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 질문의 핵심을 다루지 않습니다
  - ✅ **정확한 답변**: "Render Target 변경은 상태 변경 비용이 발생하므로, 변경 횟수를 최소화해야 합니다"
  - 변경 비용이 있으므로 최소화가 중요합니다

### ✅ 실무 / 설계 판단

**질문 1: DirectX 초기화 코드를 작성할 때 가장 중요하게 고려해야 할 사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무 경험을 보여줄 수 있는 질문입니다
  - ✅ **정확한 답변**: "에러 처리, Feature Level 폴백 처리, 다양한 해상도 지원, 리소스 해제가 가장 중요합니다"
  - 실무에서 발생하는 주요 이슈들을 이해해야 합니다

**질문 2: 여러 해상도와 화면 비율을 지원하려면 어떻게 해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 현대 게임 개발의 필수 요구사항입니다
  - ✅ **정확한 답변**: "Swap Chain을 재생성하거나, Viewport를 조정하거나, 해상도에 따라 렌더링 품질을 조정합니다"
  - 다양한 해상도 지원 방법을 이해해야 합니다

**질문 3: DirectX 초기화 실패 시 사용자에게 어떻게 알려야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 사용자 경험에 중요한 부분입니다
  - ✅ **정확한 답변**: "사용자 친화적인 에러 메시지를 표시하고, 가능한 경우 대체 방법을 시도하거나 시스템 요구사항을 안내합니다"
  - 사용자에게 명확한 안내가 필요합니다

### ✅ 요약 질문

**질문 1: DirectX API의 기본 사용 흐름(Device 생성부터 렌더링까지)을 요약해주세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 전체 이해도를 확인하는 중요한 질문입니다
  - ✅ **정확한 답변**: "D3D11CreateDevice()로 Device와 Context 생성 → Swap Chain 생성 → Render Target View와 Depth Stencil View 생성 → Viewport 설정 → 렌더링 루프(Clear → Set → Draw → Present) 순서로 진행됩니다. 각 단계에서 에러 처리를 반드시 수행해야 합니다"
  - 전체 흐름을 종합적으로 정리할 수 있어야 합니다

### 📊 전체 평가

**강점:**
- Device와 Context의 기본 역할 이해
- RTV, DSV의 기본 개념 이해
- DrawIndexed()와 Draw()의 차이 이해
- 멀티 렌더 타겟 가능성 인지

**개선 필요:**
- ❌ HRESULT를 "핸들러"로 오해 (32비트 반환값)
- ❌ HRESULT 확인 방법 오개념 (E_FAIL이 아니면 성공이라는 잘못된 이해)
- ⚠️ 여러 답변이 너무 간단하거나 모호함 (RTV, DSV 정의 등)
- ⚠️ Render Target 변경 성능 영향에 대한 부정확한 답변
- 💡 일부 답변의 구체성 부족
- ❌ 답변 누락: 초기화 과정, Device 생성 파라미터, Swap Chain 전반, Viewport 전반, 렌더링 루프 구조, 에러 처리, 성능 최적화, 실무 판단 질문들, 요약 질문

**우선순위:**
1. **높음**: HRESULT 개념 정리, 초기화 과정 전체 흐름 이해, Swap Chain 개념과 사용법, Viewport 개념 정리, 렌더링 루프 구조 이해, 답변 누락된 질문들 작성
2. **중간**: 에러 처리 방법 정리, Device 생성 파라미터 이해, 성능 최적화 고려사항
3. **낮음**: 답변의 구체성과 완성도 향상

**특별 주의사항:**
- HRESULT는 함수 호출 결과를 나타내는 32비트 값이며, SUCCEEDED()/FAILED() 매크로로 확인합니다
- DirectX 초기화 순서: Device/Context 생성 → Swap Chain → RTV → DSV → Viewport
- 렌더링 루프: Clear → Set Render Target → Set Shaders → Set Buffers → Draw → Present
- Render Target과 Viewport의 차이: Render Target은 렌더링할 텍스처, Viewport는 화면 표시 영역
- 모든 DirectX API 호출에 에러 처리가 필수입니다

## 📝 모범 답변

### ✅ 기본 개념

1. Device(ID3D11Device), Context(ID3D11DeviceContext), Swap Chain(IDXGISwapChain)이 핵심 객체입니다.

2. Device는 리소스를 생성하고, Context는 렌더링 명령을 기록하고 실행합니다.

3. D3D11CreateDevice()로 Device와 Context 생성 → Swap Chain 생성 → Render Target View 생성 → Depth Stencil View 생성 → Viewport 설정 순서로 진행됩니다.

### ✅ Device 생성

1. Direct3D 11 Device와 Immediate Context를 생성하는 함수입니다.

2. 드라이버 타입(D3D_DRIVER_TYPE), Feature Level 배열, 디버그 플래그, 생성할 Device 버전 등이 주요 파라미터입니다.

3. HRESULT를 확인하고, 실패 시 에러 메시지를 출력하거나 대체 방법을 시도합니다.

4. 하드웨어가 지원하는 DirectX 기능 수준을 나타내며, 낮은 Feature Level을 선택하면 더 많은 하드웨어에서 동작합니다.

### ✅ Swap Chain

1. 백 버퍼와 프론트 버퍼를 관리하여 화면에 이미지를 표시하는 객체입니다.

2. 더블 버퍼링을 구현하여 화면 깜빡임을 방지하고 부드러운 렌더링을 제공하기 위함입니다.

3. BufferDesc(해상도, 포맷), SampleDesc(멀티샘플링), BufferUsage, SwapEffect, Windowed 등이 주요 멤버입니다.

4. 백 버퍼와 프론트 버퍼를 교체하여 화면에 렌더링된 결과를 표시합니다.

### ✅ Render Target View

1. 렌더링 결과를 저장할 텍스처를 GPU에 바인딩하는 뷰 객체입니다.

2. 렌더링할 대상을 GPU에 알려주기 위해 필요합니다.

3. CreateRenderTargetView()로 생성하고, OMSetRenderTargets()로 Context에 설정합니다.

4. 네, DirectX 11에서는 최대 8개의 Render Target을 동시에 사용할 수 있습니다(MRT).

### ✅ Depth Stencil View

1. 깊이 테스트와 스텐실 테스트를 위한 뷰 객체입니다.

2. 3D 장면에서 가려진 객체를 올바르게 렌더링하기 위해 필요합니다.

3. Depth Buffer는 깊이 정보를 저장하고, Stencil Buffer는 특정 영역을 마스킹하는 데 사용됩니다.

4. CreateDepthStencilView()로 생성하고, OMSetRenderTargets()의 두 번째 파라미터로 설정합니다.

### ✅ Viewport

1. 렌더링 결과가 화면의 어느 영역에 표시될지를 정의하는 영역입니다.

2. 화면의 일부 영역에만 렌더링하거나, 여러 카메라 뷰를 동시에 표시하기 위해 사용합니다.

3. TopLeftX, TopLeftY(시작 위치), Width, Height(크기), MinDepth, MaxDepth(깊이 범위)가 주요 속성입니다.

4. 네, DirectX 11에서는 여러 Viewport를 동시에 사용할 수 있습니다.

### ✅ 기본 렌더링 루프

1. Clear → Set Render Target → Set Shaders → Set Buffers → Draw → Present 순서로 진행됩니다.

2. ClearRenderTargetView()는 Render Target을 특정 색상으로 초기화하고, ClearDepthStencilView()는 Depth/Stencil Buffer를 초기화합니다.

3. DrawIndexed()는 Index Buffer를 사용하여 그리며, Draw()는 Index Buffer 없이 직접 그립니다.

4. 모든 렌더링이 완료된 후, 한 프레임의 마지막에 호출하여 화면에 결과를 표시합니다.

### ✅ 에러 처리

1. 모든 API 호출의 HRESULT 반환값을 확인하고, FAILED() 매크로로 실패 여부를 판단합니다.

2. HRESULT는 함수 호출 결과를 나타내는 32비트 값이며, SUCCEEDED() 또는 FAILED() 매크로로 확인합니다.

3. HRESULT가 실패 코드인지 확인하는 매크로입니다.

4. E_INVALIDARG(잘못된 인자), E_OUTOFMEMORY(메모리 부족), DXGI_ERROR_DEVICE_REMOVED(디바이스 제거) 등이 있습니다.

### ✅ 성능 / 최적화

1. 디버그 모드 사용 여부, Feature Level 선택, 드라이버 타입 선택이 성능에 영향을 줍니다.

2. 버퍼 개수, VSync 사용 여부, 멀티샘플링 설정이 성능에 영향을 줍니다.

3. Render Target 변경은 상태 변경 비용이 발생하므로, 변경 횟수를 최소화해야 합니다.

### ✅ 실무 / 설계 판단

1. 에러 처리, Feature Level 폴백 처리, 다양한 해상도 지원, 리소스 해제가 가장 중요합니다.

2. Swap Chain을 재생성하거나, Viewport를 조정하거나, 해상도에 따라 렌더링 품질을 조정합니다.

3. 사용자 친화적인 에러 메시지를 표시하고, 가능한 경우 대체 방법을 시도하거나 시스템 요구사항을 안내합니다.

### ✅ 요약 질문

1. D3D11CreateDevice()로 Device와 Context 생성 → Swap Chain 생성 → Render Target View와 Depth Stencil View 생성 → Viewport 설정 → 렌더링 루프(Clear → Set → Draw → Present) 순서로 진행됩니다. 각 단계에서 에러 처리를 반드시 수행해야 합니다.

</div>
</details>
