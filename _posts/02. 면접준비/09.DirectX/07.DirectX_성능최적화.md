# 🧠 DirectX 성능 최적화 면접 질문 리스트

## ✅ 기본 개념

1. DirectX 성능 최적화의 목표는 무엇인가요?

    - 원하는 프레임을 방어하기 위함입니다.

2. 그래픽스 성능 병목의 주요 원인은 무엇인가요?

    - CPU에서 GPU로 전달하는 Drawcall 횟수가 가장 병목현상이 큽니다.

3. 성능 프로파일링이 중요한 이유는 무엇인가요?

    - 프레임 방어를 위합니다.

## ✅ Draw Call 최적화

1. Draw Call이란 무엇인가요?

    - CPU에서 GPU로 객체를 그리도록 하는 명령 입니다.

2. Draw Call이 성능에 미치는 영향은 무엇인가요?

    - CPU에서 GPU로 데이터를 넘기기에 예민한 성능 영향을 미칩니다.

3. Draw Call을 줄이는 방법은 무엇인가요?

    - batching이나 instancing같은 최적화 기법이 있습니다.

4. Batching이란 무엇인가요?

    - 다양한 매쉬를 하나의 매쉬로 만들어서 드로우 콜을 줄이는 기법입니다.

5. Instancing이란 무엇인가요?

    - 모두 같은 매쉬와 같은 머터리얼 및 같은 파이프라인 상태를 유지할 때 해당하는 객체를 한꺼번에 그리는 최적화 기법입니다.

6. Batching과 Instancing의 차이는 무엇인가요?

    - 매쉬가 달라도 되는것과 매쉬가 같아야하는 것에 차이가 있습니다.

## ✅ 리소스 바인딩 최적화

1. 리소스 바인딩 변경이 성능에 미치는 영향은 무엇인가요?

    - 

2. 리소스 바인딩을 최적화하는 방법은 무엇인가요?

    - 

3. 리소스를 그룹화하는 기준은 무엇인가요?

    - 

4. Constant Buffer 업데이트를 최적화하는 방법은 무엇인가요?

    - 

## ✅ GPU와 CPU 동기화 최소화

1. GPU와 CPU 동기화가 성능에 미치는 영향은 무엇인가요?

    - 

2. Flush와 Finish의 차이는 무엇인가요?

    - 

3. 동기화를 최소화하는 방법은 무엇인가요?

    - 

4. 여러 프레임을 동시에 처리하는 방법은 무엇인가요?

    - 

5. GPU 타임라인을 최적화하는 방법은 무엇인가요?

    - 

## ✅ 메모리 관리 최적화

1. GPU 메모리 관리가 중요한 이유는 무엇인가요?

    - 

2. 텍스처 압축의 장점은 무엇인가요?

    - 

3. 텍스처 포맷을 선택하는 기준은 무엇인가요?

    - 

4. 메모리 풀링을 사용하는 이유는 무엇인가요?

    - 

5. 리소스 업로드를 최적화하는 방법은 무엇인가요?

    - 

## ✅ 셰이더 최적화

1. 셰이더 성능을 최적화하는 방법은 무엇인가요?

    - 

2. 셰이더에서 브랜치의 성능 영향은 무엇인가요?

    - 

3. 셰이더에서 루프를 최적화하는 방법은 무엇인가요?

    - 

4. 셰이더 컴파일 최적화는 어떻게 하나요?

    - 

## ✅ 렌더링 상태 최적화

1. 렌더링 상태 변경이 성능에 미치는 영향은 무엇인가요?

    - 

2. 상태 변경을 최소화하는 방법은 무엇인가요?

    - 

3. Pipeline State Object를 사용하는 이유는 무엇인가요?

    - 

4. 상태를 그룹화하는 기준은 무엇인가요?

    - 

## ✅ Culling과 Occlusion

1. Frustum Culling이란 무엇인가요?

    - 

2. Occlusion Culling이란 무엇인가요?

    - 

3. Culling을 최적화하는 방법은 무엇인가요?

    - 

4. Hierarchical Z-Buffer의 역할은 무엇인가요?

    - 

## ✅ LOD (Level of Detail)

1. LOD란 무엇인가요?

    - 

2. LOD를 사용하는 이유는 무엇인가요?

    - 

3. LOD 전환 시 주의사항은 무엇인가요?

    - 

4. LOD를 자동으로 생성하는 방법은 무엇인가요?

    - 

## ✅ DirectX 12 특화 최적화

1. DirectX 12에서 성능을 최적화하는 방법은 무엇인가요?

    - 

2. Multi-threaded command recording을 최적화하는 방법은 무엇인가요?

    - 

3. Resource Barrier를 최적화하는 방법은 무엇인가요?

    - 

4. Descriptor Heap 사용을 최적화하는 방법은 무엇인가요?

    - 

## ✅ 성능 측정과 프로파일링

1. 그래픽스 성능을 측정하는 도구는 무엇인가요?

    - 

2. GPU 프로파일링의 중요성은 무엇인가요?

    - 

3. 병목 지점을 찾는 방법은 무엇인가요?

    - 

4. 성능 측정 시 주의사항은 무엇인가요?

    - 

## ✅ 실무 / 설계 판단

1. 성능 최적화를 시작할 때 어떤 순서로 접근해야 하나요?

    - 

2. Draw Call 최적화와 셰이더 최적화 중 어느 것이 더 중요할까요?

    - 

3. 성능 최적화와 코드 가독성 사이의 균형을 어떻게 맞춰야 하나요?

    - 

4. 레거시 프로젝트의 성능을 최적화할 때 고려사항은 무엇인가요?

    - 

## ✅ 요약 질문

1. DirectX 성능 최적화의 핵심 원칙과 주요 기법을 요약해주세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. GPU 활용도를 극대화하고, CPU 오버헤드를 최소화하며, 프레임 시간을 안정적으로 유지하는 것이 목표입니다.

2. Draw Call 과다, GPU와 CPU 동기화, 리소스 바인딩 변경, 셰이더 복잡도, 메모리 대역폭 부족 등이 주요 원인입니다.

3. 실제 병목 지점을 정확히 파악하고, 최적화의 효과를 측정하며, 불필요한 최적화를 피하기 위함입니다.

### ✅ Draw Call 최적화

1. GPU에 그리기 명령을 전송하는 작업으로, 각 Draw Call마다 상태 설정과 명령 전송 비용이 발생합니다.

2. Draw Call마다 CPU 오버헤드가 발생하고, 상태 변경 비용이 누적되어 성능이 저하됩니다.

3. Batching, Instancing, Geometry Shader 활용, 텍스처 아틀라스 사용 등으로 Draw Call을 줄입니다.

4. 같은 재질과 상태를 가진 객체들을 하나의 Draw Call로 묶어서 그리는 기법입니다.

5. 같은 메시를 여러 번 그리되, 인스턴스별로 다른 변환 행렬을 사용하여 그리는 기법입니다.

6. Batching은 여러 객체를 하나로 합쳐서 그리는 것이고, Instancing은 같은 메시를 여러 번 효율적으로 그리는 것입니다.

### ✅ 리소스 바인딩 최적화

1. 리소스 바인딩 변경은 상태 변경 비용이 발생하므로, 변경 횟수가 많을수록 성능이 저하됩니다.

2. 리소스를 사용 빈도와 업데이트 주기에 따라 그룹화하고, 바인딩 변경을 최소화하며, Descriptor Table을 활용합니다.

3. 재질별, 업데이트 주기별, 사용 빈도별로 그룹화하여 바인딩 변경을 최소화합니다.

4. Map() 호출 횟수를 최소화하고, 가능한 경우 한 번에 여러 데이터를 업데이트하며, 불필요한 업데이트를 피합니다.

### ✅ GPU와 CPU 동기화 최소화

1. GPU와 CPU가 서로 대기하게 되어 성능이 저하되고, GPU 활용도가 낮아집니다.

2. Flush는 명령을 즉시 제출하지만 완료를 기다리지 않고, Finish는 명령 완료를 기다립니다.

3. 동기화를 최소화하고, 필요한 경우에만 동기화하며, 여러 작업을 배치하여 동기화 횟수를 줄입니다.

4. 여러 프레임의 명령을 미리 기록하고, GPU가 여러 프레임을 파이프라인으로 처리하도록 합니다.

5. GPU 작업을 최대한 병렬화하고, Resource Barrier를 최적화하며, Command List를 효율적으로 기록합니다.

### ✅ 메모리 관리 최적화

1. GPU 메모리는 제한적이며, 메모리 부족 시 성능이 크게 저하되거나 크래시가 발생할 수 있습니다.

2. 메모리 사용량 감소, 메모리 대역폭 절약, 로딩 시간 단축이 장점입니다.

3. 메모리 사용량, 색상 정밀도, 압축 지원 여부, 하드웨어 지원 여부를 고려하여 선택합니다.

4. 리소스 생성/해제 비용을 줄이고, 메모리 단편화를 방지하며, 메모리 사용을 예측 가능하게 하기 위함입니다.

5. 리소스를 미리 업로드하고, 업로드 버퍼를 재사용하며, 여러 리소스를 배치하여 업로드합니다.

### ✅ 셰이더 최적화

1. 브랜치 최소화, 루프 최적화, 불필요한 계산 제거, 텍스처 샘플링 최적화, 레지스터 사용 최적화가 필요합니다.

2. 셰이더에서 브랜치는 성능 저하를 유발하므로, 가능한 경우 브랜치를 피하거나 동적 브랜치 대신 정적 브랜치를 사용합니다.

3. 루프 횟수를 최소화하고, 루프 언롤링을 활용하며, 루프 내부 계산을 최적화합니다.

4. 셰이더를 미리 컴파일하고, 셰이더 캐시를 활용하며, 최적화 플래그를 사용합니다.

### ✅ 렌더링 상태 최적화

1. 렌더링 상태 변경은 비용이 발생하므로, 변경 횟수가 많을수록 성능이 저하됩니다.

2. 상태를 그룹화하고, 상태 변경을 최소화하며, Pipeline State Object를 사전에 생성하여 사용합니다.

3. 여러 상태를 하나의 객체로 묶어서 상태 변경 비용을 줄이고, 상태 일관성을 보장하기 위함입니다.

4. 재질별, 렌더링 패스별로 그룹화하여 상태 변경을 최소화합니다.

### ✅ Culling과 Occlusion

1. 카메라의 시야 밖에 있는 객체를 제거하는 기법입니다.

2. 가려진 객체를 제거하여 불필요한 렌더링을 방지하는 기법입니다.

3. 공간 분할 구조(Octree, BSP)를 사용하고, 계층적 Culling을 수행하며, GPU Culling을 활용합니다.

4. 깊이 정보를 계층적으로 관리하여 Occlusion Culling을 빠르게 수행하는 기법입니다.

### ✅ LOD (Level of Detail)

1. 거리에 따라 객체의 디테일 수준을 조절하는 기법입니다.

2. 거리가 먼 객체의 디테일을 줄여서 렌더링 비용을 절감하기 위함입니다.

3. LOD 전환이 눈에 띄지 않도록 부드럽게 전환하고, 히스테리시스를 적용하여 깜빡임을 방지합니다.

4. 메시를 자동으로 단순화하는 알고리즘을 사용하거나, 아티스트가 수동으로 생성합니다.

### ✅ DirectX 12 특화 최적화

1. Multi-threaded command recording, Resource Barrier 최적화, Descriptor Heap 효율적 사용, GPU 타임라인 최적화가 필요합니다.

2. 독립적인 렌더링 작업을 잘 분리하고, Command List 생성 비용을 고려하며, CPU 코어 수에 맞게 스레드 수를 조정합니다.

3. 불필요한 전환을 피하고, 전환을 배치하여 수행하며, 리소스 사용 패턴을 최적화합니다.

4. Descriptor를 재사용하고, Descriptor Heap을 효율적으로 관리하며, Descriptor Table을 활용합니다.

### ✅ 성능 측정과 프로파일링

1. PIX, GPUView, RenderDoc, Nsight, Intel GPA 등이 주요 도구입니다.

2. 실제 GPU 작업을 분석하여 병목 지점을 정확히 파악하고, 최적화의 효과를 측정하기 위함입니다.

3. 프로파일링 도구를 사용하여 GPU 타임라인을 분석하고, 각 단계의 시간을 측정하며, 병목 지점을 식별합니다.

4. 여러 번 측정하여 평균을 내고, 다양한 시나리오에서 테스트하며, 실제 플레이 환경을 반영해야 합니다.

### ✅ 실무 / 설계 판단

1. 프로파일링으로 병목 지점 파악 → 가장 큰 영향의 병목부터 해결 → 효과 측정 → 반복 순서로 접근합니다.

2. 프로젝트 상황에 따라 다르지만, 일반적으로 Draw Call 최적화가 먼저 효과가 크고, 그 다음 셰이더 최적화를 진행합니다.

3. 최적화는 측정 가능한 성능 향상이 있을 때만 수행하고, 코드 가독성을 해치지 않는 선에서 최적화하며, 주석과 문서화를 통해 유지보수성을 확보합니다.

4. 레거시 코드의 구조를 이해하고, 점진적으로 최적화하며, 리팩토링과 최적화를 함께 진행하고, 테스트를 철저히 수행합니다.

### ✅ 요약 질문

1. DirectX 성능 최적화는 Draw Call 최소화, 리소스 바인딩 최적화, GPU-CPU 동기화 최소화, 메모리 관리 최적화, 셰이더 최적화가 핵심입니다. 프로파일링으로 병목을 정확히 파악한 후, 가장 큰 영향의 병목부터 해결하는 것이 중요합니다. 최적화는 측정 가능한 성능 향상이 있을 때만 수행하고, 코드 가독성과 유지보수성을 고려해야 합니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: DirectX 성능 최적화의 목표는 무엇인가요?**
- **현재 답변**: "원하는 프레임을 방어하기 위함입니다"
- **피드백**:
  - 💡 **보완**: 더 구체적인 목표를 설명하면 좋습니다
  - ✅ **정확한 답변**: "GPU 활용도를 극대화하고, CPU 오버헤드를 최소화하며, 프레임 시간을 안정적으로 유지하는 것이 목표입니다"
  - 프레임 방어는 결과이고, GPU 활용도 극대화와 CPU 오버헤드 최소화가 핵심 목표입니다

**질문 2: 그래픽스 성능 병목의 주요 원인은 무엇인가요?**
- **현재 답변**: "CPU에서 GPU로 전달하는 Drawcall 횟수가 가장 병목현상이 큽니다"
- **피드백**:
  - ⚠️ **부정확**: Draw Call이 주요 원인 중 하나이지만, "가장"이라고 단정하기 어렵습니다. 상황에 따라 다른 병목이 더 클 수 있습니다
  - ✅ **정확한 답변**: "Draw Call 과다, GPU와 CPU 동기화, 리소스 바인딩 변경, 셰이더 복잡도, 메모리 대역폭 부족 등이 주요 원인입니다"
  - 프로파일링을 통해 실제 병목 지점을 파악하는 것이 중요합니다

**질문 3: 성능 프로파일링이 중요한 이유는 무엇인가요?**
- **현재 답변**: "프레임 방어를 위합니다"
- **피드백**:
  - ⚠️ **부정확**: 너무 단순한 설명입니다. 프로파일링의 구체적인 목적을 설명해야 합니다
  - ✅ **정확한 답변**: "실제 병목 지점을 정확히 파악하고, 최적화의 효과를 측정하며, 불필요한 최적화를 피하기 위함입니다"
  - 추측이 아닌 데이터 기반으로 최적화해야 합니다

### ✅ Draw Call 최적화

**질문 2: Draw Call이 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: "CPU에서 GPU로 데이터를 넘기기에 예민한 성능 영향을 미칩니다"
- **피드백**:
  - 💡 **보완**: 더 구체적으로 설명하면 좋습니다
  - ✅ **정확한 답변**: "Draw Call마다 CPU 오버헤드가 발생하고, 상태 변경 비용이 누적되어 성능이 저하됩니다"
  - 각 Draw Call마다 상태 설정과 명령 전송 비용이 발생하며, 이 비용이 누적됩니다

**질문 3: Draw Call을 줄이는 방법은 무엇인가요?**
- **현재 답변**: "batching이나 instancing같은 최적화 기법이 있습니다"
- **피드백**:
  - 💡 **보완**: 더 많은 방법을 언급하면 좋습니다
  - ✅ **정확한 답변**: "Batching, Instancing, Geometry Shader 활용, 텍스처 아틀라스 사용 등으로 Draw Call을 줄입니다"
  - Geometry Shader와 텍스처 아틀라스도 중요한 최적화 기법입니다

**질문 4: Batching이란 무엇인가요?**
- **현재 답변**: "다양한 매쉬를 하나의 매쉬로 만들어서 드로우 콜을 줄이는 기법입니다"
- **피드백**:
  - ⚠️ **부정확**: 매쉬만이 아니라 재질과 상태도 중요합니다
  - ✅ **정확한 답변**: "같은 재질과 상태를 가진 객체들을 하나의 Draw Call로 묶어서 그리는 기법입니다"
  - 매쉬뿐만 아니라 재질(material)과 렌더링 상태도 같아야 효율적입니다

**질문 6: Batching과 Instancing의 차이는 무엇인가요?**
- **현재 답변**: "매쉬가 달라도 되는것과 매쉬가 같아야하는 것에 차이가 있습니다"
- **피드백**:
  - ⚠️ **부정확**: 차이점을 더 명확히 설명해야 합니다
  - ✅ **정확한 답변**: "Batching은 여러 객체를 하나로 합쳐서 그리는 것이고, Instancing은 같은 메시를 여러 번 효율적으로 그리는 것입니다"
  - Batching은 여러 객체를 합치는 것이고, Instancing은 같은 메시를 여러 번 그리는 것입니다

### ✅ 리소스 바인딩 최적화

**질문 1: 리소스 바인딩 변경이 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 리소스 바인딩 최적화의 핵심 개념입니다
  - ✅ **정확한 답변**: "리소스 바인딩 변경은 상태 변경 비용이 발생하므로, 변경 횟수가 많을수록 성능이 저하됩니다"
  - 바인딩 변경은 상태 변경의 일종으로 CPU 오버헤드가 발생합니다

**질문 2: 리소스 바인딩을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 최적화 기법입니다
  - ✅ **정확한 답변**: "리소스를 사용 빈도와 업데이트 주기에 따라 그룹화하고, 바인딩 변경을 최소화하며, Descriptor Table을 활용합니다"
  - DirectX 12에서는 Descriptor Table을 활용하여 바인딩을 효율적으로 관리합니다

**질문 3: 리소스를 그룹화하는 기준은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 리소스 관리의 핵심 개념입니다
  - ✅ **정확한 답변**: "재질별, 업데이트 주기별, 사용 빈도별로 그룹화하여 바인딩 변경을 최소화합니다"
  - 같은 재질이나 같은 업데이트 주기를 가진 리소스를 함께 사용하면 바인딩 변경을 줄일 수 있습니다

**질문 4: Constant Buffer 업데이트를 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Constant Buffer는 자주 업데이트되므로 최적화가 중요합니다
  - ✅ **정확한 답변**: "Map() 호출 횟수를 최소화하고, 가능한 경우 한 번에 여러 데이터를 업데이트하며, 불필요한 업데이트를 피합니다"
  - Map() 호출 자체가 비용이 있으므로, 한 번에 여러 데이터를 업데이트하는 것이 효율적입니다

### ✅ GPU와 CPU 동기화 최소화

**질문 1: GPU와 CPU 동기화가 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 핵심 개념입니다
  - ✅ **정확한 답변**: "GPU와 CPU가 서로 대기하게 되어 성능이 저하되고, GPU 활용도가 낮아집니다"
  - 동기화는 GPU와 CPU가 서로 기다리게 하여 파이프라인을 막습니다

**질문 2: Flush와 Finish의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 동기화 관련 중요한 개념입니다
  - ✅ **정확한 답변**: "Flush는 명령을 즉시 제출하지만 완료를 기다리지 않고, Finish는 명령 완료를 기다립니다"
  - Flush는 비동기, Finish는 동기화를 의미합니다

**질문 3: 동기화를 최소화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 핵심 기법입니다
  - ✅ **정확한 답변**: "동기화를 최소화하고, 필요한 경우에만 동기화하며, 여러 작업을 배치하여 동기화 횟수를 줄입니다"
  - 불필요한 동기화를 피하고, 여러 작업을 배치하여 동기화 횟수를 최소화합니다

**질문 4: 여러 프레임을 동시에 처리하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 고급 최적화 기법입니다
  - ✅ **정확한 답변**: "여러 프레임의 명령을 미리 기록하고, GPU가 여러 프레임을 파이프라인으로 처리하도록 합니다"
  - 여러 프레임의 명령을 미리 준비하여 GPU 파이프라인을 최대한 활용합니다

**질문 5: GPU 타임라인을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12에서 중요한 최적화 기법입니다
  - ✅ **정확한 답변**: "GPU 작업을 최대한 병렬화하고, Resource Barrier를 최적화하며, Command List를 효율적으로 기록합니다"
  - Resource Barrier 최적화와 Command List 효율적 기록이 핵심입니다

### ✅ 메모리 관리 최적화

**질문 1: GPU 메모리 관리가 중요한 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 메모리 관리의 기본 개념입니다
  - ✅ **정확한 답변**: "GPU 메모리는 제한적이며, 메모리 부족 시 성능이 크게 저하되거나 크래시가 발생할 수 있습니다"
  - GPU 메모리는 제한적이므로 효율적인 관리가 필수입니다

**질문 2: 텍스처 압축의 장점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 메모리 최적화의 기본 기법입니다
  - ✅ **정확한 답변**: "메모리 사용량 감소, 메모리 대역폭 절약, 로딩 시간 단축이 장점입니다"
  - 텍스처 압축은 메모리와 대역폭을 모두 절약합니다

**질문 3: 텍스처 포맷을 선택하는 기준은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 판단 기준입니다
  - ✅ **정확한 답변**: "메모리 사용량, 색상 정밀도, 압축 지원 여부, 하드웨어 지원 여부를 고려하여 선택합니다"
  - 품질과 성능 사이의 트레이드오프를 고려해야 합니다

**질문 4: 메모리 풀링을 사용하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 메모리 관리 최적화 기법입니다
  - ✅ **정확한 답변**: "리소스 생성/해제 비용을 줄이고, 메모리 단편화를 방지하며, 메모리 사용을 예측 가능하게 하기 위함입니다"
  - 메모리 풀링은 할당/해제 비용과 단편화를 줄입니다

**질문 5: 리소스 업로드를 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 리소스 로딩 최적화 기법입니다
  - ✅ **정확한 답변**: "리소스를 미리 업로드하고, 업로드 버퍼를 재사용하며, 여러 리소스를 배치하여 업로드합니다"
  - 배치 업로드와 버퍼 재사용이 핵심입니다

### ✅ 셰이더 최적화

**질문 1: 셰이더 성능을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 셰이더 최적화의 핵심 기법입니다
  - ✅ **정확한 답변**: "브랜치 최소화, 루프 최적화, 불필요한 계산 제거, 텍스처 샘플링 최적화, 레지스터 사용 최적화가 필요합니다"
  - 셰이더 최적화는 여러 측면에서 접근해야 합니다

**질문 2: 셰이더에서 브랜치의 성능 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 셰이더 최적화의 중요한 개념입니다
  - ✅ **정확한 답변**: "셰이더에서 브랜치는 성능 저하를 유발하므로, 가능한 경우 브랜치를 피하거나 동적 브랜치 대신 정적 브랜치를 사용합니다"
  - GPU는 SIMD 구조이므로 브랜치는 성능 저하를 유발합니다

**질문 3: 셰이더에서 루프를 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 셰이더 최적화 기법입니다
  - ✅ **정확한 답변**: "루프 횟수를 최소화하고, 루프 언롤링을 활용하며, 루프 내부 계산을 최적화합니다"
  - 루프 언롤링은 컴파일러가 자동으로 수행하지만, 루프 횟수 최소화도 중요합니다

**질문 4: 셰이더 컴파일 최적화는 어떻게 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 개발 단계에서 중요한 최적화입니다
  - ✅ **정확한 답변**: "셰이더를 미리 컴파일하고, 셰이더 캐시를 활용하며, 최적화 플래그를 사용합니다"
  - 런타임 컴파일 비용을 줄이기 위해 미리 컴파일하는 것이 중요합니다

### ✅ 렌더링 상태 최적화

**질문 1: 렌더링 상태 변경이 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 상태 최적화의 기본 개념입니다
  - ✅ **정확한 답변**: "렌더링 상태 변경은 비용이 발생하므로, 변경 횟수가 많을수록 성능이 저하됩니다"
  - 상태 변경은 CPU 오버헤드를 발생시킵니다

**질문 2: 상태 변경을 최소화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 상태 최적화의 핵심 기법입니다
  - ✅ **정확한 답변**: "상태를 그룹화하고, 상태 변경을 최소화하며, Pipeline State Object를 사전에 생성하여 사용합니다"
  - DirectX 12의 PSO를 사전에 생성하여 사용하면 효율적입니다

**질문 3: Pipeline State Object를 사용하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12의 핵심 개념입니다
  - ✅ **정확한 답변**: "여러 상태를 하나의 객체로 묶어서 상태 변경 비용을 줄이고, 상태 일관성을 보장하기 위함입니다"
  - PSO는 여러 상태를 묶어서 한 번에 변경할 수 있게 합니다

**질문 4: 상태를 그룹화하는 기준은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 상태 최적화의 실무 기법입니다
  - ✅ **정확한 답변**: "재질별, 렌더링 패스별로 그룹화하여 상태 변경을 최소화합니다"
  - 같은 재질이나 같은 렌더링 패스의 객체를 함께 렌더링하면 상태 변경을 줄일 수 있습니다

### ✅ Culling과 Occlusion

**질문 1: Frustum Culling이란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Culling의 기본 개념입니다
  - ✅ **정확한 답변**: "카메라의 시야 밖에 있는 객체를 제거하는 기법입니다"
  - 시야 밖 객체를 미리 제거하여 불필요한 렌더링을 방지합니다

**질문 2: Occlusion Culling이란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Culling의 고급 기법입니다
  - ✅ **정확한 답변**: "가려진 객체를 제거하여 불필요한 렌더링을 방지하는 기법입니다"
  - 다른 객체에 가려진 객체를 제거하여 렌더링 비용을 절감합니다

**질문 3: Culling을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Culling 최적화 기법입니다
  - ✅ **정확한 답변**: "공간 분할 구조(Octree, BSP)를 사용하고, 계층적 Culling을 수행하며, GPU Culling을 활용합니다"
  - 공간 분할 구조를 사용하면 효율적으로 Culling을 수행할 수 있습니다

**질문 4: Hierarchical Z-Buffer의 역할은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: Occlusion Culling의 고급 기법입니다
  - ✅ **정확한 답변**: "깊이 정보를 계층적으로 관리하여 Occlusion Culling을 빠르게 수행하는 기법입니다"
  - 계층적 깊이 정보를 사용하여 빠르게 가려진 객체를 판단합니다

### ✅ LOD (Level of Detail)

**질문 1: LOD란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: LOD의 기본 개념입니다
  - ✅ **정확한 답변**: "거리에 따라 객체의 디테일 수준을 조절하는 기법입니다"
  - 거리가 먼 객체는 낮은 디테일로 렌더링하여 비용을 절감합니다

**질문 2: LOD를 사용하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: LOD 사용의 목적입니다
  - ✅ **정확한 답변**: "거리가 먼 객체의 디테일을 줄여서 렌더링 비용을 절감하기 위함입니다"
  - 시각적 차이가 거의 없으면서도 렌더링 비용을 크게 줄일 수 있습니다

**질문 3: LOD 전환 시 주의사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: LOD 구현 시 중요한 고려사항입니다
  - ✅ **정확한 답변**: "LOD 전환이 눈에 띄지 않도록 부드럽게 전환하고, 히스테리시스를 적용하여 깜빡임을 방지합니다"
  - 히스테리시스(여유값)를 적용하여 LOD 전환 시 깜빡임을 방지합니다

**질문 4: LOD를 자동으로 생성하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: LOD 생성 기법입니다
  - ✅ **정확한 답변**: "메시를 자동으로 단순화하는 알고리즘을 사용하거나, 아티스트가 수동으로 생성합니다"
  - 자동 단순화 알고리즘(예: Quadric Error Metric)을 사용할 수 있습니다

### ✅ DirectX 12 특화 최적화

**질문 1: DirectX 12에서 성능을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12의 핵심 최적화 기법입니다
  - ✅ **정확한 답변**: "Multi-threaded command recording, Resource Barrier 최적화, Descriptor Heap 효율적 사용, GPU 타임라인 최적화가 필요합니다"
  - DirectX 12의 저수준 제어를 활용한 최적화가 핵심입니다

**질문 2: Multi-threaded command recording을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12 멀티스레딩 최적화입니다
  - ✅ **정확한 답변**: "독립적인 렌더링 작업을 잘 분리하고, Command List 생성 비용을 고려하며, CPU 코어 수에 맞게 스레드 수를 조정합니다"
  - 작업 분리와 스레드 수 조정이 핵심입니다

**질문 3: Resource Barrier를 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12의 중요한 최적화 기법입니다
  - ✅ **정확한 답변**: "불필요한 전환을 피하고, 전환을 배치하여 수행하며, 리소스 사용 패턴을 최적화합니다"
  - Resource Barrier는 비용이 있으므로 배치하여 수행하는 것이 중요합니다

**질문 4: Descriptor Heap 사용을 최적화하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: DirectX 12의 핵심 개념입니다
  - ✅ **정확한 답변**: "Descriptor를 재사용하고, Descriptor Heap을 효율적으로 관리하며, Descriptor Table을 활용합니다"
  - Descriptor 관리가 DirectX 12 성능에 큰 영향을 미칩니다

### ✅ 성능 측정과 프로파일링

**질문 1: 그래픽스 성능을 측정하는 도구는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 기본 도구입니다
  - ✅ **정확한 답변**: "PIX, GPUView, RenderDoc, Nsight, Intel GPA 등이 주요 도구입니다"
  - 각 도구는 다른 목적과 강점을 가지고 있습니다

**질문 2: GPU 프로파일링의 중요성은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 핵심 개념입니다
  - ✅ **정확한 답변**: "실제 GPU 작업을 분석하여 병목 지점을 정확히 파악하고, 최적화의 효과를 측정하기 위함입니다"
  - CPU 프로파일링만으로는 GPU 병목을 파악할 수 없습니다

**질문 3: 병목 지점을 찾는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화의 핵심 프로세스입니다
  - ✅ **정확한 답변**: "프로파일링 도구를 사용하여 GPU 타임라인을 분석하고, 각 단계의 시간을 측정하며, 병목 지점을 식별합니다"
  - GPU 타임라인 분석을 통해 병목 지점을 정확히 파악할 수 있습니다

**질문 4: 성능 측정 시 주의사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 정확한 성능 측정을 위한 중요 사항입니다
  - ✅ **정확한 답변**: "여러 번 측정하여 평균을 내고, 다양한 시나리오에서 테스트하며, 실제 플레이 환경을 반영해야 합니다"
  - 일회성 측정보다는 다양한 환경에서 반복 측정이 중요합니다

### ✅ 실무 / 설계 판단

**질문 1: 성능 최적화를 시작할 때 어떤 순서로 접근해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 접근 방법입니다
  - ✅ **정확한 답변**: "프로파일링으로 병목 지점 파악 → 가장 큰 영향의 병목부터 해결 → 효과 측정 → 반복 순서로 접근합니다"
  - 추측이 아닌 데이터 기반으로 우선순위를 정해야 합니다

**질문 2: Draw Call 최적화와 셰이더 최적화 중 어느 것이 더 중요할까요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 판단 기준입니다
  - ✅ **정확한 답변**: "프로젝트 상황에 따라 다르지만, 일반적으로 Draw Call 최적화가 먼저 효과가 크고, 그 다음 셰이더 최적화를 진행합니다"
  - 프로파일링을 통해 실제 병목을 파악한 후 결정해야 합니다

**질문 3: 성능 최적화와 코드 가독성 사이의 균형을 어떻게 맞춰야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 고려사항입니다
  - ✅ **정확한 답변**: "최적화는 측정 가능한 성능 향상이 있을 때만 수행하고, 코드 가독성을 해치지 않는 선에서 최적화하며, 주석과 문서화를 통해 유지보수성을 확보합니다"
  - 성능과 유지보수성 사이의 균형이 중요합니다

**질문 4: 레거시 프로젝트의 성능을 최적화할 때 고려사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 자주 마주치는 상황입니다
  - ✅ **정확한 답변**: "레거시 코드의 구조를 이해하고, 점진적으로 최적화하며, 리팩토링과 최적화를 함께 진행하고, 테스트를 철저히 수행합니다"
  - 레거시 코드는 신중하게 접근해야 합니다

### ✅ 요약 질문

**질문 1: DirectX 성능 최적화의 핵심 원칙과 주요 기법을 요약해주세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 전체적인 이해도를 평가하는 종합 질문입니다
  - ✅ **정확한 답변**: "DirectX 성능 최적화는 Draw Call 최소화, 리소스 바인딩 최적화, GPU-CPU 동기화 최소화, 메모리 관리 최적화, 셰이더 최적화가 핵심입니다. 프로파일링으로 병목을 정확히 파악한 후, 가장 큰 영향의 병목부터 해결하는 것이 중요합니다. 최적화는 측정 가능한 성능 향상이 있을 때만 수행하고, 코드 가독성과 유지보수성을 고려해야 합니다"

### 📊 전체 평가

**강점:**
- ✅ Draw Call의 기본 개념 이해
- ✅ Batching과 Instancing의 기본 개념 이해
- ✅ Instancing의 조건(같은 메시, 머터리얼, 파이프라인 상태) 정확히 이해

**개선 필요:**
- ⚠️ **부정확한 부분**: 성능 최적화 목표(프레임 방어만 언급), 병목 원인(Draw Call만 언급), 프로파일링 중요성(너무 단순), Batching 정의(재질과 상태 중요성 누락), Batching과 Instancing 차이(명확하지 않음)
- 💡 **개선 필요**: Draw Call 성능 영향, Draw Call 줄이는 방법(더 많은 기법 언급)
- ❌ **답변 누락**: 리소스 바인딩 최적화 4개, GPU-CPU 동기화 5개, 메모리 관리 5개, 셰이더 최적화 4개, 렌더링 상태 최적화 4개, Culling과 Occlusion 4개, LOD 4개, DirectX 12 특화 4개, 성능 측정과 프로파일링 4개, 실무/설계 판단 4개, 요약 질문 1개 (총 43개)

**우선순위:**
1. **높음**: 
   - 답변 누락된 핵심 개념들 답변 작성 (특히 리소스 바인딩, GPU-CPU 동기화, 메모리 관리, 셰이더 최적화)
   - Batching 정의 정확히 이해 (재질과 상태 중요성)
   - 성능 병목 원인 정확히 이해 (Draw Call만이 아닌 다양한 원인)
2. **중간**: 
   - 프로파일링 중요성 구체적으로 이해
   - Batching과 Instancing의 차이 명확히 이해
   - Draw Call 최적화 방법 더 구체적으로 이해
3. **낮음**: 
   - 각 최적화 기법의 구체적인 활용 사례 보완
   - 실무 판단 기준에 대한 답변 작성

**특별 주의사항:**
- 성능 최적화는 프로파일링 없이 시작하면 안 됩니다. 실제 병목 지점을 파악한 후 최적화해야 합니다
- Draw Call이 주요 병목이지만, 상황에 따라 셰이더 복잡도나 메모리 대역폭이 더 큰 병목일 수 있습니다
- Batching은 같은 재질과 상태를 가진 객체를 묶는 것이며, 단순히 매쉬만 합치는 것이 아닙니다
- GPU-CPU 동기화는 성능에 큰 영향을 미치므로 최소화해야 합니다
- DirectX 12의 Resource Barrier와 Descriptor Heap 최적화는 매우 중요합니다
