# 🧠 DirectX 12 특화 면접 질문 리스트

## ✅ 기본 개념

1. DirectX 12의 핵심 특징은 무엇인가요?

    - 

2. DirectX 12가 Low-level API로 변화한 이유는 무엇인가요?

    - 

3. DirectX 12의 장점과 단점은 무엇인가요?

    - 

## ✅ Command Queue

1. Command Queue란 무엇인가요?

    - 

2. Command Queue의 종류는 무엇인가요?

    - 

3. 여러 Command Queue를 사용하는 이유는 무엇인가요?

    - 

4. Command Queue에 명령을 제출하는 방법은 무엇인가요?

    - 

## ✅ Command List와 Command Allocator

1. Command List란 무엇인가요?

    - 

2. Command Allocator란 무엇인가요?

    - 

3. Command List와 Command Allocator의 관계는 무엇인가요?

    - 

4. Command List를 기록하고 실행하는 방법은 무엇인가요?

    - 

5. Command List를 재사용하는 방법은 무엇인가요?

    - 

## ✅ Resource Barrier

1. Resource Barrier란 무엇인가요?

    - 

2. Resource Barrier가 필요한 이유는 무엇인가요?

    - 

3. Resource Barrier의 주요 타입은 무엇인가요?

    - 

4. Resource Barrier를 올바르게 사용하는 방법은 무엇인가요?

    - 

5. Resource Barrier의 성능 영향은 무엇인가요?

    - 

## ✅ Descriptor Heap

1. Descriptor Heap이란 무엇인가요?

    - 

2. Descriptor Heap의 종류는 무엇인가요?

    - 

3. Descriptor Heap을 사용하는 이유는 무엇인가요?

    - 

4. Descriptor Heap을 생성하고 사용하는 방법은 무엇인가요?

    - 

5. Descriptor Heap의 크기 제한은 무엇인가요?

    - 

## ✅ Root Signature

1. Root Signature란 무엇인가요?

    - 

2. Root Signature를 사용하는 이유는 무엇인가요?

    - 

3. Root Signature의 구성 요소는 무엇인가요?

    - 

4. Root Signature를 생성하고 설정하는 방법은 무엇인가요?

    - 

5. Root Signature의 성능 영향은 무엇인가요?

    - 

## ✅ Pipeline State Object

1. Pipeline State Object(PSO)란 무엇인가요?

    - 

2. PSO를 사용하는 이유는 무엇인가요?

    - 

3. PSO의 구성 요소는 무엇인가요?

    - 

4. PSO를 생성하고 사용하는 방법은 무엇인가요?

    - 

5. PSO 변경의 성능 영향은 무엇인가요?

    - 

## ✅ Multi-threaded Command Recording

1. Multi-threaded Command Recording이란 무엇인가요?

    - 

2. 멀티스레드에서 Command List를 기록하는 방법은 무엇인가요?

    - 

3. 멀티스레드 Command Recording의 장점은 무엇인가요?

    - 

4. 멀티스레드 Command Recording 시 주의사항은 무엇인가요?

    - 

## ✅ GPU와 CPU 동기화

1. DirectX 12에서 GPU와 CPU 동기화는 어떻게 이루어지나요?

    - 

2. Fence란 무엇인가요?

    - 

3. Fence를 사용하여 동기화하는 방법은 무엇인가요?

    - 

4. 동기화를 최소화하는 방법은 무엇인가요?

    - 

## ✅ 성능 / 최적화

1. DirectX 12의 성능 이점을 극대화하는 방법은 무엇인가요?

    - 

2. Resource Barrier를 최적화하는 방법은 무엇인가요?

    - 

3. Descriptor Heap 사용을 최적화하는 방법은 무엇인가요?

    - 

4. Command List 기록을 최적화하는 방법은 무엇인가요?

    - 

## ✅ 실무 / 설계 판단

1. DirectX 12를 선택해야 하는 경우는 언제인가요?

    - 

2. DirectX 11에서 DirectX 12로 마이그레이션할 때 고려사항은 무엇인가요?

    - 

3. DirectX 12 프로젝트를 설계할 때 가장 중요하게 고려해야 할 사항은 무엇인가요?

    - 

4. DirectX 12의 복잡도를 관리하는 방법은 무엇인가요?

    - 

## ✅ 요약 질문

1. DirectX 12의 핵심 개념과 Low-level API의 특징을 요약해주세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. Low-level API, Command Queue/List 분리, Resource Barrier 명시적 관리, Descriptor Heap, Multi-threaded command recording이 핵심 특징입니다.

2. CPU 오버헤드를 줄이고 개발자가 GPU를 더 세밀하게 제어할 수 있도록 하여 성능을 극대화하기 위함입니다.

3. 장점: CPU 오버헤드 감소, 세밀한 제어, 멀티스레딩 활용 용이, 성능 향상 가능. 단점: 복잡도 증가, 개발 시간 증가, 에러 가능성 증가, 학습 곡선이 가파름.

### ✅ Command Queue

1. GPU에 명령을 제출하는 큐로, 명령들이 순서대로 실행됩니다.

2. Direct, Compute, Copy 큐가 있으며, 각각 다른 작업을 담당합니다.

3. 서로 다른 작업을 병렬로 실행하여 GPU 활용도를 높이고 성능을 향상시키기 위함입니다.

4. ExecuteCommandLists()를 사용하여 Command List 배열을 제출합니다.

### ✅ Command List와 Command Allocator

1. 렌더링 명령을 기록하는 객체로, 여러 명령을 모아서 한 번에 실행할 수 있습니다.

2. Command List가 사용하는 메모리를 할당하는 객체로, 여러 Command List가 공유할 수 있습니다.

3. Command Allocator가 메모리를 제공하고, Command List가 그 메모리에 명령을 기록합니다.

4. Reset()으로 초기화 → 명령 기록 → Close()로 마무리 → ExecuteCommandLists()로 실행합니다.

5. Command Allocator를 재사용하고, Command List를 Reset()하여 재사용하며, 메모리 할당을 최소화합니다.

### ✅ Resource Barrier

1. 리소스의 상태 전환을 명시적으로 관리하는 명령입니다.

2. GPU가 리소스의 상태를 추적하고 올바른 순서로 접근할 수 있도록 하기 위함입니다.

3. D3D12_RESOURCE_BARRIER_TYPE_TRANSITION(상태 전환), D3D12_RESOURCE_BARRIER_TYPE_ALIASING(별칭), D3D12_RESOURCE_BARRIER_TYPE_UAV(UAV 동기화)가 주요 타입입니다.

4. 리소스 사용 전에 필요한 상태로 전환하고, 사용 후에 다음 상태로 전환하며, 불필요한 전환을 피합니다.

5. Resource Barrier는 GPU 동기화를 유발하므로, 최소화하고 배치하여 성능에 영향을 줍니다.

### ✅ Descriptor Heap

1. Descriptor(리소스에 대한 참조)를 저장하는 메모리 영역입니다.

2. CBV_SRV_UAV Heap, Sampler Heap, RTV Heap, DSV Heap이 주요 종류입니다.

3. Descriptor를 효율적으로 관리하고, 셰이더에 리소스를 바인딩하기 위해 사용합니다.

4. CreateDescriptorHeap()로 생성하고, GetCPUDescriptorHandleForHeapStart()로 핸들을 얻어 사용합니다.

5. 힙 타입별로 다른 제한이 있으며, CBV_SRV_UAV는 1,000,000개, Sampler는 2,048개 등이 일반적입니다.

### ✅ Root Signature

1. 셰이더에 전달되는 리소스의 레이아웃을 정의하는 객체입니다.

2. 셰이더에 리소스를 바인딩하는 방식을 정의하고, 성능을 최적화하기 위해 사용합니다.

3. Root Parameter(상수, Descriptor Table, Descriptor Range), Static Sampler 등이 구성 요소입니다.

4. D3D12_ROOT_SIGNATURE_DESC로 정의하고, D3D12SerializeRootSignature()로 직렬화한 후 CreateRootSignature()로 생성합니다.

5. Root Signature 변경은 비용이 크므로, 변경 횟수를 최소화하고 효율적으로 구성해야 합니다.

### ✅ Pipeline State Object

1. 렌더링 파이프라인의 모든 상태를 하나의 객체로 묶은 것입니다.

2. 상태 변경 비용을 줄이고, 상태 일관성을 보장하기 위해 사용합니다.

3. Shader, Input Layout, Blend State, Depth Stencil State, Rasterizer State 등이 구성 요소입니다.

4. D3D12_GRAPHICS_PIPELINE_STATE_DESC로 정의하고, CreateGraphicsPipelineState()로 생성한 후, SetPipelineState()로 설정합니다.

5. PSO 변경은 비용이 크므로, 변경 횟수를 최소화하고 사전에 생성하여 사용해야 합니다.

### ✅ Multi-threaded Command Recording

1. 여러 스레드에서 동시에 Command List를 기록하는 기술입니다.

2. 각 스레드가 독립적인 Command List와 Command Allocator를 사용하여 명령을 기록하고, 메인 스레드에서 수집하여 실행합니다.

3. CPU 활용도 향상, 렌더링 명령 기록 병렬화, 성능 향상이 장점입니다.

4. Command Allocator는 스레드별로 분리하고, Descriptor 접근 시 동기화하며, Command List는 스레드 안전하지 않으므로 주의해야 합니다.

### ✅ GPU와 CPU 동기화

1. Fence를 사용하여 GPU 작업 완료를 CPU에서 대기하거나, GPU에서 CPU 신호를 대기합니다.

2. GPU와 CPU 간의 동기화를 위한 객체로, 특정 값에 도달했는지 확인할 수 있습니다.

3. CreateFence()로 생성하고, Signal()로 값을 설정하며, GetCompletedValue()와 SetEventOnCompletion()으로 대기합니다.

4. 동기화를 최소화하고, 필요한 경우에만 동기화하며, 여러 작업을 배치하여 동기화 횟수를 줄입니다.

### ✅ 성능 / 최적화

1. Multi-threaded command recording, Resource Barrier 최적화, Descriptor Heap 효율적 사용, GPU 타임라인 최적화가 필요합니다.

2. 불필요한 전환을 피하고, 전환을 배치하여 수행하며, 리소스 사용 패턴을 최적화합니다.

3. Descriptor를 재사용하고, Descriptor Heap을 효율적으로 관리하며, Descriptor Table을 활용합니다.

4. Command List 기록을 최소화하고, 명령을 배치하여 기록하며, 불필요한 상태 변경을 피합니다.

### ✅ 실무 / 설계 판단

1. 최대 성능이 필요하고, CPU 오버헤드가 병목이며, 개발 복잡도를 감수할 수 있을 때 선택합니다.

2. API 변경사항 학습, 리소스 관리 방식 변경, 멀티스레딩 구조 재설계, 에러 처리 강화가 필요합니다.

3. 리소스 생명주기 관리, 멀티스레딩 설계, 에러 처리, 성능 프로파일링, 코드 구조화가 가장 중요합니다.

4. 래퍼 클래스 작성, 명확한 인터페이스 설계, 단계적 마이그레이션, 철저한 테스트, 문서화가 필요합니다.

### ✅ 요약 질문

1. DirectX 12는 Low-level API로 CPU 오버헤드를 최소화하고 개발자가 GPU를 세밀하게 제어할 수 있게 합니다. Command Queue/List 분리, Resource Barrier 명시적 관리, Descriptor Heap, Multi-threaded command recording을 통해 성능을 극대화하지만, 개발 복잡도가 크게 증가합니다. 성능이 중요한 프로젝트에서 선택하며, 신중한 설계와 관리가 필요합니다.

</div>
</details>
