# 소켓 프로그래밍 면접 준비 기획문서

## 1. 현재 상태 분석 (analyze_current)

### 1.1 파일 구조 현황

현재 소켓프로그래밍 폴더에는 파일이 없습니다:

**상태:** ❌ 완전히 비어있음

**관련 폴더:**
- `10.네트워크/` - 네트워크 이론 (TCP/UDP, handshake, 패킷 구조 등)
- `11.소켓프로그래밍/` - 소켓 프로그래밍 실전 (API, I/O 멀티플렉싱, 서버 패턴 등)

**구분:**
- 네트워크 폴더: 프로토콜 이론, 패킷 구조, 연결 과정 등 개념적 내용
- 소켓 프로그래밍 폴더: 실제 소켓 API 사용, 서버 구현, I/O 멀티플렉싱 등 실전 내용

### 1.2 전체적인 문제점 요약

1. **완전히 비어있음**
   - 폴더만 존재하고 파일이 없음
   - 소켓 프로그래밍 관련 면접 질문 준비 불가

2. **주제 범위 불명확**
   - 소켓 프로그래밍의 핵심 주제가 정의되지 않음
   - 면접에서 나올 수 있는 질문 범위 미정

3. **네트워크 폴더와의 관계**
   - 네트워크 폴더는 이론 중심
   - 소켓 프로그래밍은 실전 구현 중심
   - 두 폴더는 상호 보완적 관계

---

## 2. 누락된 소켓 프로그래밍 주제 파악 (identify_missing)

### 2.1 소켓 기본 개념

#### ❌ 소켓 기본 개념
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - 소켓이란 무엇인가
  - 소켓의 종류 (TCP 소켓, UDP 소켓)
  - 소켓 주소 구조체 (sockaddr, sockaddr_in, sockaddr_in6)
  - 소켓 파일 디스크립터
  - 네트워크 바이트 순서 (빅엔디안, 리틀엔디안)

### 2.2 소켓 API 기본

#### ❌ 소켓 API 기본
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - `socket()` 함수 - 소켓 생성
  - `bind()` 함수 - 주소 바인딩
  - `listen()` 함수 - 연결 대기열 설정
  - `accept()` 함수 - 연결 수락 (서버)
  - `connect()` 함수 - 연결 요청 (클라이언트)
  - `send()` / `recv()` 함수 - 데이터 송수신
  - `sendto()` / `recvfrom()` 함수 - UDP 송수신
  - `close()` / `shutdown()` 함수 - 연결 종료
  - 각 함수의 반환값과 에러 처리

### 2.3 소켓 모드

#### ❌ 블로킹 vs 논블로킹 소켓
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - 블로킹 소켓의 동작 방식
  - 논블로킹 소켓 설정 방법 (fcntl, ioctl)
  - 논블로킹 소켓의 장단점
  - EAGAIN/EWOULDBLOCK 에러 처리
  - 언제 블로킹/논블로킹을 사용하는가

### 2.4 I/O 멀티플렉싱

#### ❌ select() / poll()
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - select() 함수의 동작 원리
  - poll() 함수의 동작 원리
  - select와 poll의 차이점
  - 파일 디스크립터 개수 제한
  - 성능 특성 (O(n) 복잡도)
  - 사용 사례와 한계

#### ❌ epoll() (Linux)
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - epoll의 등장 배경
  - epoll_create, epoll_ctl, epoll_wait
  - 레벨 트리거 vs 엣지 트리거
  - epoll의 성능 특성 (O(1) 복잡도)
  - select/poll과의 성능 비교
  - 대규모 연결 처리에서의 장점

#### ❌ kqueue() (BSD/macOS)
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - kqueue의 개념
  - epoll과의 비교
  - 크로스 플랫폼 고려사항

### 2.5 서버 프로그래밍 패턴

#### ❌ 서버 프로그래밍 패턴
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - 반복 서버 (Iterative Server) - 한 번에 하나의 클라이언트만 처리
  - 동시성 서버 (Concurrent Server) - 여러 클라이언트 동시 처리
  - 멀티프로세스 서버 (fork 기반)
  - 멀티스레드 서버 (pthread 기반)
  - 이벤트 기반 서버 (epoll/select 기반)
  - 각 패턴의 장단점
  - 언제 어떤 패턴을 사용하는가

### 2.6 에러 처리 및 예외 상황

#### ❌ 에러 처리 및 예외 상황
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - 소켓 에러 코드 (errno)
  - 주요 에러 코드 (EAGAIN, ECONNRESET, EPIPE 등)
  - 연결 끊김 감지 방법
  - 타임아웃 설정 (SO_RCVTIMEO, SO_SNDTIMEO)
  - 부분 송수신 처리 (partial send/recv)
  - 에러 복구 전략

### 2.7 소켓 옵션 및 고급 주제

#### ❌ 소켓 옵션
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - SO_REUSEADDR - 주소 재사용
  - SO_REUSEPORT - 포트 재사용
  - SO_KEEPALIVE - 연결 유지
  - SO_LINGER - 종료 지연
  - TCP_NODELAY - Nagle 알고리즘 비활성화
  - 각 옵션의 사용 사례

#### ❌ 고급 주제
- **현재 상태**: 완전히 누락
- **필수 주제**:
  - 네트워크 바이트 순서 변환 (htonl, ntohl, htons, ntohs)
  - IPv4 vs IPv6 소켓 (AF_INET vs AF_INET6)
  - 소켓 버퍼 크기 조정
  - 비동기 I/O (aio_read, aio_write)
  - 소켓 풀링 (Socket Pooling)

### 2.8 누락 주제 요약

**우선순위 매우 높음:**
1. 소켓 기본 개념
2. 소켓 API 기본
3. 블로킹 vs 논블로킹 소켓
4. select/poll
5. epoll (Linux)

**우선순위 높음:**
6. 서버 프로그래밍 패턴
7. 에러 처리 및 예외 상황

**우선순위 중간:**
8. 소켓 옵션
9. 고급 주제 (kqueue, 비동기 I/O 등)

---

## 3. 재구성된 커리큘럼 구조 (restructure_curriculum)

### 3.1 재구성 원칙

1. **논리적 순서**: 기본 개념 → API 사용 → I/O 모델 → 서버 패턴 → 고급 주제
2. **개념 흐름**: 소켓 생성 → 연결 설정 → 데이터 송수신 → 동시성 처리 → 최적화
3. **실무 적용**: 각 섹션 마지막에 실무 판단 질문 포함
4. **플랫폼 고려**: Linux 중심이지만 크로스 플랫폼 고려사항 언급

### 3.2 재구성된 파일 구조

#### Part 1: 소켓 기본

1. `01.소켓_기본개념.md` - 소켓이란 무엇인가, 소켓 종류, 주소 구조체 ❌ (신규)

**학습 목표:**
- 소켓의 개념과 역할 이해
- TCP 소켓 vs UDP 소켓 구분
- 소켓 주소 구조체 이해
- 네트워크 바이트 순서 이해

2. `02.소켓_API_기본.md` - socket, bind, listen, accept, connect, send, recv ❌ (신규)

**학습 목표:**
- 소켓 생성부터 연결 종료까지 전체 흐름 이해
- 각 API 함수의 역할과 사용법
- 서버와 클라이언트의 차이점
- 에러 처리 방법

#### Part 2: 소켓 모드

3. `03.블로킹_논블로킹.md` - 블로킹 vs 논블로킹 소켓 ❌ (신규)

**학습 목표:**
- 블로킹과 논블로킹의 차이 이해
- 논블로킹 소켓 설정 방법
- EAGAIN/EWOULDBLOCK 처리
- 언제 어떤 모드를 사용하는지 판단

#### Part 3: I/O 멀티플렉싱

4. `04.select_poll.md` - select와 poll ❌ (신규)

**학습 목표:**
- select와 poll의 동작 원리 이해
- 두 함수의 차이점 파악
- 성능 특성과 한계 이해
- 사용 사례 파악

5. `05.epoll.md` - epoll (Linux) ❌ (신규)

**학습 목표:**
- epoll의 등장 배경과 필요성 이해
- epoll API 사용법
- 레벨 트리거 vs 엣지 트리거
- select/poll과의 성능 비교
- 대규모 연결 처리에서의 장점

#### Part 4: 서버 프로그래밍 패턴

6. `06.서버_프로그래밍_패턴.md` - 반복 서버, 동시성 서버, 멀티스레드 서버 ❌ (신규)

**학습 목표:**
- 다양한 서버 패턴 이해
- 각 패턴의 장단점 파악
- 실무에서 적절한 패턴 선택 능력
- 멀티프로세스 vs 멀티스레드 vs 이벤트 기반 비교

#### Part 5: 고급 주제

7. `07.소켓_옵션_에러처리.md` - 소켓 옵션, 에러 처리, 예외 상황 ❌ (신규)

**학습 목표:**
- 주요 소켓 옵션 이해
- 에러 처리 방법 습득
- 예외 상황 대응 능력
- 실무에서 자주 발생하는 문제 해결

### 3.3 파일 구조 요약

**총 7개 파일:**
- `01.소켓_기본개념.md`
- `02.소켓_API_기본.md`
- `03.블로킹_논블로킹.md`
- `04.select_poll.md`
- `05.epoll.md`
- `06.서버_프로그래밍_패턴.md`
- `07.소켓_옵션_에러처리.md`

**학습 순서:**
1. 기본 개념 → 2. API 사용 → 3. 모드 선택 → 4. I/O 멀티플렉싱 → 5. 서버 패턴 → 6. 고급 주제

---

## 4. 질문 형식 표준화 (standardize_format)

### 4.1 권장 파일 구조

```markdown
# 🧠 [주제] 면접 질문 리스트

## ✅ [카테고리 1]

1. [질문]
   
   - [사용자 답변 공간] (선택사항)

2. [질문]
   
   - [사용자 답변 공간] (선택사항)

## ✅ [카테고리 2]

...

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### [카테고리 1]

1. [답변]
2. [답변]

### [카테고리 2]

...

</div>
</details>

---

## GPT 피드백

[필요시 피드백 추가]
```

### 4.2 질문 작성 가이드라인

#### 질문 수준
- **기본 개념**: 면접 초반에 나올 수 있는 기본적인 질문
- **심화 개념**: API 동작 원리, 내부 구조, 성능 특성 등
- **실무 적용**: 언제 사용하는지, 어떤 경우에 선택하는지

#### 질문 순서
1. 기본 개념 질문 (2-3개)
2. API 동작/사용법 질문 (3-5개)
3. 비교/차이점 질문 (2-4개)
4. 성능/최적화 질문 (2-3개)
5. 실무 적용/선택 기준 질문 (1-2개)
6. 에러 처리/예외 상황 질문 (해당되는 경우, 1-2개)
7. 요약 질문 (1개)

#### 필수 포함 질문 유형
- [ ] 기본 개념 질문 포함
- [ ] API 동작/사용법 질문 포함
- [ ] 비교/차이점 질문 포함 (해당되는 경우)
- [ ] 성능/최적화 질문 포함
- [ ] 실무 적용/선택 기준 질문 포함
- [ ] 에러 처리/예외 상황 질문 포함 (해당되는 경우)
- [ ] 요약 질문 포함

### 4.3 답변 작성 가이드라인

#### GPT 답변 형식
- **1줄 답변**: 간결하고 핵심만 담은 답변
- **카테고리별 구분**: 질문 카테고리와 동일하게 구성
- **번호 매칭**: 질문 번호와 답변 번호 일치

#### 답변 내용 기준
- **정확성**: 기술적으로 정확한 정보 제공
- **간결성**: 면접에서 답변할 수 있을 정도로 간결
- **완전성**: 질문의 핵심을 모두 다룸
- **예시 포함**: 필요시 코드 예시나 구체적 예시 포함

#### 사용자 답변 공간
- **선택사항**: 모든 질문에 필수는 아님
- **일관성**: 파일 내에서 일관되게 적용
- **형식**: 4칸 들여쓰기로 답변 공간 제공

### 4.4 카테고리 명명 규칙

**표준 카테고리:**
- `## ✅ 기본 개념`
- `## ✅ [API명] 동작` (또는 `## ✅ API 사용법`)
- `## ✅ [다른 방식]과의 비교` (해당되는 경우)
- `## ✅ 성능 / 최적화`
- `## ✅ 에러 처리 / 예외 상황` (해당되는 경우)
- `## ✅ 실무 / 설계 판단`
- `## ✅ 요약 질문`

**주제별 추가 카테고리:**
- 소켓 API 관련: `## ✅ 서버 소켓 흐름`, `## ✅ 클라이언트 소켓 흐름`
- I/O 멀티플렉싱 관련: `## ✅ 동작 원리`, `## ✅ 성능 특성`
- 서버 패턴 관련: `## ✅ 패턴 비교`, `## ✅ 장단점`

### 4.5 코드 예시 가이드라인

**코드 예시가 필요한 경우:**
- 소켓 API 사용법
- select/epoll 사용 패턴
- 서버 구현 예제
- 에러 처리 패턴

**코드 예시 형식:**
```cpp
// 간단한 설명
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
if (sockfd < 0) {
    perror("socket");
    exit(1);
}
```

---

## 5. 실행 계획

### Phase 1: 기획문서 작성 (우선순위: 높음)

1. **기획문서 작성 완료** ✅
   - 현재 상태 분석
   - 누락 주제 파악
   - 커리큘럼 구조 설계
   - 질문 형식 표준화

### Phase 2: 신규 파일 생성 (우선순위: 높음 → 중간)

**우선순위 매우 높음:**
1. `01.소켓_기본개념.md` - 소켓 기본 개념
2. `02.소켓_API_기본.md` - 소켓 API 기본

**우선순위 높음:**
3. `03.블로킹_논블로킹.md` - 블로킹 vs 논블로킹
4. `04.select_poll.md` - select와 poll
5. `05.epoll.md` - epoll

**우선순위 중간:**
6. `06.서버_프로그래밍_패턴.md` - 서버 프로그래밍 패턴
7. `07.소켓_옵션_에러처리.md` - 소켓 옵션 및 에러 처리

### Phase 3: GPT 답변 작성 (우선순위: 높음)

1. **각 파일의 GPT 답변 섹션 완성**
   - 모든 질문에 대한 답변 작성
   - 카테고리별로 구분하여 작성
   - 간결하고 정확한 답변 제공

### Phase 4: 전체 검토 (우선순위: 중간)

1. **모든 파일의 질문 품질 검토**
   - 각 파일이 체크리스트를 만족하는지 확인
   - 질문의 깊이가 적절한지 확인

2. **중복 질문 제거**
   - 여러 파일에 걸쳐 중복된 질문 확인 및 정리

3. **누락된 핵심 질문 추가**
   - 각 주제별로 면접에서 나올 수 있는 핵심 질문 확인

4. **최종 정리**
   - 파일명 일관성 확인
   - 형식 일관성 확인
   - 내용 정확성 최종 검토

---

## 6. 체크리스트

각 파일마다 다음을 확인:

### 필수 체크리스트
- [ ] 기본 개념 질문 포함
- [ ] API 동작/사용법 질문 포함
- [ ] 비교/차이점 질문 포함 (해당되는 경우)
- [ ] 성능/최적화 질문 포함
- [ ] 실무 적용/선택 기준 질문 포함
- [ ] 에러 처리/예외 상황 질문 포함 (해당되는 경우)
- [ ] GPT 답변 섹션 완성
- [ ] 요약 질문 포함

### 선택 체크리스트
- [ ] 사용자 답변 공간 제공 (일관성 유지)
- [ ] 코드 예시 포함 (필요한 경우)
- [ ] GPT 피드백 섹션 포함 (오개념이 있는 경우)

### 형식 체크리스트
- [ ] 파일명이 `##.주제명.md` 형식인가?
- [ ] 제목이 `# 🧠 [주제] 면접 질문 리스트` 형식인가?
- [ ] 카테고리가 `## ✅ [카테고리명]` 형식인가?
- [ ] GPT 답변 섹션이 `<details>` 태그로 감싸져 있는가?
- [ ] GPT 답변이 카테고리별로 구분되어 있는가?

---

## 7. 참고 사항

### 파일명 규칙
- 형식: `##.주제명.md` (##는 2자리 숫자)
- 예시: `01.소켓_기본개념.md`, `05.epoll.md`

### 마크다운 형식
- 제목: `# 🧠 [주제] 면접 질문 리스트`
- 카테고리: `## ✅ [카테고리명]`
- 질문: 번호와 함께 작성
- 사용자 답변: 4칸 들여쓰기
- GPT 답변: `<details>` 태그 내부에 작성

### 질문 작성 시 주의사항
- 면접에서 실제로 나올 수 있는 수준으로 작성
- 기본 개념부터 심화 개념까지 단계적으로 구성
- 소켓 프로그래밍 질문은 실전 구현 경험을 중요시
- API 사용법과 에러 처리를 함께 다룸
- 성능과 확장성을 고려한 질문 포함

### 플랫폼 고려사항
- Linux 중심으로 작성하되, 크로스 플랫폼 고려사항 언급
- Windows의 경우 IOCP, WSAEventSelect 등 언급 가능
- macOS의 경우 kqueue 언급 가능

### 네트워크 폴더와의 관계
- 네트워크 폴더: TCP/UDP 프로토콜 이론, handshake, 패킷 구조 등
- 소켓 프로그래밍 폴더: 소켓 API 사용, 서버 구현, I/O 멀티플렉싱 등
- 두 폴더는 상호 보완적 관계로, 네트워크 이론을 바탕으로 소켓 프로그래밍을 학습

---

**문서 작성일**: 2026-01-09  
**최종 수정일**: 2026-01-09  
**버전**: 1.0
