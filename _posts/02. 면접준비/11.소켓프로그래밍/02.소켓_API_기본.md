# 🧠 소켓 API 기본 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 소켓 API의 주요 함수들은 무엇인가요?

    - bind, accept, listen 등이 있습니다.

2. 서버와 클라이언트의 소켓 사용 흐름의 차이는 무엇인가요?

    - 클라이언트는 서버와 연결하는 소켓만 존재하면 되지만, 서버는 클라이언트마다 연결하는 소켓을 만들거나 accept전용 소켓을 만들거나 할 수 있습니다.

## ✅ socket() 함수

1. socket() 함수의 역할은 무엇인가요?

    - socket 핸들러를 생성해줍니다.

2. socket() 함수의 세 가지 인자는 무엇을 의미하나요?

    - 

3. socket() 함수가 실패하는 경우는 언제인가요?

    - 소켓을 생성에 실패했을 때?

## ✅ bind() 함수

1. bind() 함수의 역할은 무엇인가요?

    - 해당 소켓을 주소와 바인드해줍니다. 

2. 왜 서버는 bind()를 호출하지만 클라이언트는 선택사항인가요?

    - 서버는 포트가 고정되어있어야 클라이언트가 연결 신청을 할 수 있지만, 클라이언트는 포트가 관계없이 요청할 수 있기 때문입니다.

3. bind() 실패의 주요 원인은 무엇인가요?

    - 사용중인 포트로 바인드를 시도한다면 실패할 수 있습니다.

## ✅ listen() 함수

1. listen() 함수의 역할은 무엇인가요?

    - 소켓이 들어오기를 기다리는 블로킹 함수입니다.

2. listen()의 두 번째 인자(backlog)는 무엇을 의미하나요?

    - 

3. listen()을 호출하지 않으면 어떻게 되나요?

    - 서버가 클라이언트와 연결할 수 없습니다.

## ✅ accept() 함수

1. accept() 함수의 역할은 무엇인가요?

    - 클라이언트를 받아주는 함수입니다.

2. accept()가 반환하는 소켓 파일 디스크립터는 무엇인가요?

    - 클라이언트와 연결된 소켓 파일 디스크립터입니다.

3. accept()는 블로킹 함수인가요?

    - 네

## ✅ connect() 함수

1. connect() 함수의 역할은 무엇인가요?

    - 

2. connect()가 실패하는 경우는 언제인가요?

    - 

3. connect()는 블로킹 함수인가요?

    - 

## ✅ send() / recv() 함수

1. send()와 write()의 차이는 무엇인가요?

    - 

2. recv()와 read()의 차이는 무엇인가요?

    - 

3. send()가 반환하는 값의 의미는 무엇인가요?

    - 

4. 부분 송신(partial send)이 발생하는 이유는 무엇인가요?

    - 

5. recv()가 0을 반환하는 경우는 언제인가요?

    - 

## ✅ sendto() / recvfrom() 함수

1. sendto()와 send()의 차이는 무엇인가요?

    - 

2. UDP에서 sendto()를 사용하는 이유는 무엇인가요?

    - 

3. recvfrom()의 마지막 두 인자는 무엇인가요?

    - 

## ✅ close() / shutdown() 함수

1. close()와 shutdown()의 차이는 무엇인가요?

    - 

2. shutdown()의 두 번째 인자(SHUT_RD, SHUT_WR, SHUT_RDWR)는 무엇을 의미하나요?

    - 

3. 소켓을 닫을 때 주의사항은 무엇인가요?

    - 

## ✅ 서버 소켓 흐름

1. TCP 서버의 소켓 생성부터 연결 수락까지의 순서를 설명해주세요.

    - 

2. 서버가 여러 클라이언트를 동시에 처리하려면 어떻게 해야 하나요?

    - 

## ✅ 클라이언트 소켓 흐름

1. TCP 클라이언트의 소켓 생성부터 연결까지의 순서를 설명해주세요.

    - 

2. 클라이언트가 bind()를 호출하지 않아도 되는 이유는 무엇인가요?

    - 

## ✅ 에러 처리

1. 소켓 함수들의 에러 처리는 어떻게 하나요?

    - 

2. errno를 확인하는 이유는 무엇인가요?

    - 

3. 주요 소켓 에러 코드들은 무엇인가요?

    - 

## ✅ 실무 / 설계 판단

1. 소켓 프로그래밍에서 가장 중요한 에러 처리는 무엇인가요?

    - 

2. 서버와 클라이언트 중 어느 쪽이 더 복잡한가요?

    - 

## ✅ 요약 질문

1. 소켓 API의 기본 흐름을 한 문장으로 요약해보세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. socket(), bind(), listen(), accept(), connect(), send(), recv(), close() 등이 주요 함수입니다.
2. 서버는 socket-bind-listen-accept 순서, 클라이언트는 socket-connect 순서로 진행합니다.

### ✅ socket() 함수

1. 소켓을 생성하고 파일 디스크립터를 반환합니다.
2. 도메인(주소 체계), 타입(소켓 타입), 프로토콜을 지정합니다.
3. 시스템 리소스 부족, 권한 부족, 잘못된 인자 등에서 실패합니다.

### ✅ bind() 함수

1. 소켓에 로컬 주소와 포트를 할당합니다.
2. 서버는 특정 포트를 지정해야 하지만, 클라이언트는 자동 할당을 사용할 수 있습니다.
3. 포트가 이미 사용 중이거나, 권한이 없는 포트를 사용할 때 실패합니다.

### ✅ listen() 함수

1. 소켓을 수신 대기 상태로 만듭니다.
2. 연결 대기열의 최대 길이를 지정합니다.
3. accept()를 호출할 수 없게 됩니다.

### ✅ accept() 함수

1. 대기 중인 연결 요청을 수락하고 새 소켓을 생성합니다.
2. 새로 생성된 클라이언트와 통신할 소켓 파일 디스크립터입니다.
3. 기본적으로 블로킹되며, 대기 중인 연결이 없으면 대기합니다.

### ✅ connect() 함수

1. 서버에 연결을 요청합니다.
2. 서버가 응답하지 않거나, 네트워크 오류, 거부된 경우 실패합니다.
3. 기본적으로 블로킹되며, 타임아웃까지 대기합니다.

### ✅ send() / recv() 함수

1. send()는 소켓 전용 플래그를 사용할 수 있지만, write()는 일반 파일에도 사용됩니다.
2. recv()는 소켓 전용 플래그를 사용할 수 있지만, read()는 일반 파일에도 사용됩니다.
3. 실제로 전송된 바이트 수를 반환합니다.
4. 소켓 버퍼가 가득 차거나 네트워크 상황에 따라 발생합니다.
5. 상대방이 연결을 정상적으로 종료했을 때입니다.

### ✅ sendto() / recvfrom() 함수

1. sendto()는 주소를 지정할 수 있어 UDP에서 사용됩니다.
2. UDP는 비연결형이므로 매번 주소를 지정해야 합니다.
3. 송신자의 주소와 주소 길이를 저장할 버퍼입니다.

### ✅ close() / shutdown() 함수

1. close()는 소켓을 완전히 닫지만, shutdown()은 한 방향만 닫을 수 있습니다.
2. SHUT_RD는 읽기, SHUT_WR는 쓰기, SHUT_RDWR는 양방향을 닫습니다.
3. 데이터가 모두 전송될 때까지 대기하거나, SO_LINGER 옵션을 고려해야 합니다.

### ✅ 서버 소켓 흐름

1. socket() → bind() → listen() → accept() 순서로 진행합니다.
2. accept()를 반복 호출하거나, 멀티스레드/멀티프로세스, I/O 멀티플렉싱을 사용합니다.

### ✅ 클라이언트 소켓 흐름

1. socket() → connect() 순서로 진행합니다.
2. 시스템이 자동으로 사용 가능한 포트를 할당하기 때문입니다.

### ✅ 에러 처리

1. 반환값이 -1인지 확인하고, errno를 확인하여 구체적인 오류를 파악합니다.
2. 어떤 종류의 오류가 발생했는지 알기 위해서입니다.
3. EAGAIN, ECONNRESET, EPIPE, ETIMEDOUT 등이 있습니다.

### ✅ 실무 / 설계 판단

1. 모든 소켓 함수 호출 후 반환값 확인과 errno 체크가 가장 중요합니다.
2. 서버가 더 복잡하며, 동시성 처리와 리소스 관리가 필요합니다.

### ✅ 요약 질문

1. 소켓 API는 socket()으로 생성, bind()/listen()으로 서버 설정, accept()/connect()로 연결, send()/recv()로 통신, close()로 종료하는 흐름입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 소켓 API의 주요 함수들은 무엇인가요?**
- **현재 답변**: "bind, accept, listen 등이 있습니다"
- **피드백**:
  - 💡 **보완**: 주요 함수들이 누락되었습니다. socket(), connect(), send(), recv(), close() 등이 빠졌습니다
  - ✅ **정확한 답변**: "socket(), bind(), listen(), accept(), connect(), send(), recv(), close() 등이 주요 함수입니다"
  - 소켓 프로그래밍의 전체 흐름을 이해하려면 모든 주요 함수를 알아야 합니다

**질문 2: 서버와 클라이언트의 소켓 사용 흐름의 차이는 무엇인가요?**
- **현재 답변**: "클라이언트는 서버와 연결하는 소켓만 존재하면 되지만, 서버는 클라이언트마다 연결하는 소켓을 만들거나 accept전용 소켓을 만들거나 할 수 있습니다"
- **피드백**:
  - 💡 **보완**: 정확한 함수 호출 순서가 빠졌습니다. 서버와 클라이언트의 구체적인 흐름을 명시해야 합니다
  - ✅ **정확한 답변**: "서버는 socket-bind-listen-accept 순서, 클라이언트는 socket-connect 순서로 진행합니다"
  - 각 단계의 함수 호출 순서를 정확히 이해하는 것이 중요합니다

### ✅ socket() 함수

**질문 1: socket() 함수의 역할은 무엇인가요?**
- **현재 답변**: "socket 핸들러를 생성해줍니다"
- **피드백**:
  - ⚠️ **부정확**: "핸들러"라는 표현보다는 "파일 디스크립터를 반환"한다는 것이 정확합니다
  - ✅ **정확한 답변**: "소켓을 생성하고 파일 디스크립터를 반환합니다"
  - socket()은 소켓을 생성하고, 성공 시 파일 디스크립터(양수)를, 실패 시 -1을 반환합니다

**질문 2: socket() 함수의 세 가지 인자는 무엇을 의미하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 소켓 생성의 핵심 개념입니다
  - ✅ **정확한 답변**: "도메인(주소 체계), 타입(소켓 타입), 프로토콜을 지정합니다"
  - 예: socket(AF_INET, SOCK_STREAM, 0) - IPv4, TCP, 기본 프로토콜

**질문 3: socket() 함수가 실패하는 경우는 언제인가요?**
- **현재 답변**: "소켓을 생성에 실패했을 때?"
- **피드백**:
  - 💡 **보완**: 너무 모호합니다. 구체적인 실패 원인을 알아야 합니다
  - ✅ **정확한 답변**: "시스템 리소스 부족, 권한 부족, 잘못된 인자 등에서 실패합니다"
  - 실패 원인을 정확히 이해하면 디버깅에 도움이 됩니다

### ✅ bind() 함수

**질문 1: bind() 함수의 역할은 무엇인가요?**
- **현재 답변**: "해당 소켓을 주소와 바인드해줍니다"
- **피드백**:
  - 💡 **보완**: "로컬 주소와 포트"라는 구체성이 부족합니다
  - ✅ **정확한 답변**: "소켓에 로컬 주소와 포트를 할당합니다"
  - bind()는 소켓을 특정 IP 주소와 포트에 바인딩하여 해당 주소로 들어오는 연결을 받을 수 있게 합니다

### ✅ listen() 함수

**질문 1: listen() 함수의 역할은 무엇인가요?**
- **현재 답변**: "소켓이 들어오기를 기다리는 블로킹 함수입니다"
- **피드백**:
  - ❌ **오개념**: listen()은 블로킹 함수가 아닙니다. listen()은 소켓을 수신 대기 상태로 만들기만 하고, 실제로 대기하는 것은 accept()입니다
  - ✅ **정확한 답변**: "소켓을 수신 대기 상태로 만듭니다"
  - listen()은 즉시 반환하며, 연결 요청을 받을 수 있는 상태로 만듭니다. 블로킹되는 것은 accept()입니다

**질문 2: listen()의 두 번째 인자(backlog)는 무엇을 의미하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 서버 성능과 관련된 중요한 개념입니다
  - ✅ **정확한 답변**: "연결 대기열의 최대 길이를 지정합니다"
  - backlog는 accept()로 처리되기 전에 대기할 수 있는 연결 요청의 최대 개수입니다

**질문 3: listen()을 호출하지 않으면 어떻게 되나요?**
- **현재 답변**: "서버가 클라이언트와 연결할 수 없습니다"
- **피드백**:
  - 💡 **보완**: 더 구체적으로 "accept()를 호출할 수 없게 됩니다"라고 설명하는 것이 정확합니다
  - ✅ **정확한 답변**: "accept()를 호출할 수 없게 됩니다"
  - listen()을 호출하지 않으면 소켓이 수신 대기 상태가 아니므로 accept()가 실패합니다

### ✅ accept() 함수

**질문 1: accept() 함수의 역할은 무엇인가요?**
- **현재 답변**: "클라이언트를 받아주는 함수입니다"
- **피드백**:
  - 💡 **보완**: "대기 중인 연결 요청을 수락하고 새 소켓을 생성"한다는 정확한 설명이 필요합니다
  - ✅ **정확한 답변**: "대기 중인 연결 요청을 수락하고 새 소켓을 생성합니다"
  - accept()는 기존 소켓(listening socket)이 아니라 새로운 소켓을 생성하여 반환합니다

### ✅ connect() 함수

**질문 1: connect() 함수의 역할은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 클라이언트 프로그래밍의 핵심 함수입니다
  - ✅ **정확한 답변**: "서버에 연결을 요청합니다"
  - 클라이언트가 서버에 TCP 연결을 시도하는 함수입니다

**질문 2: connect()가 실패하는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 에러 처리에 중요한 내용입니다
  - ✅ **정확한 답변**: "서버가 응답하지 않거나, 네트워크 오류, 거부된 경우 실패합니다"
  - 주요 실패 원인: ECONNREFUSED(연결 거부), ETIMEDOUT(타임아웃), ENETUNREACH(네트워크 도달 불가) 등

**질문 3: connect()는 블로킹 함수인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 동기/비동기 프로그래밍 이해에 중요합니다
  - ✅ **정확한 답변**: "기본적으로 블로킹되며, 타임아웃까지 대기합니다"
  - 소켓을 논블로킹 모드로 설정하면 EINPROGRESS를 반환하고 비동기로 처리할 수 있습니다

### ✅ send() / recv() 함수

**질문 1: send()와 write()의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "send()는 소켓 전용 플래그를 사용할 수 있지만, write()는 일반 파일에도 사용됩니다"
  - send()는 MSG_DONTWAIT, MSG_NOSIGNAL 등의 소켓 전용 플래그를 사용할 수 있습니다

**질문 2: recv()와 read()의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "recv()는 소켓 전용 플래그를 사용할 수 있지만, read()는 일반 파일에도 사용됩니다"
  - recv()는 MSG_PEEK, MSG_WAITALL 등의 소켓 전용 플래그를 사용할 수 있습니다

**질문 3: send()가 반환하는 값의 의미는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 부분 송신 이해에 필수적인 개념입니다
  - ✅ **정확한 답변**: "실제로 전송된 바이트 수를 반환합니다"
  - 요청한 바이트 수와 반환된 바이트 수가 다를 수 있으므로, 루프를 통해 모든 데이터를 전송해야 합니다

**질문 4: 부분 송신(partial send)이 발생하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 매우 중요한 개념입니다
  - ✅ **정확한 답변**: "소켓 버퍼가 가득 차거나 네트워크 상황에 따라 발생합니다"
  - TCP 소켓 버퍼가 가득 차면 일부만 전송되고, 나머지는 버퍼에 공간이 생길 때까지 대기합니다

**질문 5: recv()가 0을 반환하는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 연결 종료 감지에 필수적인 개념입니다
  - ✅ **정확한 답변**: "상대방이 연결을 정상적으로 종료했을 때입니다"
  - recv()가 0을 반환하면 상대방이 shutdown() 또는 close()를 호출한 것입니다

### ✅ sendto() / recvfrom() 함수

**질문 1: sendto()와 send()의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: UDP 프로그래밍의 핵심 개념입니다
  - ✅ **정확한 답변**: "sendto()는 주소를 지정할 수 있어 UDP에서 사용됩니다"
  - send()는 연결된 소켓에서만 사용하지만, sendto()는 매번 주소를 지정할 수 있어 비연결형 프로토콜에 적합합니다

**질문 2: UDP에서 sendto()를 사용하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: UDP의 비연결형 특성 이해에 중요합니다
  - ✅ **정확한 답변**: "UDP는 비연결형이므로 매번 주소를 지정해야 합니다"
  - UDP는 연결이 없으므로, 각 패킷마다 목적지 주소를 명시해야 합니다

**질문 3: recvfrom()의 마지막 두 인자는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: UDP 서버 구현에 필수적인 내용입니다
  - ✅ **정확한 답변**: "송신자의 주소와 주소 길이를 저장할 버퍼입니다"
  - recvfrom()은 데이터뿐만 아니라 송신자의 주소 정보도 함께 받아옵니다

### ✅ close() / shutdown() 함수

**질문 1: close()와 shutdown()의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 소켓 종료의 정확한 이해에 필수적입니다
  - ✅ **정확한 답변**: "close()는 소켓을 완전히 닫지만, shutdown()은 한 방향만 닫을 수 있습니다"
  - shutdown()은 읽기/쓰기 중 하나만 선택적으로 닫을 수 있어 더 세밀한 제어가 가능합니다

**질문 2: shutdown()의 두 번째 인자(SHUT_RD, SHUT_WR, SHUT_RDWR)는 무엇을 의미하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 소켓 종료의 세밀한 제어를 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "SHUT_RD는 읽기, SHUT_WR는 쓰기, SHUT_RDWR는 양방향을 닫습니다"
  - SHUT_WR를 사용하면 더 이상 전송하지 않겠다는 신호를 보내지만, 수신은 계속 가능합니다

**질문 3: 소켓을 닫을 때 주의사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 매우 중요한 내용입니다
  - ✅ **정확한 답변**: "데이터가 모두 전송될 때까지 대기하거나, SO_LINGER 옵션을 고려해야 합니다"
  - close()는 즉시 소켓을 닫을 수 있지만, 전송 중인 데이터가 손실될 수 있으므로 주의가 필요합니다

### ✅ 서버 소켓 흐름

**질문 1: TCP 서버의 소켓 생성부터 연결 수락까지의 순서를 설명해주세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 서버 프로그래밍의 기본 흐름입니다
  - ✅ **정확한 답변**: "socket() → bind() → listen() → accept() 순서로 진행합니다"
  - 각 단계의 순서와 역할을 정확히 이해해야 합니다

**질문 2: 서버가 여러 클라이언트를 동시에 처리하려면 어떻게 해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 동시성 처리의 핵심 개념입니다
  - ✅ **정확한 답변**: "accept()를 반복 호출하거나, 멀티스레드/멀티프로세스, I/O 멀티플렉싱을 사용합니다"
  - 각 방법의 장단점을 이해하고 상황에 맞게 선택할 수 있어야 합니다

### ✅ 클라이언트 소켓 흐름

**질문 1: TCP 클라이언트의 소켓 생성부터 연결까지의 순서를 설명해주세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 클라이언트 프로그래밍의 기본 흐름입니다
  - ✅ **정확한 답변**: "socket() → connect() 순서로 진행합니다"
  - 클라이언트는 서버보다 간단한 흐름을 가집니다

**질문 2: 클라이언트가 bind()를 호출하지 않아도 되는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 클라이언트와 서버의 차이를 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "시스템이 자동으로 사용 가능한 포트를 할당하기 때문입니다"
  - 클라이언트는 특정 포트가 필요 없으므로, 시스템이 임의의 포트를 할당합니다

### ✅ 에러 처리

**질문 1: 소켓 함수들의 에러 처리는 어떻게 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 필수적인 내용입니다
  - ✅ **정확한 답변**: "반환값이 -1인지 확인하고, errno를 확인하여 구체적인 오류를 파악합니다"
  - 모든 소켓 함수는 실패 시 -1을 반환하고 errno를 설정합니다

**질문 2: errno를 확인하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 디버깅과 에러 처리에 필수적입니다
  - ✅ **정확한 답변**: "어떤 종류의 오류가 발생했는지 알기 위해서입니다"
  - errno를 통해 구체적인 오류 원인을 파악하고 적절한 처리를 할 수 있습니다

**질문 3: 주요 소켓 에러 코드들은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 자주 마주치는 에러들입니다
  - ✅ **정확한 답변**: "EAGAIN, ECONNRESET, EPIPE, ETIMEDOUT 등이 있습니다"
  - 각 에러 코드의 의미와 처리 방법을 이해해야 합니다

### ✅ 실무 / 설계 판단

**질문 1: 소켓 프로그래밍에서 가장 중요한 에러 처리는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무 관점에서 중요한 질문입니다
  - ✅ **정확한 답변**: "모든 소켓 함수 호출 후 반환값 확인과 errno 체크가 가장 중요합니다"
  - 모든 소켓 함수는 실패할 수 있으므로, 반환값을 항상 확인해야 합니다

**질문 2: 서버와 클라이언트 중 어느 쪽이 더 복잡한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 설계 시 고려사항입니다
  - ✅ **정확한 답변**: "서버가 더 복잡하며, 동시성 처리와 리소스 관리가 필요합니다"
  - 서버는 여러 클라이언트를 동시에 처리해야 하므로 더 복잡합니다

### ✅ 요약 질문

**질문 1: 소켓 API의 기본 흐름을 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 요약 능력을 평가하는 질문입니다
  - ✅ **정확한 답변**: "소켓 API는 socket()으로 생성, bind()/listen()으로 서버 설정, accept()/connect()로 연결, send()/recv()로 통신, close()로 종료하는 흐름입니다"
  - 전체 흐름을 간결하게 요약하는 능력이 중요합니다

### 📊 전체 평가

**강점:**
- ✅ bind()와 accept()의 기본적인 역할을 이해하고 있음
- ✅ 서버와 클라이언트의 기본적인 차이를 알고 있음
- ✅ accept()가 블로킹 함수임을 알고 있음
- ✅ bind() 실패 원인(포트 사용 중)을 알고 있음

**개선 필요:**
- ❌ **오개념**: 
  - listen()이 블로킹 함수라는 오해 (listen()은 즉시 반환, 블로킹되는 것은 accept())
- ⚠️ **부정확한 부분**:
  - socket()의 반환값 설명 ("핸들러" vs "파일 디스크립터")
  - bind()의 역할 설명 (구체성 부족)
  - listen()을 호출하지 않았을 때의 결과 (더 구체적인 설명 필요)
  - accept()의 역할 (새 소켓 생성 개념 부족)
- 💡 **개선이 필요한 부분**:
  - 소켓 API 주요 함수 목록 완성
  - 서버/클라이언트 흐름에 정확한 함수 호출 순서 추가
  - socket() 실패 원인을 더 구체적으로 설명
- ❌ **답변 누락**: 
  - socket()의 세 가지 인자
  - connect() 함수 전반 (역할, 실패 원인, 블로킹 여부)
  - send()/recv() 관련 모든 질문 (5개)
  - sendto()/recvfrom() 관련 모든 질문 (3개)
  - close()/shutdown() 관련 모든 질문 (3개)
  - 서버/클라이언트 소켓 흐름 (4개)
  - 에러 처리 관련 모든 질문 (3개)
  - 실무/설계 판단 질문 (2개)
  - 요약 질문 (1개)
  - 총 24개 질문 답변 누락

**우선순위:**
1. **높음**: 
   - listen()과 accept()의 차이 정확히 이해 (listen()은 블로킹 함수가 아님)
   - socket(), bind(), listen(), accept(), connect()의 정확한 역할과 순서
   - send()/recv()의 부분 송수신 개념 (반환값 의미, recv()가 0을 반환하는 경우)
   - 답변 누락된 핵심 함수들 (connect(), send(), recv(), close(), shutdown())
2. **중간**: 
   - sendto()/recvfrom()의 UDP 사용 이유
   - 서버의 다중 클라이언트 처리 방법
   - 에러 처리 방법 (반환값 확인, errno)
3. **낮음**: 
   - send()와 write()의 차이
   - 소켓 API 주요 함수 목록 완성

**특별 주의사항:**
- listen()과 accept()의 차이는 면접에서 자주 나오는 오개념입니다. listen()은 즉시 반환하며 소켓을 수신 대기 상태로 만들고, 실제로 블로킹되는 것은 accept()입니다
- send()와 recv()의 부분 송수신은 실무에서 매우 중요한 개념입니다. 반환값이 요청한 바이트 수와 다를 수 있으므로 루프를 통해 모든 데이터를 처리해야 합니다
- recv()가 0을 반환하는 경우는 상대방이 연결을 정상 종료한 것이므로, 이를 감지하여 적절히 처리해야 합니다
- close()와 shutdown()의 차이를 이해하면 소켓 종료를 더 세밀하게 제어할 수 있습니다
