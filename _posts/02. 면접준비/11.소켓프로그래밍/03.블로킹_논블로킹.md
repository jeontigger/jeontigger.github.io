# 🧠 블로킹 vs 논블로킹 소켓 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 블로킹 소켓이란 무엇인가요?

    - I/O를 사용할 때 블로킹되는 소켓입니다. recv와 send가 블로킹됩니다.

2. 논블로킹 소켓이란 무엇인가요?

    - recv와 send를 호출해도 블로킹되지 않습니다.

3. 블로킹과 논블로킹의 가장 큰 차이는 무엇인가요?

    - 실행흐름의 멈춤 유무입니다.

## ✅ 블로킹 소켓 동작

1. 블로킹 소켓에서 recv()를 호출하면 어떻게 동작하나요?

    - recv가 성공하기 전까지 블로킹됩니다.

2. 블로킹 소켓에서 send()를 호출하면 어떻게 동작하나요?

    - send가 성공하기 전까지 블로킹 됩니다.

3. 블로킹 소켓의 장점은 무엇인가요?

    - 호출 순서를 보장할 수 있습니다.

4. 블로킹 소켓의 단점은 무엇인가요?

    - 실행 흐름이 멈추기 때문에 recv와 send를 모두 하는 소켓을 만들고싶다면 2가지의 스레드가 필요합니다.

## ✅ 논블로킹 소켓 설정

1. 논블로킹 소켓을 설정하는 방법은 무엇인가요?

    - 

2. fcntl() 함수로 논블로킹을 설정하는 코드를 작성해보세요.

    - 

3. ioctl() 함수로도 논블로킹을 설정할 수 있나요?

    - 

## ✅ 논블로킹 소켓 동작

1. 논블로킹 소켓에서 recv()를 호출하면 어떻게 동작하나요?

    - 

2. 논블로킹 소켓에서 send()를 호출하면 어떻게 동작하나요?

    - 

3. 논블로킹 소켓의 장점은 무엇인가요?

    - 

4. 논블로킹 소켓의 단점은 무엇인가요?

    - 

## ✅ EAGAIN / EWOULDBLOCK

1. EAGAIN과 EWOULDBLOCK의 차이는 무엇인가요?

    - 

2. 논블로킹 소켓에서 EAGAIN이 발생하는 경우는 언제인가요?

    - 

3. EAGAIN을 받았을 때 어떻게 처리해야 하나요?

    - 

## ✅ 논블로킹과 I/O 멀티플렉싱

1. 논블로킹 소켓과 select/epoll을 함께 사용하는 이유는 무엇인가요?

    - 

2. 논블로킹 소켓 없이 select/epoll만 사용할 수 있나요?

    - 

3. 논블로킹 소켓과 I/O 멀티플렉싱의 관계는 무엇인가요?

    - 

## ✅ 성능 / 최적화

1. 블로킹 소켓과 논블로킹 소켓 중 어느 것이 성능이 좋나요?

    - 

2. 논블로킹 소켓이 CPU 사용률에 미치는 영향은 무엇인가요?

    - 

3. 논블로킹 소켓을 사용할 때 주의해야 할 점은 무엇인가요?

    - 

## ✅ 실무 / 설계 판단

1. 언제 블로킹 소켓을 사용해야 하나요?

    - 

2. 언제 논블로킹 소켓을 사용해야 하나요?

    - 

3. 단일 스레드에서 여러 소켓을 처리하려면 어떻게 해야 하나요?

    - 

## ✅ 요약 질문

1. 블로킹과 논블로킹 소켓의 차이를 한 문장으로 요약해보세요.

    - 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. I/O 작업이 완료될 때까지 함수가 대기하는 소켓입니다.
2. I/O 작업이 즉시 반환되며, 데이터가 없으면 에러를 반환하는 소켓입니다.
3. 블로킹은 대기하고, 논블로킹은 즉시 반환합니다.

### ✅ 블로킹 소켓 동작

1. 데이터가 도착할 때까지 대기하며, 데이터가 있으면 반환합니다.
2. 버퍼에 공간이 생길 때까지 대기하며, 전송 가능하면 전송합니다.
3. 코드가 단순하고 이해하기 쉽습니다.
4. 한 소켓이 블로킹되면 다른 소켓을 처리할 수 없습니다.

### ✅ 논블로킹 소켓 설정

1. fcntl() 함수로 O_NONBLOCK 플래그를 설정합니다.
2. fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL) | O_NONBLOCK);
3. 네, ioctl(sockfd, FIONBIO, &on)으로도 설정 가능합니다.

### ✅ 논블로킹 소켓 동작

1. 데이터가 있으면 반환하고, 없으면 -1을 반환하며 errno에 EAGAIN을 설정합니다.
2. 전송 가능하면 전송하고, 불가능하면 -1을 반환하며 errno에 EAGAIN을 설정합니다.
3. 여러 소켓을 단일 스레드에서 처리할 수 있습니다.
4. 에러 처리가 복잡하고, 루프에서 CPU를 많이 사용할 수 있습니다.

### ✅ EAGAIN / EWOULDBLOCK

1. 대부분의 시스템에서 동일하며, 일부 시스템에서만 다릅니다.
2. 데이터가 없거나 버퍼가 가득 찼을 때 발생합니다.
3. 나중에 다시 시도하거나, select/epoll로 대기 상태를 확인합니다.

### ✅ 논블로킹과 I/O 멀티플렉싱

1. select/epoll로 준비된 소켓만 확인하고, 논블로킹으로 즉시 처리하기 위해서입니다.
2. 가능하지만, 논블로킹과 함께 사용하는 것이 더 효율적입니다.
3. I/O 멀티플렉싱으로 준비 상태를 확인하고, 논블로킹으로 실제 I/O를 수행합니다.

### ✅ 성능 / 최적화

1. 상황에 따라 다르며, 대규모 연결에서는 논블로킹이 유리합니다.
2. 루프에서 계속 확인하면 CPU 사용률이 높아질 수 있습니다.
3. EAGAIN 처리를 제대로 해야 하며, 불필요한 루프를 피해야 합니다.

### ✅ 실무 / 설계 판단

1. 단순한 클라이언트나 단일 연결 서버에서 사용합니다.
2. 다중 연결을 처리하거나 이벤트 기반 서버에서 사용합니다.
3. 논블로킹 소켓과 select/epoll을 함께 사용합니다.

### ✅ 요약 질문

1. 블로킹 소켓은 I/O 완료까지 대기하고, 논블로킹 소켓은 즉시 반환하여 여러 소켓을 효율적으로 처리할 수 있습니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 블로킹 소켓이란 무엇인가요?**
- **현재 답변**: "I/O를 사용할 때 블로킹되는 소켓입니다. recv와 send가 블로킹됩니다"
- **피드백**:
  - 💡 **보완**: "I/O 작업이 완료될 때까지 함수가 대기"한다는 구체적인 설명이 필요합니다
  - ✅ **정확한 답변**: "I/O 작업이 완료될 때까지 함수가 대기하는 소켓입니다"
  - 단순히 "블로킹된다"는 표현보다는 "작업 완료까지 대기"한다는 것이 더 정확합니다

**질문 2: 논블로킹 소켓이란 무엇인가요?**
- **현재 답변**: "recv와 send를 호출해도 블로킹되지 않습니다"
- **피드백**:
  - 💡 **보완**: "즉시 반환"과 "데이터가 없으면 에러 반환"이라는 핵심 개념이 빠졌습니다
  - ✅ **정확한 답변**: "I/O 작업이 즉시 반환되며, 데이터가 없으면 에러를 반환하는 소켓입니다"
  - 논블로킹의 핵심은 즉시 반환과 에러 처리입니다

### ✅ 블로킹 소켓 동작

**질문 1: 블로킹 소켓에서 recv()를 호출하면 어떻게 동작하나요?**
- **현재 답변**: "recv가 성공하기 전까지 블로킹됩니다"
- **피드백**:
  - 💡 **보완**: "데이터가 도착할 때까지 대기"한다는 구체적인 설명이 필요합니다
  - ✅ **정확한 답변**: "데이터가 도착할 때까지 대기하며, 데이터가 있으면 반환합니다"
  - "성공하기 전까지"보다는 "데이터 도착까지 대기"가 더 정확한 표현입니다

**질문 2: 블로킹 소켓에서 send()를 호출하면 어떻게 동작하나요?**
- **현재 답변**: "send가 성공하기 전까지 블로킹 됩니다"
- **피드백**:
  - 💡 **보완**: "버퍼에 공간이 생길 때까지 대기"한다는 구체적인 설명이 필요합니다
  - ✅ **정확한 답변**: "버퍼에 공간이 생길 때까지 대기하며, 전송 가능하면 전송합니다"
  - send()는 소켓 버퍼가 가득 차면 공간이 생길 때까지 대기합니다

**질문 3: 블로킹 소켓의 장점은 무엇인가요?**
- **현재 답변**: "호출 순서를 보장할 수 있습니다"
- **피드백**:
  - 💡 **보완**: "코드가 단순하고 이해하기 쉽다"는 것이 더 정확한 장점입니다
  - ✅ **정확한 답변**: "코드가 단순하고 이해하기 쉽습니다"
  - 호출 순서 보장은 블로킹의 결과이지, 장점의 핵심은 코드의 단순성입니다

**질문 4: 블로킹 소켓의 단점은 무엇인가요?**
- **현재 답변**: "실행 흐름이 멈추기 때문에 recv와 send를 모두 하는 소켓을 만들고싶다면 2가지의 스레드가 필요합니다"
- **피드백**:
  - 💡 **보완**: "한 소켓이 블로킹되면 다른 소켓을 처리할 수 없다"는 것이 더 정확한 단점입니다
  - ✅ **정확한 답변**: "한 소켓이 블로킹되면 다른 소켓을 처리할 수 없습니다"
  - 단점의 핵심은 다중 소켓 처리 불가능이며, 스레드 필요성은 그 결과입니다

### ✅ 논블로킹 소켓 설정

**질문 1: 논블로킹 소켓을 설정하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓 사용의 첫 단계입니다
  - ✅ **정확한 답변**: "fcntl() 함수로 O_NONBLOCK 플래그를 설정합니다"
  - fcntl()을 사용하여 소켓의 플래그를 변경합니다

**질문 2: fcntl() 함수로 논블로킹을 설정하는 코드를 작성해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 필수적인 코드입니다
  - ✅ **정확한 답변**: "fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL) | O_NONBLOCK);"
  - 기존 플래그를 읽어서 O_NONBLOCK을 추가한 후 설정합니다

**질문 3: ioctl() 함수로도 논블로킹을 설정할 수 있나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 여러 방법을 아는 것이 유용합니다
  - ✅ **정확한 답변**: "네, ioctl(sockfd, FIONBIO, &on)으로도 설정 가능합니다"
  - ioctl()은 레거시 방법이지만 여전히 사용 가능합니다

### ✅ 논블로킹 소켓 동작

**질문 1: 논블로킹 소켓에서 recv()를 호출하면 어떻게 동작하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓의 핵심 동작입니다
  - ✅ **정확한 답변**: "데이터가 있으면 반환하고, 없으면 -1을 반환하며 errno에 EAGAIN을 설정합니다"
  - 즉시 반환되며, 데이터가 없으면 에러를 반환합니다

**질문 2: 논블로킹 소켓에서 send()를 호출하면 어떻게 동작하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓의 핵심 동작입니다
  - ✅ **정확한 답변**: "전송 가능하면 전송하고, 불가능하면 -1을 반환하며 errno에 EAGAIN을 설정합니다"
  - 버퍼가 가득 차면 즉시 에러를 반환합니다

**질문 3: 논블로킹 소켓의 장점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓 사용의 핵심 이유입니다
  - ✅ **정확한 답변**: "여러 소켓을 단일 스레드에서 처리할 수 있습니다"
  - 다중 소켓을 효율적으로 처리할 수 있는 것이 가장 큰 장점입니다

**질문 4: 논블로킹 소켓의 단점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓 사용 시 주의사항입니다
  - ✅ **정확한 답변**: "에러 처리가 복잡하고, 루프에서 CPU를 많이 사용할 수 있습니다"
  - EAGAIN 처리가 필요하고, 폴링 루프는 CPU를 많이 사용합니다

### ✅ EAGAIN / EWOULDBLOCK

**질문 1: EAGAIN과 EWOULDBLOCK의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 에러 처리 시 알아야 할 내용입니다
  - ✅ **정확한 답변**: "대부분의 시스템에서 동일하며, 일부 시스템에서만 다릅니다"
  - Linux에서는 보통 동일한 값이며, 일부 시스템에서는 다를 수 있습니다

**질문 2: 논블로킹 소켓에서 EAGAIN이 발생하는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓 에러 처리의 핵심입니다
  - ✅ **정확한 답변**: "데이터가 없거나 버퍼가 가득 찼을 때 발생합니다"
  - recv()는 데이터가 없을 때, send()는 버퍼가 가득 찼을 때 발생합니다

**질문 3: EAGAIN을 받았을 때 어떻게 처리해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 필수적인 처리 방법입니다
  - ✅ **정확한 답변**: "나중에 다시 시도하거나, select/epoll로 대기 상태를 확인합니다"
  - 무작정 재시도하지 말고, I/O 멀티플렉싱과 함께 사용하는 것이 효율적입니다

### ✅ 논블로킹과 I/O 멀티플렉싱

**질문 1: 논블로킹 소켓과 select/epoll을 함께 사용하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 고성능 서버 구현의 핵심 개념입니다
  - ✅ **정확한 답변**: "select/epoll로 준비된 소켓만 확인하고, 논블로킹으로 즉시 처리하기 위해서입니다"
  - I/O 멀티플렉싱으로 준비 상태를 확인하고, 논블로킹으로 실제 I/O를 수행합니다

**질문 2: 논블로킹 소켓 없이 select/epoll만 사용할 수 있나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: I/O 멀티플렉싱과 논블로킹의 관계를 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "가능하지만, 논블로킹과 함께 사용하는 것이 더 효율적입니다"
  - 블로킹 소켓과 함께 사용하면 일부 소켓이 블로킹될 수 있어 비효율적입니다

**질문 3: 논블로킹 소켓과 I/O 멀티플렉싱의 관계는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 고성능 서버 설계의 핵심 개념입니다
  - ✅ **정확한 답변**: "I/O 멀티플렉싱으로 준비 상태를 확인하고, 논블로킹으로 실제 I/O를 수행합니다"
  - 두 기술을 함께 사용하여 효율적인 다중 소켓 처리가 가능합니다

### ✅ 성능 / 최적화

**질문 1: 블로킹 소켓과 논블로킹 소켓 중 어느 것이 성능이 좋나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 상황에 따른 선택 기준을 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "상황에 따라 다르며, 대규모 연결에서는 논블로킹이 유리합니다"
  - 단일 연결에서는 블로킹이 단순하고, 다중 연결에서는 논블로킹이 효율적입니다

**질문 2: 논블로킹 소켓이 CPU 사용률에 미치는 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 논블로킹 소켓 사용 시 주의사항입니다
  - ✅ **정확한 답변**: "루프에서 계속 확인하면 CPU 사용률이 높아질 수 있습니다"
  - 폴링 루프는 CPU를 많이 사용하므로, I/O 멀티플렉싱과 함께 사용해야 합니다

**질문 3: 논블로킹 소켓을 사용할 때 주의해야 할 점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 매우 중요한 내용입니다
  - ✅ **정확한 답변**: "EAGAIN 처리를 제대로 해야 하며, 불필요한 루프를 피해야 합니다"
  - 에러 처리를 제대로 하지 않으면 데이터 손실이나 CPU 낭비가 발생할 수 있습니다

### ✅ 실무 / 설계 판단

**질문 1: 언제 블로킹 소켓을 사용해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 설계 시 선택 기준을 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "단순한 클라이언트나 단일 연결 서버에서 사용합니다"
  - 코드가 단순하고 이해하기 쉬운 경우 블로킹 소켓이 적합합니다

**질문 2: 언제 논블로킹 소켓을 사용해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 설계 시 선택 기준을 이해하는 데 중요합니다
  - ✅ **정확한 답변**: "다중 연결을 처리하거나 이벤트 기반 서버에서 사용합니다"
  - 여러 소켓을 동시에 처리해야 하는 경우 논블로킹 소켓이 필수입니다

**질문 3: 단일 스레드에서 여러 소켓을 처리하려면 어떻게 해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 고성능 서버 구현의 핵심입니다
  - ✅ **정확한 답변**: "논블로킹 소켓과 select/epoll을 함께 사용합니다"
  - 단일 스레드에서 다중 소켓을 처리하려면 논블로킹과 I/O 멀티플렉싱이 필요합니다

### ✅ 요약 질문

**질문 1: 블로킹과 논블로킹 소켓의 차이를 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 요약 능력을 평가하는 질문입니다
  - ✅ **정확한 답변**: "블로킹 소켓은 I/O 완료까지 대기하고, 논블로킹 소켓은 즉시 반환하여 여러 소켓을 효율적으로 처리할 수 있습니다"
  - 핵심 차이를 간결하게 요약하는 능력이 중요합니다

### 📊 전체 평가

**강점:**
- ✅ 블로킹과 논블로킹의 기본적인 차이(실행 흐름 멈춤 유무)를 이해하고 있음
- ✅ 블로킹 소켓의 기본적인 동작(recv/send가 블로킹됨)을 알고 있음
- ✅ 블로킹 소켓의 단점(다중 소켓 처리 시 스레드 필요)을 이해하고 있음

**개선 필요:**
- ⚠️ **부정확한 부분**:
  - 블로킹 소켓의 정의 (더 구체적인 설명 필요)
  - 논블로킹 소켓의 정의 (에러 반환 개념 부족)
  - 블로킹 소켓의 recv()/send() 동작 (구체적인 대기 조건 설명 부족)
  - 블로킹 소켓의 장점/단점 (더 정확한 표현 필요)
- 💡 **개선이 필요한 부분**:
  - 블로킹 소켓의 동작을 더 구체적으로 설명 (데이터 도착까지 대기, 버퍼 공간 생길 때까지 대기)
  - 논블로킹 소켓의 핵심 개념 (즉시 반환, 에러 처리) 추가
- ❌ **답변 누락**: 
  - 논블로킹 소켓 설정 방법 (3개 질문)
  - 논블로킹 소켓 동작 (4개 질문)
  - EAGAIN/EWOULDBLOCK 관련 (3개 질문)
  - 논블로킹과 I/O 멀티플렉싱 관계 (3개 질문)
  - 성능/최적화 관련 (3개 질문)
  - 실무/설계 판단 (3개 질문)
  - 요약 질문 (1개)
  - 총 20개 질문 답변 누락

**우선순위:**
1. **높음**: 
   - 논블로킹 소켓 설정 방법 (fcntl(), ioctl())
   - 논블로킹 소켓의 동작 (recv()/send()의 즉시 반환과 EAGAIN)
   - EAGAIN 처리 방법
   - 논블로킹과 I/O 멀티플렉싱의 관계
2. **중간**: 
   - 블로킹 소켓의 동작을 더 구체적으로 이해 (데이터 도착까지, 버퍼 공간까지)
   - 논블로킹 소켓의 장단점
   - 성능 비교와 사용 시기 판단
3. **낮음**: 
   - EAGAIN과 EWOULDBLOCK의 차이
   - CPU 사용률에 대한 이해

**특별 주의사항:**
- 논블로킹 소켓과 I/O 멀티플렉싱(select/epoll)의 관계는 면접에서 자주 나오는 주제입니다. 논블로킹만으로는 효율적이지 않으며, I/O 멀티플렉싱과 함께 사용해야 합니다
- EAGAIN 처리는 논블로킹 소켓 사용 시 필수적입니다. 무작정 재시도하지 말고, select/epoll로 준비 상태를 확인한 후 처리해야 합니다
- 블로킹 소켓의 recv()는 "데이터가 도착할 때까지" 대기하고, send()는 "버퍼에 공간이 생길 때까지" 대기한다는 구체적인 조건을 이해해야 합니다
- 논블로킹 소켓의 핵심은 "즉시 반환"과 "에러 처리"입니다. 데이터가 없거나 버퍼가 가득 차면 EAGAIN을 반환합니다
