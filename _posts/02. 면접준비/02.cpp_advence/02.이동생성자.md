---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 02.cpp_advence]
published: false
tags:
    [면접준비]
---

# 🧠 C++ 이동 생성자(move constructor) 면접 질문 리스트

## ✅ 기본 개념

1. 이동 생성자란 무엇인가요?

    - 이동 생성자란 기존 객체의 소유권을 포기하고 새로 생기는 객체에게 해당 소유권을 모두 넘기는 생성자입니다.

2. 이동 생성자와 복사 생성자의 차이는 무엇인가요?

    - 복사 생성자는 같은 객체가 2개 생기는 것이지만, 이동 생성자는 인자로 받았던 객체는 모두 초기화된 상태로 변경됩니다.

## ✅ 등장 배경 / 필요성

1. 이동 생성자는 왜 등장했나요?

    - 임시객체처럼 생성을 위해 사용되고 난 후엔 사용하지 않는 객체를 인자로 새 객체를 생성할 때, 불필요한 공간할당 비용을 줄이기 위해 등장했습니다.

## ✅ 언어 규칙 / 제약

1. 이동 생성자를 `noexcept`로 선언하는 이유는 무엇인가요?

    - 이동 생성자를 수행하는 도중에 예외가 발생했을 때 남은 멤버에 대한 소유권을 컴파일러가 결정할 수 없기 때문입니다.

## ✅ 컨테이너 / 실무 관점

1. STL 컨테이너에서 이동 생성자는 언제 중요한가요?

    - reallocate가 될 때 불필요한 복사 비용을 줄입니다.

2. 이동 생성자가 없으면 STL 컨테이너에서 어떤 일이 발생하나요?

    - 

3. 이동 생성자와 복사 생성자 중 어떤 것이 선택되나요?

    - 

## ✅ noexcept와 예외 안전성

1. 이동 생성자에 `noexcept`가 없으면 STL 컨테이너에서 어떻게 동작하나요?

    - 

2. 이동 생성자에서 예외가 발생하면 어떤 문제가 생기나요?

    - 

3. `noexcept` 이동 생성자와 예외 안전성의 관계는 무엇인가요?

    - 

## ✅ 이동 생성자와 복사 생성자 선택 기준

1. 컴파일러는 이동 생성자와 복사 생성자 중 어떤 것을 선택하나요?

    - 

2. 이동 생성자가 없으면 복사 생성자가 호출되나요?

    - 

3. 복사 생성자가 삭제된 경우 이동 생성자는 어떻게 동작하나요?

    - 

## ✅ 이동 생성자 구현 / 동작 원리

1. 이동 생성자를 구현할 때 주의사항은 무엇인가요?

    - 

2. 이동 생성자에서 소유권을 이전한 후 원본 객체는 어떻게 처리해야 하나요?

    - 

3. 이동 생성자에서 멤버 변수를 이동하는 방법은 무엇인가요?

    - 

## ✅ 성능 / 최적화

1. 이동 생성자가 성능에 미치는 영향은 무엇인가요?

    - 

2. 이동 생성자와 복사 생성자의 성능 차이는 무엇인가요?

    - 

3. 이동 생성자를 사용하면 어떤 경우에 성능이 향상되나요?

    - 

## ✅ 실무 / 설계 판단

1. 모든 클래스에 이동 생성자를 정의해야 하나요?

    - 

2. 이동 생성자를 정의하지 않아도 되는 경우는 언제인가요?

    - 

3. 이동 생성자를 한 문장으로 요약해보세요.

    - 

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 이동 생성자란 무엇인가요?**
- **현재 답변**: "이동 생성자란 기존 객체의 소유권을 포기하고 새로 생기는 객체에게 해당 소유권을 모두 넘기는 생성자입니다."
- **피드백**: (정확한 답변 - 피드백 없음)

**질문 2: 이동 생성자와 복사 생성자의 차이는 무엇인가요?**
- **현재 답변**: "복사 생성자는 같은 객체가 2개 생기는 것이지만, 이동 생성자는 인자로 받았던 객체는 모두 초기화된 상태로 변경됩니다."
- **피드백**:
  - ⚠️ **부정확**: "초기화된 상태"라는 표현이 부정확합니다.
  - ✅ **정확한 답변**: "복사는 데이터를 복제하고, 이동은 자원 소유권만 이전합니다."
  - 이동된 후 원본 객체는 "초기화된 상태"가 아니라 "유효하지만 미정의 상태"로 만들어야 합니다.

### ✅ 등장 배경 / 필요성

**질문 1: 이동 생성자는 왜 등장했나요?**
- **현재 답변**: "임시객체처럼 생성을 위해 사용되고 난 후엔 사용하지 않는 객체를 인자로 새 객체를 생성할 때, 불필요한 공간할당 비용을 줄이기 위해 등장했습니다."
- **피드백**: (정확한 답변 - 피드백 없음)

### ✅ 언어 규칙 / 제약

**질문 1: 이동 생성자를 `noexcept`로 선언하는 이유는 무엇인가요?**
- **현재 답변**: "이동 생성자를 수행하는 도중에 예외가 발생했을 때 남은 멤버에 대한 소유권을 컴파일러가 결정할 수 없기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 맞지만 STL 컨테이너와의 관계가 명확하지 않습니다.
  - ✅ **정확한 답변**: "컨테이너가 예외 안전을 보장하기 위해 이동을 선택할 수 있게 하기 위함입니다."
  - STL 컨테이너는 강한 예외 안전성을 보장하기 위해 `noexcept`가 없으면 복사 생성자를 선택합니다.

### ✅ 컨테이너 / 실무 관점

**질문 1: STL 컨테이너에서 이동 생성자는 언제 중요한가요?**
- **현재 답변**: "reallocate가 될 때 불필요한 복사 비용을 줄입니다."
- **피드백**: (정확한 답변 - 피드백 없음)

**질문 2: 이동 생성자가 없으면 STL 컨테이너에서 어떤 일이 발생하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: STL 컨테이너 동작 이해에 중요한 질문입니다.
  - ✅ **정확한 답변**: "복사 생성자가 호출되어 성능 저하가 발생합니다."
  - 이동 생성자가 없으면 rvalue에서도 복사 생성자가 호출됩니다.

**질문 3: 이동 생성자와 복사 생성자 중 어떤 것이 선택되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다.
  - ✅ **정확한 답변**: "rvalue일 때는 이동 생성자를, lvalue일 때는 복사 생성자를 선택합니다."
  - 값 카테고리(value category)에 따라 선택됩니다.

### ✅ noexcept와 예외 안전성

**질문 1: 이동 생성자에 `noexcept`가 없으면 STL 컨테이너에서 어떻게 동작하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: STL 컨테이너와 noexcept의 관계는 매우 중요합니다.
  - ✅ **정확한 답변**: "`noexcept`가 없으면 STL 컨테이너가 복사 생성자를 선택할 수 있습니다."
  - STL 컨테이너는 강한 예외 안전성을 보장하기 위해 `noexcept`가 없으면 복사를 선택합니다.

**질문 2: 이동 생성자에서 예외가 발생하면 어떤 문제가 생기나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 예외 안전성은 중요한 주제입니다.
  - ✅ **정확한 답변**: "부분적으로 이동된 상태가 되어 일관성이 깨질 수 있습니다."
  - 이동 중 예외 발생 시 객체의 일관성이 깨질 수 있습니다.

**질문 3: `noexcept` 이동 생성자와 예외 안전성의 관계는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 예외 안전성과 관련된 중요한 질문입니다.
  - ✅ **정확한 답변**: "`noexcept`가 있으면 컨테이너가 안전하게 이동을 선택할 수 있습니다."
  - `noexcept`는 컨테이너가 예외 안전성을 보장하면서도 이동을 사용할 수 있게 합니다.

### ✅ 이동 생성자와 복사 생성자 선택 기준

**질문 1: 컴파일러는 이동 생성자와 복사 생성자 중 어떤 것을 선택하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다.
  - ✅ **정확한 답변**: "rvalue일 때는 이동 생성자, lvalue일 때는 복사 생성자를 선택합니다."
  - 값 카테고리(value category)에 따라 선택됩니다.

**질문 2: 이동 생성자가 없으면 복사 생성자가 호출되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다.
  - ✅ **정확한 답변**: "네, 이동 생성자가 없으면 복사 생성자가 호출됩니다."
  - 이동 생성자가 없으면 rvalue에서도 복사 생성자가 호출됩니다.

**질문 3: 복사 생성자가 삭제된 경우 이동 생성자는 어떻게 동작하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 이동 가능하지만 복사 불가능한 타입에 대한 이해가 필요합니다.
  - ✅ **정확한 답변**: "이동 생성자가 호출되어 정상적으로 동작합니다."
  - 복사 생성자가 삭제되어도 이동 생성자는 정상적으로 동작합니다.

### ✅ 이동 생성자 구현 / 동작 원리

**질문 1: 이동 생성자를 구현할 때 주의사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 구현 시 중요한 주의사항입니다.
  - ✅ **정확한 답변**: "멤버를 이동하고 원본을 유효한 상태로 만들어야 합니다."
  - 이동 후 원본 객체도 유효한 상태를 유지해야 합니다.

**질문 2: 이동 생성자에서 소유권을 이전한 후 원본 객체는 어떻게 처리해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 이동 생성자 구현의 핵심입니다.
  - ✅ **정확한 답변**: "유효하지만 미정의 상태로 만들어야 합니다."
  - "초기화된 상태"가 아니라 "유효하지만 미정의 상태"로 만들어야 합니다.

**질문 3: 이동 생성자에서 멤버 변수를 이동하는 방법은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 구현 방법에 대한 질문입니다.
  - ✅ **정확한 답변**: "`std::move`를 사용하여 멤버의 이동 생성자나 이동 대입 연산자를 호출합니다."
  - `std::move`를 사용하여 멤버를 이동합니다.

### ✅ 성능 / 최적화

**질문 1: 이동 생성자가 성능에 미치는 영향은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 최적화와 관련된 중요한 질문입니다.
  - ✅ **정확한 답변**: "불필요한 복사를 제거하여 성능을 크게 향상시킬 수 있습니다."
  - 이동 생성자는 성능 향상에 큰 영향을 줍니다.

**질문 2: 이동 생성자와 복사 생성자의 성능 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 성능 차이 이해는 중요합니다.
  - ✅ **정확한 답변**: "이동은 포인터 복사 수준으로 빠르고, 복사는 전체 데이터 복제로 느립니다."
  - 이동은 포인터 복사 수준으로 빠릅니다.

**질문 3: 이동 생성자를 사용하면 어떤 경우에 성능이 향상되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 질문입니다.
  - ✅ **정확한 답변**: "큰 객체나 자원을 가진 객체를 전달할 때 성능이 향상됩니다."
  - 큰 객체나 자원을 가진 객체에서 효과적입니다.

### ✅ 실무 / 설계 판단

**질문 1: 모든 클래스에 이동 생성자를 정의해야 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 설계 판단에 중요한 질문입니다.
  - ✅ **정확한 답변**: "아니요, 이동이 의미 있는 클래스에만 정의하면 됩니다."
  - 모든 클래스에 필요하지 않습니다.

**질문 2: 이동 생성자를 정의하지 않아도 되는 경우는 언제인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 설계 판단에 중요한 질문입니다.
  - ✅ **정확한 답변**: "작은 타입이나 이동이 복사와 비슷한 비용인 경우에는 필요 없습니다."
  - 작은 타입이나 이동이 의미 없는 경우에는 필요 없습니다.

**질문 3: 이동 생성자를 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 핵심 개념을 요약하는 능력은 중요합니다.
  - ✅ **정확한 답변**: "자원의 소유권을 이전하여 불필요한 복사를 제거하는 생성자입니다."
  - 이동 생성자의 본질을 간결하게 표현해야 합니다.

### 📊 전체 평가

**강점:**
- ✅ 이동 생성자의 기본 개념을 정확히 이해하고 있습니다.
- ✅ 이동 생성자의 등장 배경을 정확히 이해하고 있습니다.
- ✅ STL 컨테이너에서 이동 생성자의 중요성을 이해하고 있습니다.

**개선 필요:**
- ⚠️ **부정확한 부분**:
  - 이동된 후 원본 객체의 상태 표현 ("초기화된 상태" → "유효하지만 미정의 상태")
  - `noexcept`의 STL 컨테이너와의 관계 설명 부족
- ❌ **답변 누락**: 
  - 이동 생성자와 복사 생성자 선택 기준 (3개 질문)
  - noexcept와 예외 안전성 (3개 질문)
  - 이동 생성자 구현 / 동작 원리 (3개 질문)
  - 성능 / 최적화 (3개 질문)
  - 실무 / 설계 판단 (3개 질문)

**우선순위:**
1. **높음**: 이동된 후 원본 객체의 상태 이해 - "유효하지만 미정의 상태"라는 정확한 표현을 사용해야 합니다.
2. **높음**: `noexcept`와 STL 컨테이너의 관계 - STL 컨테이너는 강한 예외 안전성을 보장하기 위해 `noexcept`가 없으면 복사를 선택합니다.
3. **높음**: 이동 생성자와 복사 생성자 선택 기준 - 면접에서 자주 나오는 중요한 주제입니다.
4. **중간**: 이동 생성자 구현 주의사항 - 구현 시 중요한 주의사항입니다.
5. **중간**: 성능 최적화와 관련된 질문들 - 실무에서 중요한 주제입니다.

**특별 주의사항:**
- 이동된 후 원본 객체는 "초기화된 상태"가 아니라 "유효하지만 미정의 상태"로 만들어야 합니다.
- `noexcept`는 STL 컨테이너 사용에 필수적입니다. STL 컨테이너는 강한 예외 안전성을 보장하기 위해 `noexcept`가 없으면 복사 생성자를 선택합니다.
- 컴파일러는 rvalue일 때 이동 생성자를, lvalue일 때 복사 생성자를 선택합니다.
- 이동 생성자가 없으면 rvalue에서도 복사 생성자가 호출됩니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. 임시 객체나 자원의 소유권을 다른 객체로 이전하는 생성자입니다.
2. 복사는 데이터를 복제하고, 이동은 자원 소유권만 이전합니다.

### ✅ 등장 배경 / 필요성

3. 불필요한 깊은 복사로 인한 성능 저하를 해결하기 위해 등장했습니다.

### ✅ 언어 규칙 / 제약

4. 컨테이너가 예외 안전을 보장하기 위해 이동을 선택할 수 있게 하기 위함입니다.

### ✅ 컨테이너 / 실무 관점

5. 재할당(reallocation)이나 요소 이동이 잦을 때 중요합니다.
6. 복사 생성자가 호출되어 성능 저하가 발생합니다.
7. rvalue일 때는 이동 생성자를, lvalue일 때는 복사 생성자를 선택합니다.
8. 네, 이동 생성자가 없으면 복사 생성자가 호출됩니다.
9. 이동 생성자가 호출되어 정상적으로 동작합니다.

### ✅ noexcept와 예외 안전성

10. `noexcept`가 없으면 STL 컨테이너가 복사 생성자를 선택할 수 있습니다.
11. 부분적으로 이동된 상태가 되어 일관성이 깨질 수 있습니다.
12. `noexcept`가 있으면 컨테이너가 안전하게 이동을 선택할 수 있습니다.

### ✅ 이동 생성자와 복사 생성자 선택 기준

13. rvalue일 때는 이동 생성자, lvalue일 때는 복사 생성자를 선택합니다.
14. 네, 이동 생성자가 없으면 복사 생성자가 호출됩니다.
15. 이동 생성자가 호출되어 정상적으로 동작합니다.

### ✅ 이동 생성자 구현 / 동작 원리

16. 멤버를 이동하고 원본을 유효한 상태로 만들어야 합니다.
17. 유효하지만 미정의 상태로 만들어야 합니다.
18. `std::move`를 사용하여 멤버의 이동 생성자나 이동 대입 연산자를 호출합니다.

### ✅ 성능 / 최적화

19. 불필요한 복사를 제거하여 성능을 크게 향상시킬 수 있습니다.
20. 이동은 포인터 복사 수준으로 빠르고, 복사는 전체 데이터 복제로 느립니다.
21. 큰 객체나 자원을 가진 객체를 전달할 때 성능이 향상됩니다.

### ✅ 실무 / 설계 판단

22. 아니요, 이동이 의미 있는 클래스에만 정의하면 됩니다.
23. 작은 타입이나 이동이 복사와 비슷한 비용인 경우에는 필요 없습니다.
24. 자원의 소유권을 이전하여 불필요한 복사를 제거하는 생성자입니다.

</div>
</details>

