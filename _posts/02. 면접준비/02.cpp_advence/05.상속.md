---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 02.cpp_advence]
published: false
tags:
    [면접준비]
---

# 🧠 C++ virtual / vtable / override / final 면접 질문 리스트

## ✅ virtual 기본 개념

1. C++에서 virtual 키워드는 무엇을 의미하나요?

    - 해당 함수를 가상함수로 지정하겠다는 키워드입니다. 가상함수가 되면 기반클래스 포인터로 관리하고 있어도 가상함수를 호출하면 가장 마지막으로 override 된 함수가 호출됩니다.

2. virtual 함수가 필요한 이유는 무엇인가요?

    - 함수의 동적 바인딩, 다형성을 사용하기 위해 필요합니다.

## ✅ virtual 동적 바인딩 / 다형성

1. virtual 함수가 없으면 어떤 문제가 발생하나요?

    - virtual 함수가 없으면 다형성을 사용하지 못합니다. 기반클래스 포인터로 관리하는 객체들의 함수가 전부 기반 클래스의 함수로 호출되게 됩니다.

2. 정적 바인딩과 동적 바인딩의 차이는 무엇인가요?

    - 정적 바인딩은 컴파일 시간에 함수 호출부와 구현부를 연결시킬 수 있는 함수들을 뜻합니다. 함수 오버로드나 템플릿 함수등이 정적 바인딩에 속합니다. 동적바인딩은 런타임에 해당 함수를 실행하는 주체에 따라 연결점이 달라지는것을 동적바인딩이라고 합니다. 가상함수가 이에 해당합니다.

3. 어떤 기준으로 호출될 함수가 결정되나요?

    - 동적바인딩은 원래 클래스 기준으로 가장 마지막에 재정의된 함수가 호출됩니다.

## ✅ virtual 상속 관계에서의 동작

1. 부모 클래스 포인터로 자식 객체를 가리킬 때 virtual 함수는 어떻게 동작하나요?

    - vptr을 통해 vtable에 접근하고, vtable에 맞는 함수로 연결됩니다.

2. override 키워드는 어떤 역할을 하나요?

    - override 키워드는 virtual 키워드가 붙은 함수를 재정의 할 때 사용하는 키워드입니다. 재정의 한다는 것을 명시적으로 나타냅니다.

3. virtual 키워드를 자식 클래스에도 다시 써야 하나요?

    - 써도 잘못된 동작을 하지는 않습니다. 그러나 의미상 virtual 키워드는 없애고, override 키워드만 두는 것이 바람직 합니다.

## ✅ virtual 소멸자와 virtual

1. 소멸자를 virtual로 만들어야 하는 이유는 무엇인가요?

    - virtual 키워드가 붙은 함수가 하나라도 존재하는 클래스라면 다형성을 이용하기 위함입니다. 기반클래스 포인터로 객체들을 관리하고 있을 때 객체들에 대한 소멸을 호출하면 기반클래스의 소멸자가 호출되게 되어 자식 클래스의 소멸자가 호출되지 않아 메모리 누수가 발생할 수 있습니다. 따라서 파생클래스의 소멸자가 호출되도록, 하나 이상의 virtual 함수가 존재한다면 소멸자에도 반드시 virtual 키워드를 붙이는 것을 권장합니다.

## ✅ virtual 구현 / 비용 관점

1. virtual 함수 호출에는 어떤 비용이 있나요?

    - vtable을 거쳐야 하는 포인터 연산이 중간에 필요합니다.

## ✅ virtual 설계 판단

1. 모든 함수에 virtual을 붙이면 안 되는 이유는 무엇인가요?

    - vtable을 구성해야하는 불필요한 메모리가 소요되고, 함수 호출에 연산이 추가로 필요해 성능이 떨어집니다.

2. 언제 virtual 함수를 사용하는 것이 적절한가요?

    - 동적 바인딩이 필요한 함수에만 사용하는 것이 적절할 수 있습니다.

## ✅ virtual 요약 질문

1. virtual 키워드의 역할을 한 문장으로 요약해보세요.

    - 동적 바인딩을 하는 함수로 만들어주는 키워드입니다.

## ✅ vtable 기본 개념

1. vtable이란 무엇인가요?

    - virtual 함수 호출부가 어떤 함수 구현부로 바인딩 되어야할지 정보를 갖고있는 테이블 입니다.

2. vtable은 왜 필요한가요?

    - 동적 바인딩이 발생했을 때 필요합니다.

## ✅ vtable 메모리 구조

1. vtable은 어디에 저장되나요?

    - 힙 영역에 저장됩니다.

## ✅ vtable 함수 호출 흐름

1. virtual 함수 호출 시 실제 호출 대상은 어떻게 결정되나요?

    - vptr을 통해 vtable에 접근하고, 연결된 함수가 호출됩니다.

2. 정적 바인딩과 vtable 기반 동적 바인딩의 차이는 무엇인가요?

    - 정적 바인딩은 함수의 구현부가 컴파일타임에 결정되고, 동적 바인딩은 런타임에 결정됩니다.

## ✅ vtable 상속 / 오버라이딩

1. 자식 클래스가 virtual 함수를 오버라이드하면 vtable은 어떻게 되나요?

    - vtable이 해당 함수를 자식 클래스에서 오버라이드 한 함수를 가리키게 됩니다.

## ✅ vtable 생성자 / 소멸자 연계

1. 생성자와 소멸자에서 virtual 호출이 위험한 이유는 무엇인가요?

    - vtable이 완성되지 않았을 수 있기 때문에 동적 바인딩이 정상적으로 이뤄지지 않을 수 있습니다.

## ✅ vtable 비용 / 설계 판단

1. vtable 기반 호출의 비용은 무엇인가요?

    - 포인터 역참조 연산이 필요합니다.

2. vtable 구조가 인라이닝에 불리한 이유는 무엇인가요?

    - 어떤 함수의 구현부가 바인딩 될 지 모르기 때문에 인라이닝이 불가능합니다.

## ✅ override / final 기본 개념

1. override 키워드는 무엇을 의미하나요?

    - virtaul로 선언된 함수를 현재 클래스에서 재정의 한다는 것을 명시하는 키워드입니다.

2. final 키워드는 무엇을 의미하나요?

    - 현재 클래스에서 해당 함수의 override를 더이상 하지 않겠다고 선언하는 키워드. 현재 클래스를 상속한 파생클래스들은 해당 함수를 재정의 할 수 없습니다.

## ✅ override 이해

1. override를 사용하면 어떤 문제가 방지되나요?

    - override 키워드 없이 재정의 한다면 재정의 한 함수가 사라졌을 때 단독 함수로 판정되면서 의도하지 않은 동작이 발생할 수 있습니다. 따라서 override 키워드를 붙여 원본 함수가 사라졌을 때 재정의에 실패했음을 컴파일러의 도움을 통해 알 수 있습니다.

## ✅ 다이아몬드 상속 문제

1. 다이아몬드 상속 문제(Diamond Inheritance Problem)란 무엇인가요?

    - 

2. 다이아몬드 상속 문제가 발생하는 이유는 무엇인가요?

    - 

3. virtual 상속으로 다이아몬드 상속 문제를 어떻게 해결하나요?

    - 

4. virtual 상속의 비용은 무엇인가요?

    - 

5. virtual 상속 사용 시 주의사항은 무엇인가요?

    - 

6. virtual 상속 없이 다이아몬드 상속 문제를 해결할 수 있는 방법은 있나요?

    - 

7. 다이아몬드 상속 문제를 한 문장으로 요약해보세요.

    - 

## 📝 GPT 피드백

### ✅ virtual 기본 개념

**질문 1: C++에서 virtual 키워드는 무엇을 의미하나요?**
- **현재 답변**: "해당 함수를 가상함수로 지정하겠다는 키워드입니다. 가상함수가 되면 기반클래스 포인터로 관리하고 있어도 가상함수를 호출하면 가장 마지막으로 override 된 함수가 호출됩니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 맞지만 더 정확한 표현이 가능합니다.
  - ✅ **정확한 답변**: "함수 호출을 객체의 동적 타입 기준으로 결정하도록 만드는 키워드입니다."
  - "실제 타입"보다는 "동적 타입"이라는 표현이 더 정확합니다. virtual 키워드는 동적 타입 기준으로 함수 바인딩을 하라는 키워드입니다.

### ✅ virtual 동적 바인딩 / 다형성

**질문 1: virtual 함수가 없으면 어떤 문제가 발생하나요?**
- **현재 답변**: "virtual 함수가 없으면 다형성을 사용하지 못합니다. 기반클래스 포인터로 관리하는 객체들의 함수가 전부 기반 클래스의 함수로 호출되게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 맞지만 더 정확한 표현이 가능합니다.
  - ✅ **정확한 답변**: "정적 타입 기준으로 함수가 호출되어 자식 동작이 무시될 수 있습니다."
  - "기반 클래스의 함수로 호출"보다는 "정적 타입의 함수로 호출"이 더 정확한 표현입니다. 부모 타입의 함수를 호출하는 것이 아니라 정적 타입의 함수를 호출합니다.

**질문 3: 어떤 기준으로 호출될 함수가 결정되나요?**
- **현재 답변**: "동적바인딩은 원래 클래스 기준으로 가장 마지막에 재정의된 함수가 호출됩니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 맞지만 더 정확한 표현이 가능합니다.
  - ✅ **정확한 답변**: "객체의 동적 타입과 vtable을 기준으로 결정됩니다."
  - "원래 클래스 기준"보다는 "동적 타입 기준"이 더 정확한 표현입니다.

### ✅ vtable 메모리 구조

**질문 1: vtable은 어디에 저장되나요?**
- **현재 답변**: "힙 영역에 저장됩니다."
- **피드백**:
  - ❌ **오개념**: vtable은 힙 영역이 아니라 데이터 영역(정적 영역)에 저장됩니다.
  - ✅ **정확한 답변**: "일반적으로 프로그램의 정적 영역(데이터 영역)에 저장됩니다."
  - vtable은 프로그램의 정적 영역에 저장되며, 각 클래스마다 하나의 vtable이 존재합니다.

### ✅ 다이아몬드 상속 문제

**질문 1: 다이아몬드 상속 문제(Diamond Inheritance Problem)란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다.
  - ✅ **정확한 답변**: "공통 기반 클래스가 두 번 상속되어 모호성이 발생하는 상속 구조 문제입니다."

**질문 2: 다이아몬드 상속 문제가 발생하는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 다이아몬드 상속 문제 이해에 중요한 질문입니다.
  - ✅ **정확한 답변**: "공통 기반 클래스가 중간 클래스를 통해 두 번 상속되기 때문입니다."

**질문 3: virtual 상속으로 다이아몬드 상속 문제를 어떻게 해결하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 다이아몬드 상속 문제 해결 방법에 대한 질문입니다.
  - ✅ **정확한 답변**: "공통 기반 클래스를 virtual로 상속하여 단일 인스턴스만 생성되도록 합니다."

**질문 4: virtual 상속의 비용은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: virtual 상속의 비용 이해에 중요한 질문입니다.
  - ✅ **정확한 답변**: "추가적인 포인터 간접 참조와 메모리 오버헤드가 발생합니다."

**질문 5: virtual 상속 사용 시 주의사항은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: virtual 상속 사용 시 중요한 주의사항입니다.
  - ✅ **정확한 답변**: "생성자 초기화 순서와 가상 기반 클래스의 초기화를 주의해야 합니다."

**질문 6: virtual 상속 없이 다이아몬드 상속 문제를 해결할 수 있는 방법은 있나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 대안 방법에 대한 질문입니다.
  - ✅ **정확한 답변**: "인터페이스 분리나 컴포지션 패턴을 사용할 수 있습니다."

**질문 7: 다이아몬드 상속 문제를 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 핵심 개념을 요약하는 능력은 중요합니다.
  - ✅ **정확한 답변**: "공통 기반 클래스가 중복 상속되어 발생하는 모호성 문제입니다."

### 📊 전체 평가

**강점:**
- ✅ virtual 함수의 기본 개념과 동작을 정확히 이해하고 있습니다.
- ✅ 정적 바인딩과 동적 바인딩의 차이를 정확히 이해하고 있습니다.
- ✅ vtable의 기본 개념과 함수 호출 흐름을 정확히 이해하고 있습니다.
- ✅ override와 final 키워드의 역할을 정확히 이해하고 있습니다.
- ✅ 소멸자를 virtual로 만들어야 하는 이유를 정확히 이해하고 있습니다.

**개선 필요:**
- ❌ **오개념**: 
  - vtable의 저장 위치 (힙 영역 → 데이터 영역)
- ⚠️ **부정확한 부분**:
  - virtual 키워드 설명에서 "실제 타입" → "동적 타입" 표현
  - virtual 함수가 없을 때 "기반 클래스의 함수" → "정적 타입의 함수" 표현
  - 호출 함수 결정 기준에서 "원래 클래스 기준" → "동적 타입 기준" 표현
- ❌ **답변 누락**: 
  - 다이아몬드 상속 문제 관련 질문 (7개 질문)

**우선순위:**
1. **높음**: vtable의 저장 위치 오개념 수정 - vtable은 데이터 영역에 저장됩니다.
2. **높음**: 다이아몬드 상속 문제 관련 질문 답변 - 면접에서 자주 나오는 중요한 주제입니다.
3. **중간**: "동적 타입" 표현 사용 - "실제 타입"보다는 "동적 타입"이 더 정확한 표현입니다.
4. **중간**: "정적 타입" 표현 사용 - virtual 함수가 없을 때 정적 타입 기준으로 호출됩니다.
5. **낮음**: 표현의 정확성 개선 - 기술적으로 더 정확한 용어 사용이 필요합니다.

**특별 주의사항:**
- vtable은 힙 영역이 아니라 데이터 영역(정적 영역)에 저장됩니다.
- virtual 키워드는 동적 타입 기준으로 함수 바인딩을 하라는 키워드입니다.
- virtual 함수가 없으면 정적 타입 기준으로 함수가 호출됩니다.
- 부모 타입의 함수를 호출하는 것이 아니라 정적 타입의 함수를 호출합니다.
- 다이아몬드 상속 문제는 공통 기반 클래스가 중복 상속되어 발생하는 모호성 문제입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

## ✅ virtual

1. 함수 호출을 객체의 실제 타입 기준으로 결정하도록 만드는 키워드입니다.
2. 상속 관계에서 다형성을 구현하기 위해 필요합니다.

3. 부모 타입 기준으로 함수가 호출되어 자식 동작이 무시될 수 있습니다.
4. 정적 바인딩은 컴파일 타임 결정, 동적 바인딩은 런타임 결정입니다.
5. 객체의 실제 타입과 vtable을 기준으로 결정됩니다.

6. 포인터 타입이 아니라 실제 객체 타입의 함수가 호출됩니다.
7. 의도한 오버라이딩을 컴파일 타임에 검증해줍니다.
8. 아니요, 부모에 virtual이 있으면 자식에서도 자동으로 virtual입니다.

9. 부모 포인터로 자식 객체를 삭제할 때 전체 소멸을 보장하기 위해서입니다.

10. vtable을 통해 함수 포인터를 간접 호출합니다.
11. 간접 호출로 인한 약간의 런타임 오버헤드가 있습니다.

12. 불필요한 간접 호출 비용과 설계 복잡도가 증가하기 때문입니다.
13. 기반 클래스 인터페이스로 다형적 사용이 필요할 때입니다.

14. virtual은 “호출을 타입이 아닌 객체 기준으로 하라”는 지시입니다.

## ✅ vtable

1. virtual 함수 주소들을 모아둔 테이블입니다.
2. 런타임에 실제 객체 타입 기준으로 함수를 호출하기 위해 필요합니다.

3. 일반적으로 프로그램의 정적 영역에 저장됩니다.
4. 객체는 자신의 클래스에 해당하는 vtable을 가리키는 포인터를 가집니다.
5. 객체 내부에 숨겨진 vtable을 가리키는 포인터입니다.

6. 객체의 vptr이 가리키는 vtable에서 함수 주소를 찾아 호출합니다.

7. 오버라이드된 함수 주소가 자식 클래스의 vtable에 들어갑니다.
8. 포인터 타입과 무관하게 vptr을 통해 자식 vtable이 사용됩니다.

9. 해당 시점에는 vptr이 완전히 설정되지 않았거나 변경 중이기 때문입니다.

10. 간접 호출로 인한 분기 예측 실패 가능성과 약간의 오버헤드입니다.
11. 호출 대상이 컴파일 타임에 확정되지 않기 때문입니다.

## ✅ override / final

1. 기반 클래스의 virtual 함수를 재정의한다는 의도를 명시하는 키워드입니다.
2. 더 이상 재정의하거나 상속할 수 없음을 명시하는 키워드입니다.

3. 함수 시그니처 불일치로 인한 의도치 않은 오버로딩을 방지합니다.

## ✅ 다이아몬드 상속 문제

1. 공통 기반 클래스가 두 번 상속되어 모호성이 발생하는 상속 구조 문제입니다.
2. 공통 기반 클래스가 중간 클래스를 통해 두 번 상속되기 때문입니다.
3. 공통 기반 클래스를 virtual로 상속하여 단일 인스턴스만 생성되도록 합니다.
4. 추가적인 포인터 간접 참조와 메모리 오버헤드가 발생합니다.
5. 생성자 초기화 순서와 가상 기반 클래스의 초기화를 주의해야 합니다.
6. 인터페이스 분리나 컴포지션 패턴을 사용할 수 있습니다.
7. 공통 기반 클래스가 중복 상속되어 발생하는 모호성 문제입니다.

</div>
</details>

