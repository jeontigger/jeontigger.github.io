# 🧠 C++ std::shared_ptr 참조 카운팅 구조 이해 면접 질문 리스트

## ✅ 기본 개념

1. std::shared_ptr란 무엇인가요?

    - 자원을 가리키는 포인터를 가지고 다중 소유권을 원칙으로 하는 스마트 포인터입니다. 생성자에서 카운트를 증가시키고, 소멸자에서 카운트를 감소킵니다. 카운트가 0이 되는 순간 자원을 해제합니다.

2. shared_ptr는 어떤 방식으로 자원 수명을 관리하나요?

    - control block을 생성하여 내부적으로 카운트를 기록합니다. ref_count가 0이 되면 자원이 해제되고 weak_count도 0이되면 control block도 해제합니다.

## ✅ 참조 카운트 구조 (핵심)

1. 참조 카운트는 어디에 저장되나요?

    - 제어 블럭에 저장됩니다.

2. control block이란 무엇인가요?

    - 해당 자원을 몇개의 포인터가 가리키고 있는지 등의 정보를 가지고 있는 메타데이터 입니다.

3. 하나의 객체에 control block은 몇 개 존재하나요?

    - 원칙적으로는 하나의 객체에 하나의 제어 블럭만 존재합니다.

## ✅ 증가 / 감소 시점

1. 참조 카운트는 언제 증가하나요?

    - make_shared처럼 새로운 포인터를 생성할 때와 복제할 때 증가합니다.

2. 참조 카운트는 언제 감소하나요?

    - shared_ptr이 소멸할 때 감소합니다.

3. 참조 카운트가 0이 되면 어떤 일이 발생하나요?

    - 관리중인 자원을 해제합니다.

## ✅ use_count / 소멸 타이밍

1. use_count()는 무엇을 의미하나요?

    - 자원을 가리키는 포인터의 개수를 의미합니다.

2. use_count()를 로직 판단에 사용하면 안 되는 이유는 무엇인가요?

    - 모르겠습니다.

## ✅ weak_ptr 연계

1. weak_ptr는 참조 카운트에 어떤 영향을 주나요?

    - ref_count는 증가시키지 않지만 또다른 weak_count를 증가시킵니다.

2. weak_ptr가 필요한 이유는 무엇인가요?

    - shared_ptr의 순환참조문제로 메모리 누수를 방지하기위해 입니다.

## ✅ 스레드 / 비용 관점

1. shared_ptr의 참조 카운트는 스레드 안전한가요?
2. shared_ptr의 성능 비용은 어디서 발생하나요?

## ✅ 실무 / 버그 포인트

1. raw pointer로 shared_ptr를 여러 개 만들면 왜 위험한가요?

    - 제어 블럭이 여러개 생깁니다.

2. shared_ptr 참조 카운팅 구조를 한 문장으로 요약해보세요.

    - 제어 블럭의 참조 카운트로 자원 해제를 판단하는 다중 소유권 원칙의 스마트 포인터입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 여러 포인터가 하나의 객체를 공동 소유하는 스마트 포인터입니다.
2. 참조 카운트를 통해 마지막 소유자가 사라질 때 자원을 해제합니다.

3. 객체와 분리된 control block에 저장됩니다.
4. 참조 카운트, deleter, allocator 등을 담는 관리 구조체입니다.
5. 정상적인 사용에서는 하나만 존재합니다.

6. shared_ptr가 복사될 때 증가합니다.
7. shared_ptr가 소멸되거나 다른 객체를 가리키면 감소합니다.
8. 관리 대상 객체가 delete됩니다.

9. 해당 객체를 소유 중인 shared_ptr의 개수입니다.
10. 멀티스레드 환경에서 즉시 변할 수 있기 때문입니다.

11. 증가시키지 않습니다.
12. 순환 참조를 방지하기 위해서입니다.

13. 네, 참조 카운트 증감은 원자적으로 수행됩니다.
14. 원자 연산과 control block 접근 비용입니다.

15. 서로 다른 control block이 생겨 이중 delete가 발생할 수 있습니다.
16. shared_ptr는 “control block의 참조 카운트로 수명을 관리하는 포인터”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 증가 / 감소 시점

**질문 2: 참조 카운트는 언제 감소하나요?**
- **현재 답변**: "shared_ptr이 소멸할 때 감소합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 부분적으로만 맞습니다
  - ✅ **정확한 답변**: "shared_ptr이 소멸되거나 다른 객체를 가리키면 감소합니다"
  - shared_ptr에 다른 객체를 할당하거나 reset()을 호출하면 기존 객체에 대한 참조 카운트가 감소합니다

### ✅ use_count / 소멸 타이밍

**질문 2: use_count()를 로직 판단에 사용하면 안 되는 이유는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "멀티스레드 환경에서 즉시 변할 수 있기 때문입니다"
  - use_count()는 호출 시점의 값을 반환하지만, 반환 직후 다른 스레드에서 참조 카운트가 변경될 수 있어 로직 판단에 사용하면 race condition이 발생할 수 있습니다

### ✅ 스레드 / 비용 관점

**질문 1: shared_ptr의 참조 카운트는 스레드 안전한가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "네, 참조 카운트 증감은 원자적으로 수행됩니다"
  - shared_ptr의 참조 카운트 증감 연산은 원자 연산(atomic operation)으로 구현되어 멀티스레드 환경에서 안전합니다

**질문 2: shared_ptr의 성능 비용은 어디서 발생하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 질문입니다
  - ✅ **정확한 답변**: "원자 연산과 control block 접근 비용입니다"
  - 참조 카운트 증감 시 원자 연산 오버헤드와 control block에 대한 접근 비용이 발생합니다. 또한 control block 자체의 메모리 할당 비용도 있습니다

### ✅ 실무 / 버그 포인트

**질문 1: raw pointer로 shared_ptr를 여러 개 만들면 왜 위험한가요?**
- **현재 답변**: "제어 블럭이 여러개 생깁니다."
- **피드백**:
  - 💡 **보완**: "서로 다른 control block이 생겨 이중 delete가 발생할 수 있습니다"라고 구체적으로 설명하면 더 좋습니다
  - 각 shared_ptr가 독립적인 control block을 생성하므로, 하나의 shared_ptr가 객체를 해제한 후 다른 shared_ptr가 같은 객체를 다시 해제하려고 시도하여 정의되지 않은 동작이 발생합니다

### 📊 전체 평가

**강점:**
- shared_ptr의 기본 개념과 control block 구조 이해
- 참조 카운트 증가 시점 파악
- weak_ptr의 역할 이해
- raw pointer로 여러 shared_ptr 생성 시 문제점 인지

**개선 필요:**
- ❌ **높음**: use_count()를 로직 판단에 사용하면 안 되는 이유에 대한 답변이 필요합니다
- ❌ **높음**: shared_ptr의 스레드 안전성에 대한 답변이 필요합니다
- ❌ **중간**: shared_ptr의 성능 비용에 대한 답변이 필요합니다
- ⚠️ **중간**: 참조 카운트 감소 시점 설명이 불완전합니다 (다른 객체를 가리킬 때도 감소)
- 💡 **낮음**: raw pointer로 여러 shared_ptr 생성 시 이중 delete 문제를 더 구체적으로 설명할 수 있습니다

**우선순위:**
1. **높음**: use_count()를 로직 판단에 사용하면 안 되는 이유(멀티스레드 환경에서 즉시 변할 수 있음)를 이해해야 합니다
2. **높음**: shared_ptr의 참조 카운트 증감이 원자 연산으로 구현되어 스레드 안전하다는 점을 이해해야 합니다
3. **중간**: shared_ptr의 성능 비용(원자 연산, control block 접근)을 이해해야 합니다
4. **중간**: 참조 카운트가 소멸뿐만 아니라 다른 객체를 가리킬 때도 감소한다는 점을 이해해야 합니다

**특별 주의사항:**
- use_count()와 스레드 안전성은 면접에서 자주 나오는 주제입니다
- shared_ptr의 성능 비용은 실무에서 고려해야 할 중요한 요소입니다
- raw pointer로 여러 shared_ptr를 생성하면 control block이 여러 개 생겨 이중 delete가 발생할 수 있습니다

