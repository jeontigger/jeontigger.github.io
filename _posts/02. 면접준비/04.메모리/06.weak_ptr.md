# 🧠 C++ std::weak_ptr 사용 이유 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. std::weak_ptr란 무엇인가요?

    - shared_ptr의 순환참조 문제를 해결하기 위해 등장한 스마트 포인터입니다. 자원을 가리켜도 참조 카운트를 증가시키지 않습니다.

2. weak_ptr는 shared_ptr와 어떤 관계인가요?

    - weak_ptr은 shared_ptr로 승격할 수 있습니다.

## ✅ 사용 이유 (핵심)

1. weak_ptr는 왜 필요한가요?

    - shared_ptr의 순환참조 문제를 해결하기 위해 필요합니다.

2. shared_ptr만 사용하면 어떤 문제가 발생하나요?

    - 순환 참조 문제가 발생합니다.

## ✅ 참조 카운트 관점

1. weak_ptr는 참조 카운트에 어떤 영향을 주나요?

    - 참조 카운트에는 영향을 주지 않습니다.

2. weak_ptr가 객체 수명에 영향을 주지 않는 이유는 무엇인가요?

    - 참조 카운트를 증가시키지 않기 때문에 객체는 참조 카운트에 의존적으로 수명이 결정됩니다.

## ✅ 순환 참조 문제

1. 순환 참조(cyclic reference)란 무엇인가요?

    - shared_ptr이 서로를 가리켜 참조 카운트가 감소되지 않는 문제가 있습니다.

2. weak_ptr는 순환 참조를 어떻게 해결하나요?

    - ref_count를 증가시키지 않고 weak_count를 증가시킵니다.

## ✅ API 동작 이해

1. weak_ptr는 어떻게 객체에 접근하나요?

    - 가리키고 있는지 유효한지만 구분할 수 있습니다. 사용하려면 승격시켜야 합니다.

2. lock() 함수는 어떤 역할을 하나요?

    - 

3. expired()는 언제 true가 되나요?

    - 가리키는 자원이 해제되었을 때 true를 반환합니다.

## ✅ 안전성 / 설계 판단

1. weak_ptr로 직접 객체에 접근할 수 없는 이유는 무엇인가요?

    - 설계 원칙입니다. 직접 접근하는 것은 unique_ptr과 shared_ptr로 제한합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. shared_ptr가 관리하는 객체를 소유하지 않고 참조만 하는 스마트 포인터입니다.
2. 동일한 control block을 공유하지만 참조 카운트는 증가시키지 않습니다.

3. 객체를 소유하지 않고 관찰만 하기 위해 필요합니다.
4. 순환 참조로 인해 참조 카운트가 0이 되지 않을 수 있습니다.

5. 증가시키지 않습니다.
6. 소유권을 가지지 않기 때문입니다.

7. 객체들이 서로를 shared_ptr로 참조해 해제되지 않는 상태입니다.
8. 한쪽 참조를 weak_ptr로 만들어 참조 카운트 증가를 막습니다.

9. lock()을 통해 shared_ptr로 변환해야 합니다.
10. 객체가 살아 있을 때만 shared_ptr를 안전하게 반환합니다.
11. 관리 대상 객체가 이미 해제된 경우입니다.

12. 객체가 이미 소멸되었을 수 있기 때문입니다.
13. observer 패턴, 캐시, 부모-자식 관계입니다.

14. lock() 결과가 null일 수 있음을 항상 고려해야 합니다.
15. weak_ptr는 “소유하지 않는 안전한 참조”를 위한 포인터입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 순환 참조 문제

**질문 1: 순환 참조(cyclic reference)란 무엇인가요?**
- **현재 답변**: "shared_ptr이 서로를 가리켜 참조 카운트가 감소되지 않는 문제가 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "shared_ptr이 서로를 가리킨다"는 표현이 부정확합니다
  - ✅ **정확한 답변**: "객체들이 서로를 shared_ptr로 참조해 해제되지 않는 상태입니다"
  - 순환 참조는 shared_ptr 자체가 서로를 가리키는 것이 아니라, 객체 A가 객체 B를 shared_ptr로 참조하고, 객체 B가 다시 객체 A를 shared_ptr로 참조하는 구조입니다

### ✅ API 동작 이해

**질문 2: lock() 함수는 어떤 역할을 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "객체가 살아 있을 때만 shared_ptr를 안전하게 반환합니다"
  - lock()은 weak_ptr이 가리키는 객체가 아직 살아있는지 확인하고, 살아있다면 shared_ptr을 반환합니다. 객체가 이미 해제되었다면 빈 shared_ptr을 반환합니다

### ✅ 안전성 / 설계 판단

**질문 1: weak_ptr로 직접 객체에 접근할 수 없는 이유는 무엇인가요?**
- **현재 답변**: "설계 원칙입니다. 직접 접근하는 것은 unique_ptr과 shared_ptr로 제한합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 너무 단순하고 핵심을 놓치고 있습니다
  - ✅ **정확한 답변**: "객체가 이미 소멸되었을 수 있기 때문입니다"
  - weak_ptr은 참조 카운트를 증가시키지 않으므로, 객체가 언제든지 해제될 수 있습니다. 직접 접근을 허용하면 이미 해제된 객체에 접근할 위험이 있어 안전하지 않습니다. 따라서 lock()을 통해 객체가 살아있는지 확인한 후 shared_ptr로 변환해야 합니다

### 📊 전체 평가

**강점:**
- weak_ptr의 기본 개념과 사용 이유 이해
- 참조 카운트에 미치는 영향 파악
- 순환 참조 해결 방법 이해
- expired() 함수 동작 이해

**개선 필요:**
- ❌ **높음**: lock() 함수의 역할에 대한 답변이 필요합니다
- ⚠️ **중간**: 순환 참조의 개념을 더 정확히 이해해야 합니다 (객체 간 상호 참조 구조)
- ⚠️ **중간**: weak_ptr로 직접 접근할 수 없는 이유를 더 구체적으로 이해해야 합니다 (객체가 이미 소멸되었을 수 있음)

**우선순위:**
1. **높음**: lock() 함수의 역할(객체가 살아 있을 때만 shared_ptr 반환)을 이해해야 합니다
2. **중간**: 순환 참조는 shared_ptr이 서로를 가리키는 것이 아니라, 객체들이 서로를 참조하는 구조임을 정확히 이해해야 합니다
3. **중간**: weak_ptr로 직접 접근할 수 없는 이유는 객체가 이미 소멸되었을 수 있기 때문임을 이해해야 합니다

**특별 주의사항:**
- lock() 함수는 weak_ptr 사용 시 필수적인 API이며, 면접에서 자주 나오는 질문입니다
- weak_ptr은 참조 카운트를 증가시키지 않으므로 객체가 언제든지 해제될 수 있어, lock()을 통해 안전하게 접근해야 합니다

