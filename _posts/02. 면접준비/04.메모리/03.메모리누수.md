# 🧠 C++ 메모리 누수(memory leak) 발생 원인 면접 질문 리스트

## ✅ 기본 개념

1. 메모리 누수란 무엇인가요?

    - 힙 영역에 메모리를 할당은 했지만 해제를 요청하지 않아 사용중이지만 사용할 수 없는 메모리가 생기면 메모리 누수라고 합니다.

2. 메모리 누수가 왜 문제가 되나요?

    - 메모리가 필요할 때 필요한 메모리 영역을 할당받지 못할 수 있습니다.

## ✅ 대표적인 발생 원인

1. new로 할당한 메모리를 delete하지 않으면 어떤 문제가 발생하나요?

    - 메모리 누수가 발생합니다.

2. 예외 발생 시 메모리 누수가 생기는 이유는 무엇인가요?

    - 보통 delete 키워드를 함수 마지막에 사용하는데, 중간에 예외가 발생한다면 이후의 구문들은 실행하지 않고 스택 언와인딩을 하기 때문에 catch 구문에 모든 delete 대응이 되어있지 않는다면 메모리 누수가 발생하게 됩니다.

3. 함수 조기 return이 메모리 누수를 유발하는 경우는 언제인가요?

    - new를 하고 조기리턴 구문에 delete를 적지 않았을 경우에 발생합니다.

## ✅ 포인터 관련 실수

1. 포인터를 덮어쓸 때 메모리 누수가 발생하는 이유는 무엇인가요?

    - 기존에 힙 영역을 가리키던 포인터가 메모리 해제를 하지 않고 다른 힙 영역으로 덮어씌워진다면 가리키고 있던 힙 영역의 메모리는 아무 포인터도 가리키지 않을 때 메모리 누수가 발생합니다.

2. dangling pointer와 메모리 누수의 차이는 무엇인가요?

    - 댕글링 포인터는 해제된 메모리 영역을 가리키고 있는 포인터입니다. 접근하면 정의되지 않은 동작을 수행합니다. 메모리 누수는 해제되지 않은 메모리 영역을 가리키는 포인터가 없는 상태를 뜻합니다.

3. 이중 포인터(double delete)와 메모리 누수는 어떤 관계가 있나요?

    - 이중 딜리트는 해제한 메모리 영역을 다시 한 번 해제하려고 할 때 발생합니다. 메모리 누수는 해제하지 않은 메모리 영역을 어떤 포인터도 가리키지 않을 때 발생합니다.

## ✅ 컨테이너 / STL 사용 실수

1. STL 컨테이너 사용 시 메모리 누수가 발생하는 경우는 언제인가요?

    - raw pointer로 저장할 때 해제시 delete하지 않으면 메모리 누수가 발생합니다.

2. 컨테이너에 raw pointer를 저장할 때 주의할 점은 무엇인가요?

    - 더이상 사용하지 않을 때 delete해주어야 합니다.

## ✅ 순환 참조

1. 순환 참조(cyclic reference)란 무엇인가요?

    - 서로 다른 shared_ptr이 각자를 가리키는 것을 순환참조라고 말합니다.

2. shared_ptr에서 메모리 누수가 발생하는 이유는 무엇인가요?

    - 순환참조가 발생하면 refcount가 0이 되지 않아 메모리 누수가 발생합니다.

## ✅ 리소스 관리 범위 확장

1. 메모리 외에 누수가 발생할 수 있는 자원에는 무엇이 있나요?

    - mutex, file 포인터 등이 있습니다.

2. 메모리 누수 방지를 위한 기본 원칙은 무엇인가요?

    - RAII를 사용합니다.

## ✅ 요약 질문

1. 메모리 누수 발생 원인을 한 문장으로 요약해보세요.

    - 소멸시에 해야하는 함수호출을 하지 않았을 때 발생합니다. 예외가 발생할 때까지의 대처는 어렵기 때문에 RAII를 사용합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ?? 1줄 모범 답변

1. 더 이상 접근할 수 없는 메모리가 해제되지 않고 남아 있는 상태입니다.
2. 메모리 고갈, 성능 저하, 프로그램 불안정을 유발합니다.

3. 해제되지 않은 힙 메모리가 영구적으로 남습니다.
4. 예외로 인해 delete 경로가 실행되지 않을 수 있기 때문입니다.
5. 해제 코드에 도달하지 못하고 함수가 종료될 때입니다.

6. 기존 포인터를 잃어버려 해제할 수 없게 되기 때문입니다.
7. dangling pointer는 해제 후 접근, 누수는 해제 자체가 안 된 상태입니다.
8. double delete는 다른 오류이며 누수와는 별개로 정의되지 않은 동작입니다.

9. raw pointer를 저장하고 명시적으로 해제하지 않을 때입니다.
10. 소유권과 해제 책임을 명확히 해야 합니다.

11. 객체들이 서로를 참조해 참조 카운트가 0이 되지 않는 상태입니다.
12. 순환 참조로 참조 카운트가 줄지 않기 때문입니다.

13. 파일 핸들, 소켓, 뮤텍스, GPU 자원 등입니다.
14. RAII를 사용해 소유권과 수명을 묶는 것입니다.

15. 메모리 누수는 “할당은 했지만 해제 경로를 잃은 상태”입니다.

</div>
</details>

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 2: 메모리 누수가 왜 문제가 되나요?**
- **현재 답변**: "메모리가 필요할 때 필요한 메모리 영역을 할당받지 못할 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: 메모리 고갈만 언급하고 있습니다
  - ✅ **정확한 답변**: "메모리 고갈, 성능 저하, 프로그램 불안정을 유발합니다"
  - 메모리 누수는 단순히 메모리 부족뿐만 아니라 가비지 컬렉션 오버헤드, 캐시 미스 증가, 시스템 불안정성 등 다양한 문제를 야기합니다

### ✅ 순환 참조

**질문 1: 순환 참조(cyclic reference)란 무엇인가요?**
- **현재 답변**: "서로 다른 shared_ptr이 각자를 가리키는 것을 순환참조라고 말합니다."
- **피드백**:
  - ⚠️ **부정확**: "서로 다른 shared_ptr이 각자를 가리키는 것"이라는 표현이 부정확합니다
  - ✅ **정확한 답변**: "객체들이 서로를 참조해 참조 카운트가 0이 되지 않는 상태입니다"
  - 순환 참조는 객체 A가 객체 B를 참조하고, 객체 B가 다시 객체 A를 참조하는 구조입니다. shared_ptr이 서로를 직접 가리키는 것이 아니라, 객체들이 서로를 참조하는 구조입니다

### ✅ 리소스 관리 범위 확장

**질문 1: 메모리 외에 누수가 발생할 수 있는 자원에는 무엇이 있나요?**
- **현재 답변**: "mutex, file 포인터 등이 있습니ㅏㄷ."
- **피드백**:
  - ⚠️ **오타**: "있습니ㅏㄷ" → "있습니다"
  - ✅ **정확한 답변**: "파일 핸들, 소켓, 뮤텍스, GPU 자원 등입니다"
  - file 포인터보다는 "파일 핸들"이 더 정확한 표현이며, 소켓, GPU 자원 등도 포함해야 합니다

**질문 2: 컨테이너에 raw pointer를 저장할 때 주의할 점은 무엇인가요?**
- **현재 답변**: "더이상 사용하지 않을 때 delete해주어야 합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 너무 단순하고 핵심을 놓치고 있습니다
  - ✅ **정확한 답변**: "소유권과 해제 책임을 명확히 해야 합니다"
  - 단순히 delete만 하는 것이 아니라, 누가 소유권을 가지고 언제 해제할 책임이 있는지 명확히 해야 합니다. 컨테이너가 소유권을 가지는지, 외부에서 관리하는지에 따라 접근 방식이 달라집니다

### 📊 전체 평가

**강점:**
- 메모리 누수의 기본 개념 이해
- 예외 발생 시 메모리 누수 원인 파악
- dangling pointer와 메모리 누수의 차이 구분
- double delete와 메모리 누수의 관계 이해
- RAII 사용 원칙 인지

**개선 필요:**
- ⚠️ **중간**: 메모리 누수의 문제점을 더 포괄적으로 이해해야 합니다 (고갈뿐만 아니라 성능, 안정성)
- ⚠️ **중간**: 순환 참조의 개념을 더 정확히 이해해야 합니다 (객체 간 상호 참조 구조)
- ⚠️ **중간**: 컨테이너에 raw pointer 저장 시 소유권 개념을 명확히 해야 합니다
- ⚠️ **낮음**: 오타 수정 필요

**우선순위:**
1. **중간**: 메모리 누수의 문제점을 메모리 고갈뿐만 아니라 성능 저하, 프로그램 불안정까지 포함하여 이해해야 합니다
2. **중간**: 순환 참조는 shared_ptr이 서로를 직접 가리키는 것이 아니라, 객체들이 서로를 참조하는 구조임을 정확히 이해해야 합니다
3. **중간**: 컨테이너에 raw pointer 저장 시 소유권과 해제 책임을 명확히 해야 합니다

**특별 주의사항:**
- 메모리 누수는 단순히 메모리 부족 문제가 아니라 성능 저하와 시스템 불안정성까지 유발할 수 있습니다
- 순환 참조는 shared_ptr의 참조 카운팅 메커니즘과 관련된 중요한 개념이므로 정확히 이해해야 합니다

