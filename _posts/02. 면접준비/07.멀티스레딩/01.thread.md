# 🧠 C++ std::thread 사용법 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. std::thread란 무엇인가요?

    - 스레드란 프로세스내에서 또다른 실행흐름을 만들 수 있는 클래스입니다.

2. 스레드 생성은 어떻게 하나요?

    - 

## ✅ 함수/람다 전달

1. thread에 함수 포인터를 넘기는 방법은 무엇인가요?

    - std::bind로 넘겨야 합니다.

2. thread에 람다를 넘길 때 주의할 점은 무엇인가요?

    - 

## ✅ 인자 전달 규칙

1. thread에 인자를 전달하면 기본적으로 값 복사인가요?

    - 기본적으로는 값 복사입니다. 

2. 참조로 전달하려면 어떻게 해야 하나요?

    - perfect_forward 함수를 사용해야 합니다.

3. move-only 타입(unique_ptr 등)을 thread에 넘기는 방법은 무엇인가요?

    - std::move를 통해 넘기면 됩니다.

## ✅ 생명 주기 관리 (핵심)

1. join()은 무엇이고 언제 사용하나요?

    - join은 해당 스레드가 완료될 때 까지 블로킹되는 함수입니다.

2. detach()는 무엇이고 언제 위험한가요?

    - detach는 스레드가 백그라운드에서 동작하도록 하는 함수입니다. 메인 스레드가 종료되기 전에 서브 스레드들이 종료를 확인하지 않으면 비정상적인 종료가 이뤄질 수 있습니다.

3. joinable()은 무엇을 의미하나요?

    - 스레드가 종료됐는지 여부를 반환합니다.

## ✅ 예외 / 종료

1. thread 객체가 join/detach 없이 파괴되면 어떻게 되나요?

    - 

2. 스레드 함수에서 예외가 발생하면 어떻게 되나요?

    - 해당 스레드만 종료될수도, 프로세스 전체에 영향이 갈수도 있습니다.

## ✅ 동기화 / 공유 데이터

1. 스레드 간 공유 데이터 접근 시 무엇이 필요하나요?

    - 동기화 객체가 필요합니다.

2. mutex와 atomic을 각각 언제 쓰나요?

    - mutex는 여러 표현식이 critical section에 해당할 때 사용하고, atmoic은 하나의 변수 동기화를 하는데 사용하는 것을 권장합니다.

## ✅ 유틸리티

1. std::this_thread::sleep_for는 무엇인가요?

    - thread를 인자에 들어간 ms만큼 재웁니다.

2. std::thread::hardware_concurrency는 무엇을 의미하나요?

    - 

## ✅ 요약 질문

1. std::thread 사용 시 가장 중요한 규칙 한 가지를 말해보세요.

    - 동기화와 종료여부가 가장 중요합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

### ✅ 기본 개념

1. C++ 표준 라이브러리의 OS 스레드 래퍼입니다.
2. std::thread에 실행할 callable을 넘겨 생성합니다.

### ✅ 함수/람다 전달

1. std::thread(f, args...) 형태로 넘깁니다.
2. 캡처한 객체의 수명(lifetime)을 보장해야 합니다.

### ✅ 인자 전달 규칙

1. 기본은 값 복사입니다.
2. std::ref / std::cref로 감싸서 전달합니다.
3. std::move로 rvalue로 전달합니다.

### ✅ 생명 주기 관리 (핵심)

1. 스레드가 끝날 때까지 대기하며 합류합니다.
2. 백그라운드로 분리하며, 수명 관리 실패 시 UB가 될 수 있습니다.
3. join 또는 detach가 가능한 스레드인지 여부입니다.

### ✅ 예외 / 종료

1. std::terminate가 호출됩니다.
2. 예외가 스레드 밖으로 전파되지 않으므로 내부에서 처리해야 합니다.

### ✅ 동기화 / 공유 데이터

1. mutex 또는 atomic 같은 동기화가 필요합니다.
2. 단일 변수는 atomic, 여러 변수 불변식은 mutex가 적절합니다.

### ✅ 유틸리티

1. 현재 스레드를 지정 시간 동안 재웁니다.
2. 동시 실행 가능한 하드웨어 스레드 수의 힌트입니다.

### ✅ 요약 질문

1. join/detach를 반드시 처리해야 합니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: std::thread란 무엇인가요?**
- **현재 답변**: "스레드란 프로세스내에서 또다른 실행흐름을 만들 수 있는 클래스입니다."
- **피드백**:
  - ⚠️ **부정확**: "OS 스레드 래퍼"라는 핵심 개념이 누락되었습니다
  - ✅ **정확한 답변**: "C++ 표준 라이브러리의 OS 스레드 래퍼입니다"
  - std::thread는 단순한 클래스가 아니라 OS의 네이티브 스레드를 감싸는 래퍼 클래스입니다

**질문 2: 스레드 생성은 어떻게 하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 기본 질문입니다
  - ✅ **정확한 답변**: "std::thread에 실행할 callable(함수, 함수 포인터, 함수 객체, 람다 등)을 넘겨 생성합니다"
  - 예: `std::thread t(func, arg1, arg2);`

### ✅ 함수/람다 전달

**질문 1: thread에 함수 포인터를 넘기는 방법은 무엇인가요?**
- **현재 답변**: "std::bind로 넘겨야 합니다."
- **피드백**:
  - ❌ **오개념**: std::bind는 필수가 아닙니다. 함수 포인터를 직접 넘길 수 있습니다
  - ✅ **정확한 답변**: "std::thread(f, args...) 형태로 직접 넘깁니다"
  - std::bind는 인자를 바인딩할 때만 필요하며, 함수 포인터 자체는 직접 전달 가능합니다
  - 예: `std::thread t(func_ptr, arg1, arg2);`

**질문 2: thread에 람다를 넘길 때 주의할 점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "캡처한 객체의 수명(lifetime)을 보장해야 합니다"
  - 람다가 참조로 캡처한 지역 변수가 스레드보다 먼저 파괴되면 undefined behavior가 발생합니다

### ✅ 인자 전달 규칙

**질문 2: 참조로 전달하려면 어떻게 해야 하나요?**
- **현재 답변**: "perfect_forward 함수를 사용해야 합니다."
- **피드백**:
  - ❌ **오개념**: "perfect_forward"라는 함수는 존재하지 않습니다
  - ✅ **정확한 답변**: "std::ref / std::cref로 감싸서 전달합니다"
  - std::ref는 참조 래퍼를 만들어 값 복사 대신 참조로 전달합니다
  - 예: `std::thread t(func, std::ref(var));`

### ✅ 생명 주기 관리 (핵심)

**질문 2: detach()는 무엇이고 언제 위험한가요?**
- **현재 답변**: "detach는 스레드가 백그라운드에서 동작하도록 하는 함수입니다. 메인 스레드가 종료되기 전에 서브 스레드들이 종료를 확인하지 않으면 비정상적인 종료가 이뤄질 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "비정상적인 종료"보다는 "undefined behavior(UB)"가 더 정확한 표현입니다
  - 💡 **보완**: "수명 관리 실패 시 undefined behavior가 발생할 수 있습니다"
  - detach된 스레드가 참조하는 객체가 파괴되면 UB가 발생합니다

**질문 3: joinable()은 무엇을 의미하나요?**
- **현재 답변**: "스레드가 종료됐는지 여부를 반환합니다."
- **피드백**:
  - ❌ **오개념**: joinable()은 스레드 종료 여부가 아니라 join/detach 가능 여부를 확인합니다
  - ✅ **정확한 답변**: "join 또는 detach가 가능한 스레드인지 여부를 반환합니다"
  - 스레드가 이미 join되거나 detach되었으면 joinable()은 false를 반환합니다
  - 기본 생성된 thread 객체도 joinable()은 false입니다

### ✅ 예외 / 종료

**질문 1: thread 객체가 join/detach 없이 파괴되면 어떻게 되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 매우 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "std::terminate가 호출되어 프로그램이 강제 종료됩니다"
  - joinable한 thread 객체를 파괴하면 std::terminate()가 호출됩니다

**질문 2: 스레드 함수에서 예외가 발생하면 어떻게 되나요?**
- **현재 답변**: "해당 스레드만 종료될수도, 프로세스 전체에 영향이 갈수도 있습니다."
- **피드백**:
  - ❌ **오개념**: 예외는 스레드 밖으로 전파되지 않습니다
  - ✅ **정확한 답변**: "예외가 스레드 밖으로 전파되지 않으므로 내부에서 처리해야 합니다"
  - 예외가 발생하면 해당 스레드만 종료되며, 다른 스레드나 프로세스에 영향을 주지 않습니다
  - 예외를 전파하려면 promise/future나 shared state를 사용해야 합니다

### ✅ 동기화 / 공유 데이터

**질문 2: mutex와 atomic을 각각 언제 쓰나요?**
- **현재 답변**: "mutex는 여러 표현식이 critical section에 해당할 때 사용하고, atmoic은 하나의 변수 동기화를 하는데 사용하는 것을 권장합니다."
- **피드백**:
  - ⚠️ **오타**: "atmoic" → "atomic"
  - 💡 **보완**: "여러 변수 간의 불변식(invariant)을 보장해야 할 때는 mutex가 적절합니다"
  - 단일 변수는 atomic, 여러 변수 간의 관계(불변식)를 보장해야 할 때는 mutex를 사용합니다

### ✅ 유틸리티

**질문 1: std::this_thread::sleep_for는 무엇인가요?**
- **현재 답변**: "thread를 인자에 들어간 ms만큼 재웁니다."
- **피드백**:
  - ⚠️ **부정확**: "ms만큼"은 정확하지 않습니다. duration 타입을 받으며 단위는 자유롭게 지정 가능합니다
  - ✅ **정확한 답변**: "현재 스레드를 지정 시간 동안 재웁니다"
  - std::chrono::milliseconds, seconds, microseconds 등 다양한 단위 사용 가능합니다
  - 예: `std::this_thread::sleep_for(std::chrono::milliseconds(100));`

**질문 2: std::thread::hardware_concurrency는 무엇을 의미하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 스레드 풀 설계 시 중요한 정보입니다
  - ✅ **정확한 답변**: "동시 실행 가능한 하드웨어 스레드 수의 힌트를 반환합니다"
  - CPU 코어 수와 관련이 있으며, 스레드 풀의 최적 크기를 결정할 때 참고합니다
  - 0을 반환할 수도 있으므로 "힌트"라는 표현이 중요합니다

### ✅ 요약 질문

**질문 1: std::thread 사용 시 가장 중요한 규칙 한 가지를 말해보세요.**
- **현재 답변**: "동기화와 종료여부가 가장 중요합니다."
- **피드백**:
  - ⚠️ **부정확**: 질문은 "한 가지"를 요구하는데 두 가지를 언급했습니다
  - 💡 **보완**: "join/detach를 반드시 처리해야 합니다"가 가장 기본적이고 중요한 규칙입니다
  - join/detach 미처리는 std::terminate를 유발하므로 동기화보다 더 근본적인 문제입니다

### 📊 전체 평가

**강점:**
- ✅ join()의 블로킹 개념을 정확히 이해함
- ✅ move-only 타입 전달 방법(std::move)을 정확히 알고 있음
- ✅ 기본적인 값 복사 개념을 이해함
- ✅ 동기화 객체의 필요성을 인지함

**개선 필요:**
- ❌ **오개념**: 함수 포인터 전달 시 std::bind 필수라고 잘못 이해함
- ❌ **오개념**: perfect_forward라는 존재하지 않는 함수 언급
- ❌ **오개념**: joinable()의 의미를 잘못 이해함 (종료 여부 vs join/detach 가능 여부)
- ❌ **오개념**: 스레드 예외 전파에 대한 잘못된 이해
- ⚠️ **부정확**: std::thread의 "OS 스레드 래퍼" 개념 누락
- ⚠️ **부정확**: detach의 위험성을 "비정상 종료"로 표현 (UB가 더 정확)
- ⚠️ **부정확**: sleep_for의 시간 단위를 ms로 한정
- ❌ **답변 누락**: 스레드 생성 방법, 람다 주의사항, join/detach 없이 파괴 시 동작, hardware_concurrency

**우선순위:**
1. **높음**: 
   - join/detach 없이 파괴 시 std::terminate 호출 (면접 단골 질문)
   - joinable()의 정확한 의미 (join/detach 가능 여부)
   - 스레드 예외는 전파되지 않는다는 사실
2. **중간**: 
   - 함수 포인터는 std::bind 없이 직접 전달 가능
   - 참조 전달은 std::ref/std::cref 사용
   - 람다 캡처 객체의 수명 관리
3. **낮음**: 
   - sleep_for의 시간 단위 표현 개선
   - std::thread의 OS 래퍼 개념 보완

**특별 주의사항:**
- **join/detach 규칙**: joinable한 thread 객체를 파괴하면 std::terminate가 호출됩니다. 이는 면접에서 매우 자주 나오는 질문입니다.
- **예외 처리**: 스레드 내부 예외는 절대 밖으로 전파되지 않습니다. 이는 많은 개발자가 오해하는 부분입니다.
- **joinable() vs 종료 여부**: joinable()은 스레드가 종료되었는지가 아니라 join/detach 가능한지 여부를 확인합니다.

