# 🧠 C++ std::async / std::future 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. std::async란 무엇인가요?

    - 스레드처럼 비동기 실행을 만드는 클래스입니다.

2. std::future란 무엇인가요?

    - 나중에 async로 보낸 함수가 종료되고나서 값을 받을 수 있는 객체입니다.

3. async와 thread의 차이는 무엇인가요?

    - async는 future를 통해 나중에 값을 받을 수 있고, thread는 직접 처리해야 합니다. async가 thread의 고수준 API라고 볼 수 있습니다.

## ✅ async 사용법

1. std::async는 어떻게 사용하나요?

    - 

2. std::launch::async와 std::launch::deferred의 차이는 무엇인가요?

    - 

3. 기본 launch policy는 무엇인가요?

    - 

## ✅ future 동작

1. std::future는 어떤 역할을 하나요?

    - get()으로 블로킹되어 값을 async에게서 받게 되면 풀려납니다.

2. get() 함수는 무엇을 하나요?

    - asnyc로부터 전달되는 값을 받아옵니다.

3. get()을 여러 번 호출하면 어떻게 되나요?

    - async에서 값을 다시 전달하지 않고 있기 때문에 무한대기 상태에 빠집니다.

## ✅ 비동기 결과 받기

1. async로 실행한 함수의 반환값은 어떻게 받나요?

    - future로 받습니다.

2. 예외는 어떻게 전파되나요?


3. future가 유효하지 않으면 어떻게 되나요?


## ✅ promise와의 관계

1. std::promise란 무엇인가요?
2. promise와 future의 관계는 무엇인가요?
3. promise는 언제 사용하나요?

## ✅ shared_future

1. std::shared_future란 무엇인가요?
2. future와 shared_future의 차이는 무엇인가요?
3. shared_future는 언제 사용하나요?

## ✅ 성능 / 주의점

1. async가 항상 새 스레드를 생성하나요?
2. async 사용 시 주의해야 할 점은 무엇인가요?
3. async vs thread_pool의 차이는 무엇인가요?

## ✅ 요약 질문

1. async와 future를 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

### ✅ 기본 개념

1. 함수를 비동기로 실행하고 future를 반환하는 함수입니다.
2. 비동기 작업의 결과를 받는 객체입니다.
3. async는 결과를 받을 수 있고, thread는 직접 관리해야 합니다.

### ✅ async 사용법

4. `std::async(launch_policy, function, args...)` 형태로 사용합니다.
5. async는 새 스레드에서 실행, deferred는 지연 실행(나중에 get() 호출 시)입니다.
6. 구현에 따라 다르지만 보통 async | deferred 조합입니다.

### ✅ future 동작

7. 비동기 작업의 결과를 저장하고 접근할 수 있게 합니다.
8. 결과를 가져오고 future를 무효화합니다.
9. 한 번만 호출 가능하며, 두 번째 호출 시 예외가 발생합니다.

### ✅ 비동기 결과 받기

10. future의 get()으로 반환값을 받습니다.
11. get() 호출 시 예외가 다시 던져집니다.
12. 정의되지 않은 동작이 발생합니다.

### ✅ promise와의 관계

13. future에 값을 설정하는 객체입니다.
14. promise는 값 설정, future는 값 읽기를 담당합니다.
15. 직접 스레드를 만들고 결과를 전달할 때 사용합니다.

### ✅ shared_future

16. 여러 스레드가 공유할 수 있는 future입니다.
17. future는 한 번만 get() 가능, shared_future는 여러 번 가능합니다.
18. 여러 스레드가 같은 결과를 기다릴 때 사용합니다.

### ✅ 성능 / 주의점

19. 아니요, launch policy에 따라 다르고 스레드 풀을 사용할 수도 있습니다.
20. future를 반드시 받아야 하고, 소멸 시 대기하므로 주의가 필요합니다.
21. async는 간단하지만 제어가 제한적, thread_pool은 더 세밀한 제어가 가능합니다.

### ✅ 요약 질문

22. async와 future는 "비동기 작업 실행과 결과를 받는 간편한 메커니즘"입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: std::async란 무엇인가요?**
- **현재 답변**: "스레드처럼 비동기 실행을 만드는 클래스입니다."
- **피드백**:
  - ⚠️ **부정확**: std::async는 클래스가 아니라 함수입니다
  - ✅ **정확한 답변**: "함수를 비동기로 실행하고 future를 반환하는 함수입니다"
  - std::async는 함수 템플릿이며, 실행 정책에 따라 새 스레드에서 실행하거나 지연 실행할 수 있습니다

**질문 2: std::future란 무엇인가요?**
- **현재 답변**: "나중에 async로 보낸 함수가 종료되고나서 값을 받을 수 있는 객체입니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 정확한 표현이 있습니다
  - ✅ **정확한 답변**: "비동기 작업의 결과를 받는 객체입니다"
  - async뿐만 아니라 promise와 함께 사용할 때도 future를 사용합니다

**질문 3: async와 thread의 차이는 무엇인가요?**
- **현재 답변**: "async는 future를 통해 나중에 값을 받을 수 있고, thread는 직접 처리해야 합니다. async가 thread의 고수준 API라고 볼 수 있습니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "async는 결과를 받을 수 있고, thread는 직접 관리해야 합니다"
  - async는 future를 통해 결과와 예외를 받을 수 있으며, 스레드 생명주기 관리가 자동화됩니다

### ✅ async 사용법

**질문 1: std::async는 어떻게 사용하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 기본 질문입니다
  - ✅ **정확한 답변**: "`std::async(launch_policy, function, args...)` 형태로 사용합니다"
  - 예: `auto fut = std::async(std::launch::async, func, arg1, arg2);`
  - launch_policy는 생략 가능하며, 생략 시 구현에 따라 결정됩니다

**질문 2: std::launch::async와 std::launch::deferred의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 매우 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "async는 새 스레드에서 실행, deferred는 지연 실행(나중에 get() 호출 시)입니다"
  - std::launch::async는 즉시 새 스레드에서 실행하고, std::launch::deferred는 get() 호출 시 호출한 스레드에서 실행합니다

**질문 3: 기본 launch policy는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "구현에 따라 다르지만 보통 async | deferred 조합입니다"
  - 기본 정책은 `std::launch::async | std::launch::deferred`로, 구현이 선택할 수 있습니다
  - 따라서 기본 정책을 사용하면 비동기 실행이 보장되지 않습니다

### ✅ future 동작

**질문 1: std::future는 어떤 역할을 하나요?**
- **현재 답변**: "get()으로 블로킹되어 값을 async에게서 받게 되면 풀려납니다."
- **피드백**:
  - ⚠️ **부정확**: future의 역할에 대한 설명이 부족합니다
  - ✅ **정확한 답변**: "비동기 작업의 결과를 저장하고 접근할 수 있게 합니다"
  - get()은 결과를 가져오는 함수이며, future 자체는 비동기 작업의 결과를 나타내는 핸들입니다

**질문 2: get() 함수는 무엇을 하나요?**
- **현재 답변**: "asnyc로부터 전달되는 값을 받아옵니다."
- **피드백**:
  - ⚠️ **오타**: "asnyc" → "async"
  - ⚠️ **부정확**: get()의 추가 동작이 누락되었습니다
  - ✅ **정확한 답변**: "결과를 가져오고 future를 무효화합니다"
  - get()은 결과를 반환하고 future를 이동시켜 무효화합니다
  - 비동기 작업이 완료되지 않았다면 블로킹됩니다

**질문 3: get()을 여러 번 호출하면 어떻게 되나요?**
- **현재 답변**: "async에서 값을 다시 전달하지 않고 있기 때문에 무한대기 상태에 빠집니다."
- **피드백**:
  - ❌ **오개념**: get()을 두 번째 호출하면 무한 대기가 아니라 예외가 발생합니다
  - ✅ **정확한 답변**: "한 번만 호출 가능하며, 두 번째 호출 시 예외가 발생합니다"
  - future는 move-only 타입이며, get() 호출 후 future가 무효화되므로 두 번째 호출 시 std::future_error 예외가 발생합니다

### ✅ 비동기 결과 받기

**질문 1: async로 실행한 함수의 반환값은 어떻게 받나요?**
- **현재 답변**: "future로 받습니다."
- **피드백**:
  - 💡 **보완**: 답변이 맞지만 더 구체적으로 설명할 수 있습니다
  - ✅ **정확한 답변**: "future의 get()으로 반환값을 받습니다"
  - async는 future를 반환하고, future의 get()을 호출하여 실제 반환값을 받습니다

**질문 2: 예외는 어떻게 전파되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 중요한 질문입니다
  - ✅ **정확한 답변**: "get() 호출 시 예외가 다시 던져집니다"
  - async로 실행한 함수에서 예외가 발생하면, get() 호출 시 해당 예외가 다시 전파됩니다
  - 스레드 경계를 넘어 예외를 전파할 수 있는 메커니즘입니다

**질문 3: future가 유효하지 않으면 어떻게 되나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 질문입니다
  - ✅ **정확한 답변**: "정의되지 않은 동작이 발생합니다"
  - 유효하지 않은 future에 대해 get()을 호출하면 undefined behavior가 발생합니다
  - future가 이동되었거나 기본 생성된 경우 유효하지 않습니다

### ✅ promise와의 관계

**질문 1: std::promise란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "future에 값을 설정하는 객체입니다"
  - promise는 future와 쌍을 이루며, set_value()나 set_exception()으로 값을 설정합니다

**질문 2: promise와 future의 관계는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "promise는 값 설정, future는 값 읽기를 담당합니다"
  - promise::get_future()로 future를 얻고, promise에서 값을 설정하면 future에서 읽을 수 있습니다
  - 하나의 promise에 대응하는 하나의 future만 존재합니다

**질문 3: promise는 언제 사용하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 질문입니다
  - ✅ **정확한 답변**: "직접 스레드를 만들고 결과를 전달할 때 사용합니다"
  - std::thread를 직접 사용하면서 결과를 전달해야 할 때 promise/future를 사용합니다
  - async로는 표현하기 어려운 복잡한 스레드 제어가 필요할 때 사용합니다

### ✅ shared_future

**질문 1: std::shared_future란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "여러 스레드가 공유할 수 있는 future입니다"
  - future::share()로 shared_future를 만들 수 있으며, 복사 가능합니다

**질문 2: future와 shared_future의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "future는 한 번만 get() 가능, shared_future는 여러 번 가능합니다"
  - future는 move-only이고 get() 후 무효화되지만, shared_future는 복사 가능하고 여러 번 get()할 수 있습니다

**질문 3: shared_future는 언제 사용하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 질문입니다
  - ✅ **정확한 답변**: "여러 스레드가 같은 결과를 기다릴 때 사용합니다"
  - 여러 스레드가 동일한 비동기 작업의 결과를 모두 받아야 할 때 사용합니다
  - 예: 브로드캐스트 패턴, 여러 워커가 같은 설정을 읽어야 할 때

### ✅ 성능 / 주의점

**질문 1: async가 항상 새 스레드를 생성하나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 매우 자주 나오는 핵심 질문입니다
  - ✅ **정확한 답변**: "아니요, launch policy에 따라 다르고 스레드 풀을 사용할 수도 있습니다"
  - std::launch::deferred를 사용하면 새 스레드를 생성하지 않습니다
  - std::launch::async를 명시해도 구현에 따라 스레드 풀을 사용할 수 있습니다

**질문 2: async 사용 시 주의해야 할 점은 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 실무에서 매우 중요한 질문입니다
  - ✅ **정확한 답변**: "future를 반드시 받아야 하고, 소멸 시 대기하므로 주의가 필요합니다"
  - async의 반환값(future)을 받지 않으면 소멸자가 호출될 때 비동기 작업이 완료될 때까지 대기합니다
  - 기본 launch policy를 사용하면 비동기 실행이 보장되지 않으므로, 필요시 std::launch::async를 명시해야 합니다

**질문 3: async vs thread_pool의 차이는 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다
  - ✅ **정확한 답변**: "async는 간단하지만 제어가 제한적, thread_pool은 더 세밀한 제어가 가능합니다"
  - async는 간단하지만 스레드 수 제어가 불가능하고, thread_pool은 스레드 수와 동작을 명시적으로 제어할 수 있습니다
  - async는 구현에 따라 다를 수 있지만, thread_pool은 명시적으로 제어 가능합니다

### ✅ 요약 질문

**질문 1: async와 future를 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 요약 질문입니다
  - ✅ **정확한 답변**: "async와 future는 '비동기 작업 실행과 결과를 받는 간편한 메커니즘'입니다"
  - 함수를 비동기로 실행하고 결과를 future를 통해 받는 간편한 방법을 제공합니다

### 📊 전체 평가

**강점:**
- ✅ async와 thread의 기본적인 차이를 이해함 (future를 통한 결과 받기)
- ✅ async가 thread의 고수준 API라는 개념을 이해함
- ✅ future를 통해 값을 받는다는 기본 개념을 이해함

**개선 필요:**
- ❌ **오개념**: std::async를 클래스로 잘못 이해함 (함수임)
- ❌ **오개념**: get()을 여러 번 호출 시 무한 대기라고 잘못 이해함 (예외 발생)
- ❌ **답변 누락**: 대부분의 질문에 답변이 누락됨 (async 사용법, launch policy, 예외 전파, promise, shared_future, 성능/주의점 등)
- ⚠️ **부정확**: future의 역할 설명이 부족함
- ⚠️ **부정확**: get()의 동작 설명이 부족함 (future 무효화)
- ⚠️ **오타**: "asnyc" → "async"

**우선순위:**
1. **높음**: 
   - std::async가 함수라는 사실 (클래스가 아님)
   - get()을 여러 번 호출 시 예외 발생 (무한 대기 아님)
   - launch policy 이해 (async vs deferred)
   - async가 항상 새 스레드를 생성하는지 여부
   - async 사용 시 주의사항 (future를 반드시 받아야 함)
2. **중간**: 
   - promise와 future의 관계
   - shared_future의 개념과 사용 사례
   - 예외 전파 메커니즘
   - future의 역할과 get()의 정확한 동작
3. **낮음**: 
   - async vs thread_pool의 차이
   - future가 유효하지 않을 때의 동작

**특별 주의사항:**
- **std::async는 함수입니다**: 클래스가 아니라 함수 템플릿입니다. 면접에서 자주 나오는 질문입니다.
- **get()은 한 번만 호출 가능**: future는 move-only 타입이며, get() 호출 후 무효화됩니다. 두 번째 호출 시 예외가 발생합니다.
- **launch policy**: std::launch::async는 새 스레드에서 실행, std::launch::deferred는 지연 실행입니다. 기본 정책은 구현에 따라 다를 수 있어 비동기 실행이 보장되지 않습니다.
- **future를 반드시 받아야 함**: async의 반환값을 받지 않으면 소멸자가 호출될 때 비동기 작업이 완료될 때까지 대기합니다. 이는 데드락을 유발할 수 있습니다.
- **promise/future 패턴**: 직접 스레드를 만들고 결과를 전달할 때 사용하며, promise는 값 설정, future는 값 읽기를 담당합니다.
- **shared_future**: 여러 스레드가 같은 결과를 기다릴 때 사용하며, 복사 가능하고 여러 번 get()할 수 있습니다.

