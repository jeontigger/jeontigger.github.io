# 🧠 C++ std::mutex / std::lock_guard 사용법 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. std::mutex란 무엇인가요?

    - 동기화를 위한 클래스입니다.

2. std::lock_guard란 무엇인가요?

    - mutex를 RAII로 관리하는 클래스입니다.

3. mutex와 lock_guard의 역할 차이는 무엇인가요?

    - mutex는 critical section이 발생할 수 있는 영역을 상호배제하는 역할이고, lock_guard는 mutex의 unlock을 변수 생명주기에 연결하는 클래스입니다.

## ✅ 사용 방식

1. mutex는 어떻게 사용하나요?

    - mutex는 lock과 unlock으로 상호배제를 구현합니다.

2. lock_guard는 어떻게 사용하나요?

    - lock_guard는 mutex를 인자로 받아 lock을 진행합니다.

## ✅ RAII / 예외 안전성 (핵심)

1. lock_guard가 RAII를 어떻게 활용하나요?

    - 생성자에서 lock을 호출하고, 소멸자에서 unlock을 호출합니다.

2. lock_guard가 예외 안전한 이유는 무엇인가요?

    - lock_guard는 중간에 예외 발생으로 스택언와인딩이 발생해도 스택 객체가 소멸되는 것으로 소멸자가 호출되어 unlock을 호출할 수 있습니다.

## ✅ 수명 / 범위

1. lock_guard의 잠금 해제 시점은 언제인가요?

    - lock_guard의 소멸 시점입니다.

2. lock_guard의 스코프 설계가 중요한 이유는 무엇인가요?

    - lock_guard가 소멸해야 unlock이 호출되기 때문입니다.

## ✅ 비교 / 확장

1. lock_guard와 unique_lock의 차이는 무엇인가요?

    - lock_guard는 기본적인 RAII만 구현되어있습니다. unique_lock은 lock_guard에서 다른 함수들이 구현되어있기 때문에 더 많은 기능은가능하지만, 조금 무겁게 됩니다.

2. mutex를 직접 lock/unlock하는 것이 위험한 이유는 무엇인가요?

    - RAII를 사용하는 목적과 일치합니다.

## ✅ 성능 / 실무

1. lock_guard는 성능 오버헤드가 있나요?

    - 오버헤드가 존재합니다. 그러나 오버헤드보다는 안정성이 더 중요합니다.

2. 중첩 lock_guard 사용 시 주의할 점은 무엇인가요?

    - 점유대기를 하지 않도록 해서 데드락을 방지해야 합니다.

## ✅ 요약 질문

1. mutex와 lock_guard를 한 문장으로 요약해보세요.

    - mutex는 상호배제를 위한 클래스이고 lock_guard는 mutex를 RAII로 관리하는 클래스입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## ✅ 1줄 모범 답변

### ✅ 기본 개념

1. 상호 배제를 제공하는 기본적인 락 객체입니다.
2. mutex를 RAII 방식으로 관리하는 락 래퍼입니다.
3. mutex는 락 객체, lock_guard는 락 관리 도구입니다.

### ✅ 사용 방식

4. lock()으로 잠그고 unlock()으로 해제합니다.
5. 생성 시 잠그고 소멸 시 해제합니다.

### ✅ RAII / 예외 안전성 (핵심)

6. 생성자에서 lock, 소멸자에서 unlock을 수행합니다.
7. 스코프 종료 시 자동 해제되기 때문입니다.

8. lock_guard 객체가 파괴될 때입니다.
9. 임계 구역 범위를 명확히 하기 위해서입니다.

### ✅ 비교 / 확장

10. unique_lock은 잠금/해제를 제어할 수 있습니다.
11. unlock 누락이나 예외 발생 시 데드락 위험이 있습니다.

### ✅ 성능 / 실무

12. 사실상 없습니다.
13. 락 순서로 인한 데드락입니다.

14. mutex는 “락”, lock_guard는 “락의 수명 관리자”입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: std::mutex란 무엇인가요?**
- **현재 답변**: "동기화를 위한 클래스입니다."
- **피드백**:
  - ⚠️ **부정확**: "동기화"는 너무 일반적인 표현입니다
  - ✅ **정확한 답변**: "상호 배제(mutual exclusion)를 제공하는 기본적인 락 객체입니다"
  - mutex는 상호 배제라는 구체적인 동기화 메커니즘을 제공합니다

### ✅ 사용 방식

**질문 2: lock_guard는 어떻게 사용하나요?**
- **현재 답변**: "lock_guard는 mutex를 인자로 받아 lock을 진행합니다."
- **피드백**:
  - ⚠️ **부정확**: 소멸 시 자동 해제되는 핵심 기능이 누락되었습니다
  - ✅ **정확한 답변**: "생성 시 잠그고 소멸 시 해제합니다"
  - lock_guard의 핵심은 생성자에서 lock, 소멸자에서 unlock을 자동으로 수행하는 것입니다

### ✅ RAII / 예외 안전성 (핵심)

**질문 2: lock_guard가 예외 안전한 이유는 무엇인가요?**
- **현재 답변**: "lock_guard는 중간에 예외 발생으로 스택언와인딩이 발생해도 스택 객체가 소멸되는 것으로 소멸자가 호출되어 unlock을 호출할 수 있습니다."
- **피드백**:
  - ⚠️ **오타**: "스택언와인딩" → "스택 언와인딩(stack unwinding)"
  - 💡 **보완**: "스코프 종료 시 자동 해제되기 때문입니다"가 더 간결하고 정확한 표현입니다
  - 예외 발생 시 스택 언와인딩 과정에서 lock_guard의 소멸자가 호출되어 unlock이 보장됩니다

### ✅ 수명 / 범위

**질문 2: lock_guard의 스코프 설계가 중요한 이유는 무엇인가요?**
- **현재 답변**: "lock_guard가 소멸해야 unlock이 호출되기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 맞지만 핵심 이유가 누락되었습니다
  - 💡 **보완**: "임계 구역(critical section) 범위를 명확히 하기 위해서입니다"
  - 스코프를 통해 잠금이 필요한 영역을 명시적으로 표현할 수 있습니다

### ✅ 비교 / 확장

**질문 1: lock_guard와 unique_lock의 차이는 무엇인가요?**
- **현재 답변**: "lock_guard는 기본적인 RAII만 구현되어있습니다. unique_lock은 lock_guard에서 다른 함수들이 구현되어있기 때문에 더 많은 기능은가능하지만, 조금 무겁게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "lock_guard에서 다른 함수들이 구현되어있기 때문에"라는 표현이 부정확합니다
  - 💡 **보완**: "unique_lock은 잠금/해제를 제어할 수 있습니다"
  - unique_lock은 lock(), unlock(), try_lock() 등을 직접 호출할 수 있으며, 조건 변수와 함께 사용 가능합니다
  - lock_guard는 생성/소멸 시에만 잠금을 관리하는 단순한 구조입니다

**질문 2: mutex를 직접 lock/unlock하는 것이 위험한 이유는 무엇인가요?**
- **현재 답변**: "RAII를 사용하는 목적과 일치합니다."
- **피드백**:
  - ❌ **오개념**: 질문에 대한 직접적인 답변이 아닙니다
  - ✅ **정확한 답변**: "unlock 누락이나 예외 발생 시 데드락 위험이 있습니다"
  - 직접 lock/unlock을 사용하면 unlock을 깜빡하거나, 예외 발생 시 unlock이 호출되지 않아 데드락이 발생할 수 있습니다
  - RAII 패턴을 사용하면 이러한 문제를 자동으로 방지할 수 있습니다

### ✅ 성능 / 실무

**질문 1: lock_guard는 성능 오버헤드가 있나요?**
- **현재 답변**: "오버헤드가 존재합니다. 그러나 오버헤드보다는 안정성이 더 중요합니다."
- **피드백**:
  - ❌ **오개념**: lock_guard 자체는 사실상 오버헤드가 없습니다
  - ✅ **정확한 답변**: "사실상 없습니다"
  - lock_guard는 단순히 생성자/소멸자에서 mutex의 lock/unlock을 호출하는 래퍼일 뿐입니다
  - 오버헤드는 mutex 자체에서 발생하며, lock_guard는 추가적인 비용을 거의 들이지 않습니다
  - 안정성 측면에서 lock_guard 사용을 권장하는 것은 맞지만, 성능 오버헤드가 있다는 표현은 부정확합니다

**질문 2: 중첩 lock_guard 사용 시 주의할 점은 무엇인가요?**
- **현재 답변**: "점유대기를 하지 않도록 해서 데드락을 방지해야 합니다."
- **피드백**:
  - ⚠️ **부정확**: "점유대기"는 표준 용어가 아닙니다
  - ✅ **정확한 답변**: "락 순서로 인한 데드락입니다"
  - 여러 mutex를 사용할 때 항상 같은 순서로 잠금을 획득해야 합니다
  - 서로 다른 순서로 잠금을 획득하면 데드락이 발생할 수 있습니다

### 📊 전체 평가

**강점:**
- ✅ lock_guard의 RAII 개념을 정확히 이해함 (생성자에서 lock, 소멸자에서 unlock)
- ✅ lock_guard의 소멸 시점에 잠금이 해제된다는 것을 이해함
- ✅ mutex와 lock_guard의 기본 역할 차이를 이해함
- ✅ 요약 질문에 대한 답변이 정확함

**개선 필요:**
- ❌ **오개념**: lock_guard의 성능 오버헤드에 대한 잘못된 이해
- ❌ **오개념**: mutex 직접 lock/unlock의 위험성에 대한 답변이 부정확
- ⚠️ **부정확**: std::mutex의 정의가 너무 일반적 ("동기화" → "상호 배제")
- ⚠️ **부정확**: lock_guard 사용법 설명에 소멸 시 자동 해제 누락
- ⚠️ **부정확**: unique_lock과의 차이 설명이 부정확
- ⚠️ **부정확**: 중첩 lock 사용 시 주의사항 용어 오류 ("점유대기" → "락 순서")
- ⚠️ **오타**: "스택언와인딩" → "스택 언와인딩"

**우선순위:**
1. **높음**: 
   - lock_guard의 성능 오버헤드 오개념 (사실상 없음)
   - mutex 직접 lock/unlock의 위험성 (unlock 누락, 예외 시 데드락)
   - lock_guard 사용법에 소멸 시 자동 해제 추가
2. **중간**: 
   - std::mutex의 정확한 정의 (상호 배제)
   - unique_lock과의 차이점 보완
   - 중첩 lock 사용 시 락 순서 개념
3. **낮음**: 
   - 용어 정리 (스택 언와인딩, 점유대기)
   - 스코프 설계 이유 보완

**특별 주의사항:**
- **RAII 패턴**: lock_guard는 RAII 패턴의 대표적인 예시입니다. 생성자에서 자원 획득(lock), 소멸자에서 자원 해제(unlock)를 보장합니다.
- **예외 안전성**: lock_guard는 예외 발생 시에도 소멸자가 호출되어 unlock이 보장되므로 예외 안전합니다. 이는 면접에서 자주 나오는 질문입니다.
- **성능**: lock_guard 자체는 오버헤드가 거의 없으며, 단순히 mutex의 lock/unlock을 래핑하는 역할만 합니다. 실제 오버헤드는 mutex 자체에서 발생합니다.
- **데드락 방지**: 여러 mutex를 사용할 때는 항상 같은 순서로 잠금을 획득해야 합니다. 이는 데드락을 방지하는 핵심 원칙입니다.

