# 🧠 C++ 전방 선언(Forward Declaration) 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. 전방 선언(Forward Declaration)이란 무엇인가요?

    - 해당 심볼이 존재한다는 것을 상위에 명시하여 알리는 것입니다.
    
2. 전방 선언은 왜 필요한가요?

    - 구현부를 작성하지 않아도 해당 구현부가 어딘가에 존재하다는 것을 알림으로써 순환 참조에도 대응할 수 있고, 바이너리 파일의 크기를 줄일 수 있습니다.

## ✅ 선언 vs 정의

1. 전방 선언과 완전한 정의의 차이는 무엇인가요?

    - 전방 선언은 해당 심볼이 존재한 다는 것만 알리는 것이고, 완전한 정의는 해당 심볼의 정의를 모두 포함하는 선언입니다.

2. 전방 선언만으로 무엇을 할 수 있나요?

    - 예를들어 class CMyClass 등으로 전방 선언 한다면 컴파일타임에 해당 CMyClass가 존재한다는 것을 바탕으로 컴파일을 진행할 수 있습니다.

## ✅ 사용 사례

1. 전방 선언의 대표적인 사용 사례는 무엇인가요?

    - class COtherClass 등을 전방선언 하면 class CMyClass에서는 COtherClass에 대한 포인터 멤버 변수를 선언할 수 있습니다. 해당 타입이 존재한다는 것을 전방선언했고, 레지스터의 크기만큼으로 할당되는 포인터이기 때문에 가능합니다.

2. 포인터나 참조를 사용할 때 전방 선언이 가능한 이유는 무엇인가요?

    - 해당 클래스를 객체화 할 때 모든 멤버 변수의 크기를 계산하여 할당량을 계산합니다. 이때 전방선언만으로는 해당 클래스의 크기를 계산이 불가능합니다. 따라서 포인터나 참조처럼 정해진 메모리 크기를 사용하는 경우에는 전방선언이 가능합니다.

## ✅ 컴파일 시간 개선

1. 전방 선언이 컴파일 시간을 개선하는 이유는 무엇인가요?

    - 해당 클래스의 완전한 정의를 알지 못해도 컴파일을 진행할 수 있기 때문입니다. 전방선언을 하지 않는다면 파일마다 완전한 구현을 파악하는데 컴파일 타임이 필요하기 때문에 이 부분을 절약할 수 있을 것이라고 생각됩니다.

2. 헤더 파일 의존성을 줄이는 것이 왜 중요한가요?

    - 의존성이 늘어난다면 헤더파일에 다른 헤더를 여러개 가져와야하고, 해당 헤더를 선언하는 파일마다, 같은 작업을 수행해야하기 때문에 최대한 헤더 파일의 의존성을 줄이고, 필요한 헤더만 불러올 수 있도록 설계하는 것이 중요합니다. 바이너리의 크기도 비대해지고, 순환 의존이 발생할 수도 있습니다.

## ✅ 제약 사항

1. 전방 선언만으로는 할 수 없는 것은 무엇인가요?

    - 해당 클래스의 크기 계산이 불가능합니다.

2. 언제 전방 선언 대신 완전한 정의가 필요한가요?

    - 해당 클래스 타입의 멤버 변수를 갖는다면 완전한 정의가 필요합니다.

## ✅ 실무 / 설계

1. 헤더 파일 설계 시 전방 선언을 어떻게 활용하나요?

    - 사용자 클래스 타입 멤버 변수들에 대해서 값으로 갖고있는 것이 아니라 포인터나 참조로 유지하며 전방선언을 사용합니다.

2. 순환 의존성 문제를 전방 선언으로 해결할 수 있나요?

    - 네 가능합니다.

## ✅ 주의점

1. 전방 선언 사용 시 주의해야 할 점은 무엇인가요?

    - 반드시 포인터나 참조로 활용해야 합니다. 값 타입으로는 전방 선언을 사용할 수 없습니다.

2. 전방 선언을 남용하면 어떤 문제가 발생하나요?

    - 모르겠습니다.

## ✅ 요약 질문

1. 전방 선언을 한 문장으로 요약해보세요.

    - 완전한 정의를 최대한 배제하기 위한 방법입니다. 

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. 타입의 존재만 알리고 정의는 나중에 제공하는 선언입니다.
2. 헤더 파일 의존성을 줄이고 컴파일 시간을 단축하기 위해서입니다.

### ✅ 선언 vs 정의

3. 전방 선언은 타입 이름만, 정의는 전체 구조를 포함합니다.
4. 포인터/참조 선언, 함수 선언, 타입 크기 불필요한 경우에 사용할 수 있습니다.

### ✅ 사용 사례

5. 헤더 파일에서 포인터/참조만 사용할 때, 순환 의존성 해결입니다.
6. 포인터/참조는 타입 크기를 알 필요가 없기 때문입니다.

### ✅ 컴파일 시간 개선

7. 불필요한 헤더 포함을 줄여 전처리와 컴파일 시간이 단축됩니다.
8. 헤더 변경 시 재컴파일되는 파일 수가 줄어들기 때문입니다.

### ✅ 제약 사항

9. 타입 크기 사용, 멤버 접근, 상속, 템플릿 인스턴스화는 불가능합니다.
10. 타입 크기나 멤버에 접근해야 할 때입니다.

### ✅ 실무 / 설계

11. 헤더에는 전방 선언, 구현 파일에 필요한 헤더를 포함합니다.
12. 네, 순환 의존성을 끊는 데 유용합니다.

### ✅ 주의점

13. 정의가 실제로 제공되어야 하고, 순서가 중요할 수 있습니다.
14. 과도한 전방 선언은 코드 가독성을 떨어뜨릴 수 있습니다.

### ✅ 요약 질문

15. 전방 선언은 "타입 정의 없이 타입 존재만 알리는 선언"입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 전방 선언(Forward Declaration)이란 무엇인가요?**
- **현재 답변**: "해당 심볼이 존재한다는 것을 상위에 명시하여 알리는 것입니다."
- **피드백**:
  - ⚠️ **부정확**: "상위에 명시"라는 표현이 모호합니다. "타입의 존재만 알리고 정의는 나중에 제공"이 더 정확합니다.
  - ✅ **정확한 답변**: "타입의 존재만 알리고 정의는 나중에 제공하는 선언입니다."
  - 💡 **보완**: 전방 선언은 타입의 이름만 선언하고, 실제 정의는 나중에 제공하는 선언입니다.

**질문 2: 전방 선언은 왜 필요한가요?**
- **현재 답변**: "구현부를 작성하지 않아도 해당 구현부가 어딘가에 존재하다는 것을 알림으로써 순환 참조에도 대응할 수 있고, 바이너리 파일의 크기를 줄일 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "바이너리 파일의 크기를 줄일 수 있다"는 설명이 부정확합니다. 전방 선언은 컴파일 시간 단축과 헤더 의존성 감소에 주로 기여합니다.
  - ✅ **정확한 답변**: "헤더 파일 의존성을 줄이고 컴파일 시간을 단축하기 위해서입니다."
  - 💡 **보완**: 전방 선언은 헤더 파일 의존성을 줄여 불필요한 헤더 포함을 방지하고, 컴파일 시간을 단축합니다. 순환 의존성 해결에도 도움이 됩니다.

### ✅ 선언 vs 정의

**질문 1: 전방 선언과 완전한 정의의 차이는 무엇인가요?**
- **현재 답변**: "전방 선언은 해당 심볼이 존재한 다는 것만 알리는 것이고, 완전한 정의는 해당 심볼의 정의를 모두 포함하는 선언입니다."
- **피드백**:
  - ⚠️ **부정확**: "심볼"보다는 "타입"이 더 정확한 표현입니다. 또한 "정의를 모두 포함하는 선언"이라는 표현이 모호합니다.
  - ✅ **정확한 답변**: "전방 선언은 타입 이름만, 정의는 전체 구조를 포함합니다."
  - 💡 **보완**: 전방 선언은 타입의 이름만 선언하고, 완전한 정의는 타입의 전체 구조(멤버 변수, 멤버 함수 등)를 포함합니다.

**질문 2: 전방 선언만으로 무엇을 할 수 있나요?**
- **현재 답변**: "예를들어 class CMyClass 등으로 전방 선언 한다면 컴파일타임에 해당 CMyClass가 존재한다는 것을 바탕으로 컴파일을 진행할 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: 너무 모호한 설명입니다. 구체적으로 무엇을 할 수 있는지 명시해야 합니다.
  - ✅ **정확한 답변**: "포인터/참조 선언, 함수 선언, 타입 크기 불필요한 경우에 사용할 수 있습니다."
  - 💡 **보완**: 전방 선언만으로는 포인터나 참조를 선언하거나, 함수의 매개변수/반환 타입으로 사용할 수 있습니다. 타입의 크기를 알 필요가 없는 경우에 사용 가능합니다.

### ✅ 사용 사례

**질문 1: 전방 선언의 대표적인 사용 사례는 무엇인가요?**
- **현재 답변**: "class COtherClass 등을 전방선언 하면 class CMyClass에서는 COtherClass에 대한 포인터 멤버 변수를 선언할 수 있습니다. 해당 타입이 존재한다는 것을 전방선언했고, 레지스터의 크기만큼으로 할당되는 포인터이기 때문에 가능합니다."
- **피드백**:
  - ⚠️ **부정확**: "레지스터의 크기만큼"이라는 표현이 부정확합니다. 포인터는 고정 크기(보통 4바이트 또는 8바이트)를 가지지만, 레지스터와는 직접적인 관련이 없습니다.
  - ✅ **정확한 답변**: "헤더 파일에서 포인터/참조만 사용할 때, 순환 의존성 해결입니다."
  - 💡 **보완**: 전방 선언은 헤더 파일에서 다른 클래스의 포인터나 참조만 사용할 때, 그리고 순환 의존성을 해결할 때 사용됩니다. 포인터는 고정 크기를 가지므로 타입의 완전한 정의가 필요 없습니다.

**질문 2: 포인터나 참조를 사용할 때 전방 선언이 가능한 이유는 무엇인가요?**
- **현재 답변**: "해당 클래스를 객체화 할 때 모든 멤버 변수의 크기를 계산하여 할당량을 계산합니다. 이때 전방선언만으로는 해당 클래스의 크기를 계산이 불가능합니다. 따라서 포인터나 참조처럼 정해진 메모리 크기를 사용하는 경우에는 전방선언이 가능합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "포인터/참조는 타입 크기를 알 필요가 없기 때문입니다"라고 간결하게 표현할 수 있습니다.

### ✅ 컴파일 시간 개선

**질문 1: 전방 선언이 컴파일 시간을 개선하는 이유는 무엇인가요?**
- **현재 답변**: "해당 클래스의 완전한 정의를 알지 못해도 컴파일을 진행할 수 있기 때문입니다. 전방선언을 하지 않는다면 파일마다 완전한 구현을 파악하는데 컴파일 타임이 필요하기 때문에 이 부분을 절약할 수 있을 것이라고 생각됩니다."
- **피드백**:
  - ⚠️ **부정확**: 핵심인 "불필요한 헤더 포함을 줄인다"는 점이 누락되었습니다.
  - ✅ **정확한 답변**: "불필요한 헤더 포함을 줄여 전처리와 컴파일 시간이 단축됩니다."
  - 💡 **보완**: 전방 선언을 사용하면 헤더 파일을 include하지 않아도 되므로, 전처리 단계에서 헤더 파일을 읽고 확장하는 시간이 줄어듭니다. 또한 헤더 파일이 변경되어도 전방 선언만 사용하는 파일은 재컴파일할 필요가 없습니다.

**질문 2: 헤더 파일 의존성을 줄이는 것이 왜 중요한가요?**
- **현재 답변**: "의존성이 늘어난다면 헤더파일에 다른 헤더를 여러개 가져와야하고, 해당 헤더를 선언하는 파일마다, 같은 작업을 수행해야하기 때문에 최대한 헤더 파일의 의존성을 줄이고, 필요한 헤더만 불러올 수 있도록 설계하는 것이 중요합니다. 바이너리의 크기도 비대해지고, 순환 의존이 발생할 수도 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "바이너리의 크기도 비대해진다"는 설명이 부정확합니다. 헤더 의존성은 주로 컴파일 시간에 영향을 줍니다.
  - ✅ **정확한 답변**: "헤더 변경 시 재컴파일되는 파일 수가 줄어들기 때문입니다."
  - 💡 **보완**: 헤더 파일 의존성을 줄이면 헤더가 변경되었을 때 재컴파일해야 하는 파일 수가 줄어듭니다. 이는 빌드 시간을 크게 단축시킵니다. 순환 의존성 문제도 해결할 수 있습니다.

### ✅ 제약 사항

**질문 1: 전방 선언만으로는 할 수 없는 것은 무엇인가요?**
- **현재 답변**: "해당 클래스의 크기 계산이 불가능합니다."
- **피드백**:
  - ⚠️ **부정확**: 크기 계산만 언급했지만, 멤버 접근, 상속, 템플릿 인스턴스화 등도 불가능합니다.
  - ✅ **정확한 답변**: "타입 크기 사용, 멤버 접근, 상속, 템플릿 인스턴스화는 불가능합니다."
  - 💡 **보완**: 전방 선언만으로는 타입의 크기를 알 수 없고, 멤버 변수나 멤버 함수에 접근할 수 없으며, 상속이나 템플릿 인스턴스화도 불가능합니다.

**질문 2: 언제 전방 선언 대신 완전한 정의가 필요한가요?**
- **현재 답변**: "해당 클래스 타입의 멤버 변수를 갖는다면 완전한 정의가 필요합니다."
- **피드백**:
  - ⚠️ **부정확**: "멤버 변수를 갖는다"는 표현이 모호합니다. "값 타입으로 멤버 변수를 선언한다"가 정확합니다.
  - ✅ **정확한 답변**: "타입 크기나 멤버에 접근해야 할 때입니다."
  - 💡 **보완**: 값 타입으로 멤버 변수를 선언하거나, 멤버에 접근하거나, 타입의 크기를 알아야 할 때는 완전한 정의가 필요합니다.

### ✅ 실무 / 설계

**질문 1: 헤더 파일 설계 시 전방 선언을 어떻게 활용하나요?**
- **현재 답변**: "사용자 클래스 타입 멤버 변수들에 대해서 값으로 갖고있는 것이 아니라 포인터나 참조로 유지하며 전방선언을 사용합니다."
- **피드백**:
  - ⚠️ **부정확**: "사용자 클래스 타입"이라는 표현이 모호합니다. 또한 구현 파일에 헤더를 포함하는 것도 언급해야 합니다.
  - ✅ **정확한 답변**: "헤더에는 전방 선언, 구현 파일에 필요한 헤더를 포함합니다."
  - 💡 **보완**: 헤더 파일에서는 다른 클래스를 포인터나 참조로만 사용할 때 전방 선언을 사용하고, 실제 구현 파일(.cpp)에서 필요한 헤더를 include합니다.

**질문 2: 순환 의존성 문제를 전방 선언으로 해결할 수 있나요?**
- **현재 답변**: "네 가능합니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "순환 의존성을 끊는 데 유용합니다"라고 표현하면 더 명확합니다.

### ✅ 주의점

**질문 1: 전방 선언 사용 시 주의해야 할 점은 무엇인가요?**
- **현재 답변**: "반드시 포인터나 참조로 활용해야 합니다. 값 타입으로는 전방 선언을 사용할 수 없습니다."
- **피드백**:
  - ⚠️ **부정확**: 핵심 주의사항인 "정의가 실제로 제공되어야 한다"는 점이 누락되었습니다.
  - ✅ **정확한 답변**: "정의가 실제로 제공되어야 하고, 순서가 중요할 수 있습니다."
  - 💡 **보완**: 전방 선언을 사용할 때는 실제 정의가 어딘가에 제공되어야 합니다. 또한 전방 선언의 순서가 중요할 수 있습니다(특히 템플릿이나 복잡한 타입의 경우).

**질문 2: 전방 선언을 남용하면 어떤 문제가 발생하나요?**
- **현재 답변**: "모르겠습니다."
- **피드백**:
  - ❌ **답변 필요**: 실무에서 중요한 주의사항입니다.
  - ✅ **정확한 답변**: "과도한 전방 선언은 코드 가독성을 떨어뜨릴 수 있습니다."
  - 💡 **보완**: 전방 선언을 과도하게 사용하면 어떤 타입이 실제로 사용되는지 파악하기 어려워 코드 가독성이 떨어질 수 있습니다. 적절한 균형이 필요합니다.

### ✅ 요약 질문

**질문 1: 전방 선언을 한 문장으로 요약해보세요.**
- **현재 답변**: "완전한 정의를 최대한 배제하기 위한 방법입니다."
- **피드백**:
  - ⚠️ **부정확**: "배제"보다는 "타입 정의 없이 타입 존재만 알리는"이 더 정확합니다.
  - ✅ **정확한 답변**: "전방 선언은 '타입 정의 없이 타입 존재만 알리는 선언'입니다."
  - 💡 **보완**: 전방 선언은 타입의 완전한 정의 없이 타입의 존재만 선언하는 것입니다. 이를 통해 헤더 의존성을 줄이고 컴파일 시간을 단축할 수 있습니다.

### 📊 전체 평가

**강점:**
- 전방 선언의 기본 개념을 이해하고 있습니다.
- 포인터/참조에서 전방 선언이 가능한 이유를 이해하고 있습니다.
- 순환 의존성 해결에 도움이 된다는 것을 알고 있습니다.

**개선 필요:**
- ❌ 전방 선언 남용 시 문제 답변 누락
- ⚠️ 전방 선언 정의 설명 모호 ("상위에 명시")
- ⚠️ 전방 선언 필요성 설명 부정확 ("바이너리 크기 감소")
- ⚠️ 전방 선언만으로 할 수 있는 것 설명 모호
- ⚠️ 사용 사례 설명 부정확 ("레지스터 크기")
- ⚠️ 컴파일 시간 개선 이유 설명 부족 (불필요한 헤더 포함 감소)
- ⚠️ 헤더 의존성 중요성 설명 부정확 ("바이너리 크기")
- ⚠️ 전방 선언 제약 사항 설명 부족 (멤버 접근, 상속 등)
- ⚠️ 헤더 설계 활용 설명 모호
- ⚠️ 전방 선언 주의사항 설명 부족 (정의 제공 필요성)
- ⚠️ 요약 질문 표현 부정확

**우선순위:**
1. **높음**: 전방 선언 남용 시 문제 답변 작성
2. **높음**: 전방 선언 정의 명확화
3. **높음**: 전방 선언 필요성 설명 수정 (컴파일 시간 단축)
4. **중간**: 전방 선언만으로 할 수 있는 것 구체화
5. **중간**: 사용 사례 설명 수정 (포인터 크기)
6. **중간**: 전방 선언 제약 사항 보완
7. **낮음**: 표현 정확성 개선

**특별 주의사항:**
- 전방 선언은 "타입 정의 없이 타입 존재만 알리는 선언"입니다. 헤더 의존성을 줄이고 컴파일 시간을 단축하는 것이 주요 목적입니다.
- 포인터나 참조는 고정 크기를 가지므로 타입의 완전한 정의 없이도 선언할 수 있습니다. 값 타입은 타입 크기를 알아야 하므로 전방 선언만으로는 불가능합니다.
- 전방 선언을 사용할 때는 실제 정의가 어딘가에 제공되어야 합니다. 헤더에는 전방 선언, 구현 파일에는 필요한 헤더를 포함하는 것이 일반적인 패턴입니다.
- 전방 선언을 과도하게 사용하면 코드 가독성이 떨어질 수 있으므로 적절한 균형이 필요합니다.
