# 🧠 C++ ODR(One Definition Rule) 설명 가능 면접 질문 리스트

## ✅ 기본 개념

1. ODR(One Definition Rule)이란 무엇인가요?

    - 선언은 한 번만 해야한다는 규칙입니다.

2. ODR은 왜 필요한 규칙인가요?

    - 컴파일러가 어떤 주소로 연결지어야 할 지 모호해지기 때문입니다.

## ✅ 선언 vs 정의

1. 선언(declaration)과 정의(definition)의 차이는 무엇인가요?

    - 선언은 함수 시그니처만 명시하는 것이고, 정의는 해당 함수 시그니처가 호출될 때 어떻게 동작하는지에 대한 구현부 입니다.

2. 헤더 파일에는 무엇을 넣어야 하나요?

    - 헤더 파일에는 선언부만 넣어야 합니다.

## ✅ 위반 사례 (핵심)

1. ODR 위반이 발생하는 대표적인 경우는 무엇인가요?

    - 헤더에 함수 정의를 넣을 경우에 발생합니다.

2. 헤더에 함수 정의를 넣으면 언제 문제가 되나요?

    - 컴파일타임에 함수 선언부와 구현부에 대한 심볼 결정을 내릴 수 없습니다.

3. 전역 변수 정의로 인한 ODR 위반은 언제 발생하나요?

    - 링킹타임에 ?

## ✅ inline / template / constexpr

1. inline 함수는 왜 ODR 위반을 피할 수 있나요?

    - 특수하게 취급하여 ODR 위반을 피합니다. 짧고 간단한 함수들을 호출부에 그대로 인라이닝 함으로써 컴파일 후에는 선언부를 제거합니다.

2. 템플릿은 왜 ODR 위반 문제가 적은가요?

    - 템플릿 또한 특수하게 취급합니다. 템플릿은 구현부가 헤더에 있어야만 한다는 특징이 존재하기 때문에 ODR을 위반할 수 밖에 없지만 템플릿이라는 시스템을 사용하기 위해 ODR에서 예외적으로 취급합니다.

3. constexpr 변수는 ODR과 어떤 관계가 있나요?

    - 모르겠습니다.

## ✅ 링크 단계 관점

1. ODR 위반은 언제 발견되나요?

    - 링크 단계에서 발생합니다.

2. 링크 에러와 ODR 위반의 관계는 무엇인가요?

    - 함수의 선언부와 구현부가 다중으로 생성되었을 때 어떤것끼리 매칭해야할 지 모호할 때 발생합니다.

## ✅ 설계 / 예방

1. ODR 위반을 방지하는 기본 원칙은 무엇인가요?

    - 헤더파일에는 선언부만 기입하고, #pragma once등의 전처리를 합니다.

2. ODR을 의식한 헤더 설계의 핵심은 무엇인가요?

    - 구현부가 없는 API만 추려서 볼 수 있습니다. 

## ✅ 요약 질문

1. ODR을 한 문장으로 요약해보세요.

    - 하나의 함수 심볼은 한 번만 정의해야한다는 규칙입니다. 이를 위배할경우 링킹과정에서 문제가 발생합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 기본 개념

1. 같은 엔티티는 프로그램 전체에서 정확히 한 번만 정의되어야 한다는 규칙입니다.
2. 중복 정의로 인한 링크 에러와 정의 불일치를 방지하기 위해서입니다.

### ✅ 선언 vs 정의

3. 선언은 존재를 알리고, 정의는 실제 구현을 제공합니다.
4. 선언만 넣고 정의는 .cpp 파일에 둡니다.

### ✅ 위반 사례 (핵심)

5. 헤더에 함수 정의, 전역 변수 정의, 클래스 멤버 함수 정의를 넣는 경우입니다.
6. 여러 .cpp 파일에서 포함되면 중복 정의가 발생합니다.
7. 헤더에 전역 변수를 정의하고 여러 파일에서 포함할 때입니다.

### ✅ inline / template / constexpr

8. inline 함수는 여러 번 정의되어도 동일해야 하며 링커가 하나로 합칩니다.
9. 템플릿은 인스턴스화 시점에 정의가 필요하므로 ODR 예외입니다.
10. constexpr 변수는 헤더에 정의 가능하며 내부 링크를 가질 수 있습니다.

### ✅ 링크 단계 관점

11. 링크 단계에서 중복 정의나 정의 불일치로 발견됩니다.
12. ODR 위반은 링크 에러(중복 정의)나 정의되지 않은 동작을 유발합니다.

### ✅ 설계 / 예방

13. 헤더에는 선언만, 정의는 .cpp에 두는 것입니다.
14. 헤더에는 inline/template/constexpr만 정의하고 나머지는 선언만 둡니다.

### ✅ 요약 질문

15. ODR은 "같은 것은 한 번만 정의하라"는 C++ 규칙입니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: ODR(One Definition Rule)이란 무엇인가요?**
- **현재 답변**: "선언은 한 번만 해야한다는 규칙입니다."
- **피드백**:
  - ❌ **오개념**: ODR은 "선언"이 아니라 "정의"에 대한 규칙입니다. 선언은 여러 번 할 수 있지만, 정의는 한 번만 해야 합니다.
  - ✅ **정확한 답변**: "같은 엔티티는 프로그램 전체에서 정확히 한 번만 정의되어야 한다는 규칙입니다."
  - 💡 **보완**: ODR은 함수, 변수, 클래스 등의 정의가 프로그램 전체에서 정확히 한 번만 존재해야 한다는 규칙입니다. 선언은 여러 번 가능하지만, 정의는 한 번만 가능합니다.

**질문 2: ODR은 왜 필요한 규칙인가요?**
- **현재 답변**: "컴파일러가 어떤 주소로 연결지어야 할 지 모호해지기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: "컴파일러"가 아니라 "링커"가 주소를 연결합니다. 또한 정의 불일치 문제도 언급해야 합니다.
  - ✅ **정확한 답변**: "중복 정의로 인한 링크 에러와 정의 불일치를 방지하기 위해서입니다."
  - 💡 **보완**: ODR은 중복 정의로 인한 링크 에러를 방지하고, 같은 엔티티가 서로 다른 정의를 가지는 것을 방지합니다.

### ✅ 선언 vs 정의

**질문 1: 선언(declaration)과 정의(definition)의 차이는 무엇인가요?**
- **현재 답변**: "선언은 함수 시그니처만 명시하는 것이고, 정의는 해당 함수 시그니처가 호출될 때 어떻게 동작하는지에 대한 구현부 입니다."
- **피드백**:
  - ⚠️ **부정확**: 함수에만 국한된 설명입니다. 변수, 클래스 등에도 적용되는 일반적인 설명이 필요합니다.
  - ✅ **정확한 답변**: "선언은 존재를 알리고, 정의는 실제 구현을 제공합니다."
  - 💡 **보완**: 선언은 이름과 타입을 알리는 것이고, 정의는 실제 메모리 할당이나 구현을 제공하는 것입니다. 함수뿐만 아니라 변수, 클래스 등에도 적용됩니다.

**질문 2: 헤더 파일에는 무엇을 넣어야 하나요?**
- **현재 답변**: "헤더 파일에는 선언부만 넣어야 합니다."
- **피드백**:
  - ⚠️ **부정확**: 일반적으로 맞지만, inline 함수, 템플릿, constexpr 변수 등은 예외입니다.
  - ✅ **정확한 답변**: "선언만 넣고 정의는 .cpp 파일에 둡니다."
  - 💡 **보완**: 헤더에는 일반적으로 선언만 넣지만, inline 함수, 템플릿, constexpr 변수 등은 정의를 넣을 수 있습니다. 나머지는 .cpp 파일에 정의를 둡니다.

### ✅ 위반 사례 (핵심)

**질문 1: ODR 위반이 발생하는 대표적인 경우는 무엇인가요?**
- **현재 답변**: "헤더에 함수 정의를 넣을 경우에 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: 함수 정의만 언급했지만, 전역 변수 정의, 클래스 멤버 함수 정의도 포함해야 합니다.
  - ✅ **정확한 답변**: "헤더에 함수 정의, 전역 변수 정의, 클래스 멤버 함수 정의를 넣는 경우입니다."
  - 💡 **보완**: 헤더에 일반 함수 정의, 전역 변수 정의, 클래스 멤버 함수 정의를 넣고 여러 .cpp 파일에서 include하면 ODR 위반이 발생합니다.

**질문 2: 헤더에 함수 정의를 넣으면 언제 문제가 되나요?**
- **현재 답변**: "컴파일타임에 함수 선언부와 구현부에 대한 심볼 결정을 내릴 수 없습니다."
- **피드백**:
  - ❌ **오개념**: 컴파일 타임이 아니라 링크 타임에 문제가 발생합니다. 각 .cpp 파일은 정상적으로 컴파일되지만, 링크 시 중복 정의 에러가 발생합니다.
  - ✅ **정확한 답변**: "여러 .cpp 파일에서 포함되면 중복 정의가 발생합니다."
  - 💡 **보완**: 헤더에 함수 정의를 넣으면, 여러 .cpp 파일에서 include할 때 각 오브젝트 파일에 같은 함수 정의가 포함됩니다. 링크 단계에서 중복 정의 에러가 발생합니다.

**질문 3: 전역 변수 정의로 인한 ODR 위반은 언제 발생하나요?**
- **현재 답변**: "링킹타임에 ?"
- **피드백**:
  - ❌ **답변 필요**: 답변이 미완성입니다.
  - ✅ **정확한 답변**: "헤더에 전역 변수를 정의하고 여러 파일에서 포함할 때입니다."
  - 💡 **보완**: 헤더에 전역 변수를 정의하고 여러 .cpp 파일에서 include하면, 각 오브젝트 파일에 같은 전역 변수 정의가 포함되어 링크 단계에서 중복 정의 에러가 발생합니다.

### ✅ inline / template / constexpr

**질문 1: inline 함수는 왜 ODR 위반을 피할 수 있나요?**
- **현재 답변**: "특수하게 취급하여 ODR 위반을 피합니다. 짧고 간단한 함수들을 호출부에 그대로 인라이닝 함으로써 컴파일 후에는 선언부를 제거합니다."
- **피드백**:
  - ❌ **오개념**: "선언부를 제거"라는 설명이 잘못되었습니다. inline 함수는 여러 번 정의되어도 동일해야 하며, 링커가 하나로 합칩니다.
  - ✅ **정확한 답변**: "inline 함수는 여러 번 정의되어도 동일해야 하며 링커가 하나로 합칩니다."
  - 💡 **보완**: inline 함수는 ODR의 예외입니다. 여러 번 정의되어도 모든 정의가 동일하면 링커가 하나로 합칩니다. 인라인화는 컴파일러 최적화이며, ODR 예외와는 별개입니다.

**질문 2: 템플릿은 왜 ODR 위반 문제가 적은가요?**
- **현재 답변**: "템플릿 또한 특수하게 취급합니다. 템플릿은 구현부가 헤더에 있어야만 한다는 특징이 존재하기 때문에 ODR을 위반할 수 밖에 없지만 템플릿이라는 시스템을 사용하기 위해 ODR에서 예외적으로 취급합니다."
- **피드백**:
  - ⚠️ **부정확**: "ODR 위반 문제가 적다"는 표현이 부정확합니다. 템플릿은 ODR의 예외입니다.
  - ✅ **정확한 답변**: "템플릿은 인스턴스화 시점에 정의가 필요하므로 ODR 예외입니다."
  - 💡 **보완**: 템플릿은 인스턴스화 시점에 정의가 필요하므로 헤더에 정의를 넣어야 합니다. 템플릿 인스턴스는 각 번역 단위에서 생성되지만, 같은 인스턴스는 하나로 합쳐집니다.

**질문 3: constexpr 변수는 ODR과 어떤 관계가 있나요?**
- **현재 답변**: "모르겠습니다."
- **피드백**:
  - ❌ **답변 필요**: 면접에서 나올 수 있는 질문입니다.
  - ✅ **정확한 답변**: "constexpr 변수는 헤더에 정의 가능하며 내부 링크를 가질 수 있습니다."
  - 💡 **보완**: constexpr 변수는 컴파일 타임 상수이므로 헤더에 정의해도 문제가 없습니다. 내부 링크를 가지므로 각 번역 단위에서 별도로 정의되어도 ODR 위반이 아닙니다.

### ✅ 링크 단계 관점

**질문 1: ODR 위반은 언제 발견되나요?**
- **현재 답변**: "링크 단계에서 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "발생"보다는 "발견"이 정확합니다. 또한 정의 불일치도 언급해야 합니다.
  - ✅ **정확한 답변**: "링크 단계에서 중복 정의나 정의 불일치로 발견됩니다."
  - 💡 **보완**: ODR 위반은 링크 단계에서 중복 정의 에러로 발견되거나, 정의 불일치로 인한 정의되지 않은 동작으로 나타날 수 있습니다.

**질문 2: 링크 에러와 ODR 위반의 관계는 무엇인가요?**
- **현재 답변**: "함수의 선언부와 구현부가 다중으로 생성되었을 때 어떤것끼리 매칭해야할 지 모호할 때 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "선언부와 구현부"라는 표현이 부정확합니다. "정의가 다중으로 생성"이 정확합니다. 또한 정의되지 않은 동작도 언급해야 합니다.
  - ✅ **정확한 답변**: "ODR 위반은 링크 에러(중복 정의)나 정의되지 않은 동작을 유발합니다."
  - 💡 **보완**: ODR 위반은 링크 단계에서 중복 정의 에러를 발생시키거나, 같은 심볼이 서로 다른 정의를 가지는 경우 정의되지 않은 동작을 유발할 수 있습니다.

### ✅ 설계 / 예방

**질문 1: ODR 위반을 방지하는 기본 원칙은 무엇인가요?**
- **현재 답변**: "헤더파일에는 선언부만 기입하고, #pragma once등의 전처리를 합니다."
- **피드백**:
  - ⚠️ **부정확**: #pragma once는 중복 include를 방지하는 것이지, ODR 위반을 직접적으로 방지하는 것은 아닙니다. 헤더 가드는 중복 include를 방지하지만, ODR 위반은 정의를 여러 번 포함하는 것에서 발생합니다.
  - ✅ **정확한 답변**: "헤더에는 선언만, 정의는 .cpp에 두는 것입니다."
  - 💡 **보완**: 헤더에는 선언만 넣고, 정의는 .cpp 파일에 둡니다. inline 함수, 템플릿, constexpr 변수는 예외입니다. #pragma once나 헤더 가드는 중복 include를 방지하지만, ODR 위반 방지의 핵심은 정의를 헤더에 넣지 않는 것입니다.

**질문 2: ODR을 의식한 헤더 설계의 핵심은 무엇인가요?**
- **현재 답변**: "구현부가 없는 API만 추려서 볼 수 있습니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 너무 모호합니다. 구체적인 설계 원칙을 명시해야 합니다.
  - ✅ **정확한 답변**: "헤더에는 inline/template/constexpr만 정의하고 나머지는 선언만 둡니다."
  - 💡 **보완**: 헤더에는 일반 함수/변수는 선언만 두고, inline 함수, 템플릿, constexpr 변수만 정의를 둡니다. 이를 통해 API 인터페이스를 명확히 하고 ODR 위반을 방지합니다.

### ✅ 요약 질문

**질문 1: ODR을 한 문장으로 요약해보세요.**
- **현재 답변**: "하나의 함수 심볼은 한 번만 정의해야한다는 규칙입니다. 이를 위배할경우 링킹과정에서 문제가 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: "함수 심볼"만 언급했지만, 함수뿐만 아니라 변수, 클래스 등 모든 엔티티에 적용됩니다. 또한 두 문장으로 나뉘어 있습니다.
  - ✅ **정확한 답변**: "ODR은 '같은 것은 한 번만 정의하라'는 C++ 규칙입니다."
  - 💡 **보완**: ODR은 프로그램 전체에서 같은 엔티티(함수, 변수, 클래스 등)가 정확히 한 번만 정의되어야 한다는 C++ 규칙입니다.

### 📊 전체 평가

**강점:**
- ODR의 기본 개념을 이해하고 있습니다.
- 헤더에 선언만 넣어야 한다는 원칙을 알고 있습니다.
- 링크 단계에서 문제가 발생한다는 것을 알고 있습니다.

**개선 필요:**
- ❌ ODR의 핵심 오개념 (선언 vs 정의 혼동)
- ❌ inline 함수 동작 설명 오개념 ("선언부 제거" vs "링커가 합침")
- ❌ 헤더에 함수 정의 시 문제 발생 시점 오개념 (컴파일 타임 vs 링크 타임)
- ❌ 전역 변수 ODR 위반 답변 미완성
- ❌ constexpr 변수 관계 답변 누락
- ⚠️ ODR 필요성 설명 부정확 (컴파일러 vs 링커)
- ⚠️ 선언 vs 정의 차이 설명이 함수에만 국한됨
- ⚠️ 헤더 파일 내용 설명 부족 (inline/template/constexpr 예외)
- ⚠️ ODR 위반 사례 설명 부족 (전역 변수, 클래스 멤버 함수)
- ⚠️ 템플릿 설명 부정확 ("문제가 적다" vs "ODR 예외")
- ⚠️ 링크 에러와 ODR 위반 관계 설명 부정확 (선언부/구현부 vs 정의)
- ⚠️ ODR 위반 방지 원칙 설명 부정확 (#pragma once의 역할)
- ⚠️ 헤더 설계 핵심 설명 모호
- ⚠️ 요약 질문이 함수에만 국한됨

**우선순위:**
1. **높음**: ODR의 핵심 개념 수정 (선언 vs 정의 혼동)
2. **높음**: inline 함수 동작 설명 수정 (링커가 합치는 것)
3. **높음**: 헤더에 함수 정의 시 문제 발생 시점 수정 (링크 타임)
4. **높음**: 전역 변수 ODR 위반, constexpr 변수 관계 답변 작성
5. **중간**: ODR 위반 사례 보완 (전역 변수, 클래스 멤버 함수)
6. **중간**: 헤더 파일 내용 설명 보완 (inline/template/constexpr 예외)
7. **낮음**: 표현 정확성 개선 (컴파일러 vs 링커, 선언 vs 정의 등)

**특별 주의사항:**
- ODR은 "선언"이 아니라 "정의"에 대한 규칙입니다. 선언은 여러 번 가능하지만, 정의는 한 번만 가능합니다.
- 헤더에 함수 정의를 넣으면 컴파일은 성공하지만, 링크 단계에서 중복 정의 에러가 발생합니다.
- inline 함수는 여러 번 정의되어도 동일하면 링커가 하나로 합칩니다. "선언부 제거"가 아닙니다.
- 템플릿과 constexpr 변수는 ODR의 예외로, 헤더에 정의를 넣을 수 있습니다.
- #pragma once는 중복 include를 방지하지만, ODR 위반 방지의 핵심은 정의를 헤더에 넣지 않는 것입니다.
- ODR은 함수뿐만 아니라 변수, 클래스 등 모든 엔티티에 적용됩니다.
