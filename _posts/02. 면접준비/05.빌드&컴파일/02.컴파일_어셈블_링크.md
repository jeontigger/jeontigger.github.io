# 🧠 C/C++ 컴파일 / 어셈블 / 링크 단계 설명 가능 면접 질문 리스트

## ✅ 전체 흐름

1. C/C++ 프로그램이 실행 파일이 되기까지의 전체 단계를 설명해보세요.

    - 전처리, 컴파일, 어셈플, 링킹 과정을 통해서 프로그램이 만들어집니다.

2. 전처리, 컴파일, 어셈블, 링크 단계의 순서는 어떻게 되나요?

    - 전처리 -> 컴파일 -> 어셈블 -> 링크 단계로 이루어집니다.

## ✅ 컴파일 단계

1. 컴파일 단계에서는 어떤 작업이 수행되나요?

    - 문법 검사, 함수의 심볼화 등이 이루어집니다.

2. 컴파일 단계의 입력과 출력은 무엇인가요?

    - 전처리 단계를 거친 파일이 입력이고, 출력으론 어셈블리 파일이 나옵니다.

3. 컴파일 에러는 어떤 종류의 오류인가요?

    - 컴파일 에러는 언어의 문법적 오류를 검출합니다.

## ✅ 어셈블 단계

1. 어셈블 단계란 무엇인가요?

    - 컴파일 단계가 지나서 나온 어셈블리 파일을 기계어로 변경하는 단계입니다.

2. 어셈블 단계의 입력과 출력은 무엇인가요?

    - 어셈블리 파일이 입력이고, 기계어 파일이 출력입니다.

3. 어셈블 에러는 언제 발생하나요?

    - 어셈블리 문법이 일치하지 않을 때 발생합니다.

## ✅ 링크 단계

1. 링크 단계란 무엇인가요?

    - 기계어로 작업된 오브젝트 파일들을 서로 연결하여 프로그램을 만드는 단계입니다.

2. 링크 단계에서는 어떤 작업이 수행되나요?

    - makefile등을 읽어서 헤더와 목적파일을 서로 이어주는 역할을 합니다. 헤더와 함수 구현부를 이어줍니다.

3. 링크 에러는 어떤 경우에 발생하나요?

    - 링크 에러는 호출된 함수 시그니처가 있지만 구현부가 연결되지 않을 때 발생합니다.

## ✅ 오브젝트 파일 / 심볼

1. 오브젝트 파일(.o/.obj)에는 무엇이 들어 있나요?
2. 심볼(symbol)이란 무엇인가요?

## ✅ 정적 / 동적 링크

1. 정적 링크와 동적 링크의 차이는 무엇인가요?

    - 정적링크는 컴파일 과정에서 구현부와 호출부를 연결하고, 동적 링크는 런타임에서 동적 타입에 따라 함수 구현부를 연결합니다.
    
2. 컴파일 / 어셈블 / 링크 단계를 한 문장으로 요약해보세요.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 📝 모범 답변

### ✅ 전체 흐름

1. 전처리 → 컴파일 → 어셈블 → 링크 순서로 진행됩니다.
2. 전처리 → 컴파일 → 어셈블 → 링크 순서입니다.

### ✅ 컴파일 단계

3. 소스 코드를 어셈블리 코드로 변환하고 최적화합니다.
4. 입력은 전처리된 소스, 출력은 어셈블리 코드입니다.
5. 문법 오류, 타입 오류, 의미론 오류입니다.

### ✅ 어셈블 단계

6. 어셈블리 코드를 기계어 오브젝트 파일로 변환하는 단계입니다.
7. 입력은 어셈블리 코드, 출력은 오브젝트 파일입니다.
8. 어셈블리 문법 오류나 명령어 오류 시 발생합니다.

### ✅ 링크 단계

9. 여러 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합하는 단계입니다.
10. 심볼 해석, 주소 재배치, 라이브러리 연결을 수행합니다.
11. 정의되지 않은 심볼, 중복 정의, 라이브러리 누락 시 발생합니다.

### ✅ 오브젝트 파일 / 심볼

12. 기계어 코드, 데이터, 심볼 테이블, 재배치 정보가 들어 있습니다.
13. 함수나 변수 같은 식별자와 메모리 주소의 연결 정보입니다.

### ✅ 정적 / 동적 링크

14. 정적은 컴파일 시 포함, 동적은 실행 시 로드됩니다.

</div>
</details>

## 📝 GPT 피드백

### ✅ 전체 흐름

**질문 1: C/C++ 프로그램이 실행 파일이 되기까지의 전체 단계를 설명해보세요.**
- **현재 답변**: "전처리, 컴파일, 어셈플, 링킹 과정을 통해서 프로그램이 만들어집니다."
- **피드백**:
  - ⚠️ **부정확**: "어셈플"은 오타이며, 각 단계의 역할이 명확하지 않습니다.
  - ✅ **정확한 답변**: "전처리 → 컴파일 → 어셈블 → 링크 순서로 진행됩니다."
  - 💡 **보완**: 각 단계의 역할을 간단히 언급하면 더 좋습니다. 전처리(헤더 포함, 매크로 치환), 컴파일(소스를 어셈블리로), 어셈블(어셈블리를 기계어로), 링크(오브젝트 파일 결합).

**질문 2: 전처리, 컴파일, 어셈블, 링크 단계의 순서는 어떻게 되나요?**
- **현재 답변**: "전처리 -> 컴파일 -> 어셈블 -> 링크 단계로 이루어집니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. 화살표 표기(→)를 사용하면 더 표준적입니다.

### ✅ 컴파일 단계

**질문 1: 컴파일 단계에서는 어떤 작업이 수행되나요?**
- **현재 답변**: "문법 검사, 함수의 심볼화 등이 이루어집니다."
- **피드백**:
  - ⚠️ **부정확**: 핵심 작업인 "소스 코드를 어셈블리 코드로 변환"이 누락되었습니다. "함수의 심볼화"는 링크 단계의 작업입니다.
  - ✅ **정확한 답변**: "소스 코드를 어셈블리 코드로 변환하고 최적화합니다."
  - 💡 **보완**: 컴파일러는 전처리된 소스 코드를 어셈블리 코드로 변환하며, 문법 검사, 타입 검사, 최적화 등을 수행합니다.

**질문 2: 컴파일 단계의 입력과 출력은 무엇인가요?**
- **현재 답변**: "전처리 단계를 거친 파일이 입력이고, 출력으론 어셈블리 파일이 나옵니다."
- **피드백**:
  - 💡 **보완**: 정확합니다. "전처리된 소스"와 "어셈블리 코드"라고 표현하면 더 명확합니다.

**질문 3: 컴파일 에러는 어떤 종류의 오류인가요?**
- **현재 답변**: "컴파일 에러는 언어의 문법적 오류를 검출합니다."
- **피드백**:
  - ⚠️ **부정확**: 문법 오류만 언급했지만, 타입 오류와 의미론 오류도 컴파일 에러입니다.
  - ✅ **정확한 답변**: "문법 오류, 타입 오류, 의미론 오류입니다."
  - 💡 **보완**: 컴파일 에러는 문법 오류(구문 오류), 타입 오류(타입 불일치), 의미론 오류(미정의 변수 사용 등)를 포함합니다.

### ✅ 어셈블 단계

**질문 1: 어셈블 단계란 무엇인가요?**
- **현재 답변**: "컴파일 단계가 지나서 나온 어셈블리 파일을 기계어로 변경하는 단계입니다."
- **피드백**:
  - ⚠️ **부정확**: "기계어 파일"보다는 "오브젝트 파일"이 정확한 표현입니다. 오브젝트 파일에는 기계어 코드뿐만 아니라 심볼 테이블, 재배치 정보 등도 포함됩니다.
  - ✅ **정확한 답변**: "어셈블리 코드를 기계어 오브젝트 파일로 변환하는 단계입니다."
  - 💡 **보완**: 어셈블러는 어셈블리 코드를 기계어로 변환하여 오브젝트 파일(.o/.obj)을 생성합니다.

**질문 2: 어셈블 단계의 입력과 출력은 무엇인가요?**
- **현재 답변**: "어셈블리 파일이 입력이고, 기계어 파일이 출력입니다."
- **피드백**:
  - ⚠️ **부정확**: "기계어 파일"보다는 "오브젝트 파일"이 정확합니다.
  - ✅ **정확한 답변**: "입력은 어셈블리 코드, 출력은 오브젝트 파일입니다."

**질문 3: 어셈블 에러는 언제 발생하나요?**
- **현재 답변**: "어셈블리 문법이 일치하지 않을 때 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: 문법 오류만 언급했지만, 명령어 오류도 포함됩니다.
  - ✅ **정확한 답변**: "어셈블리 문법 오류나 명령어 오류 시 발생합니다."
  - 💡 **보완**: 어셈블 에러는 어셈블리 문법 오류, 잘못된 명령어, 레지스터 오류 등에서 발생합니다.

### ✅ 링크 단계

**질문 1: 링크 단계란 무엇인가요?**
- **현재 답변**: "기계어로 작업된 오브젝트 파일들을 서로 연결하여 프로그램을 만드는 단계입니다."
- **피드백**:
  - ⚠️ **부정확**: "프로그램"보다는 "실행 파일"이 더 정확합니다. 라이브러리 연결도 포함해야 합니다.
  - ✅ **정확한 답변**: "여러 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합하는 단계입니다."
  - 💡 **보완**: 링커는 여러 오브젝트 파일과 정적/동적 라이브러리를 결합하여 하나의 실행 파일을 만듭니다.

**질문 2: 링크 단계에서는 어떤 작업이 수행되나요?**
- **현재 답변**: "makefile등을 읽어서 헤더와 목적파일을 서로 이어주는 역할을 합니다. 헤더와 함수 구현부를 이어줍니다."
- **피드백**:
  - ❌ **오개념**: 링커는 makefile을 읽지 않습니다. makefile은 빌드 도구(make)가 읽습니다. 또한 헤더 파일은 링크 단계에서 사용되지 않습니다.
  - ✅ **정확한 답변**: "심볼 해석, 주소 재배치, 라이브러리 연결을 수행합니다."
  - 💡 **보완**: 링커는 오브젝트 파일들 간의 심볼 참조를 해석하고, 메모리 주소를 재배치하며, 필요한 라이브러리를 연결합니다. 헤더 파일은 컴파일 단계에서만 사용됩니다.

**질문 3: 링크 에러는 어떤 경우에 발생하나요?**
- **현재 답변**: "링크 에러는 호출된 함수 시그니처가 있지만 구현부가 연결되지 않을 때 발생합니다."
- **피드백**:
  - ⚠️ **부정확**: 링크 에러의 주요 원인만 언급했지만, 중복 정의나 라이브러리 누락도 중요합니다.
  - ✅ **정확한 답변**: "정의되지 않은 심볼, 중복 정의, 라이브러리 누락 시 발생합니다."
  - 💡 **보완**: 링크 에러는 정의되지 않은 심볼(함수/변수 선언만 있고 정의 없음), 중복 정의(같은 심볼이 여러 번 정의됨), 라이브러리 누락 등에서 발생합니다.

### ✅ 오브젝트 파일 / 심볼

**질문 1: 오브젝트 파일(.o/.obj)에는 무엇이 들어 있나요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 면접에서 자주 나오는 질문입니다.
  - ✅ **정확한 답변**: "기계어 코드, 데이터, 심볼 테이블, 재배치 정보가 들어 있습니다."
  - 💡 **보완**: 오브젝트 파일에는 컴파일된 기계어 코드, 초기화된/초기화되지 않은 데이터, 심볼 테이블(함수/변수 이름과 주소), 재배치 정보(링크 시 주소 조정을 위한 정보)가 포함됩니다.

**질문 2: 심볼(symbol)이란 무엇인가요?**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 링크 단계를 이해하는 데 중요한 개념입니다.
  - ✅ **정확한 답변**: "함수나 변수 같은 식별자와 메모리 주소의 연결 정보입니다."
  - 💡 **보완**: 심볼은 함수나 변수 같은 식별자와 메모리 주소를 연결하는 정보입니다. 링커는 심볼 테이블을 사용하여 서로 다른 오브젝트 파일 간의 참조를 해석합니다.

### ✅ 정적 / 동적 링크

**질문 1: 정적 링크와 동적 링크의 차이는 무엇인가요?**
- **현재 답변**: "정적링크는 컴파일 과정에서 구현부와 호출부를 연결하고, 동적 링크는 런타임에서 동적 타입에 따라 함수 구현부를 연결합니다."
- **피드백**:
  - ❌ **오개념**: "동적 타입에 따라 함수 구현부를 연결"이라는 설명이 잘못되었습니다. 동적 링크는 런타임에 라이브러리를 로드하는 것이지, 타입에 따라 연결하는 것이 아닙니다.
  - ✅ **정확한 답변**: "정적은 컴파일 시 포함, 동적은 실행 시 로드됩니다."
  - 💡 **보완**: 
    - 정적 링크: 컴파일/링크 시점에 라이브러리 코드가 실행 파일에 포함됨. 실행 파일 크기가 크지만 독립적 실행 가능.
    - 동적 링크: 실행 시점에 동적 라이브러리(.dll/.so)를 메모리에 로드. 실행 파일 크기가 작지만 런타임에 라이브러리가 필요함.

**질문 2: 컴파일 / 어셈블 / 링크 단계를 한 문장으로 요약해보세요.**
- **현재 답변**: 답변 누락
- **피드백**:
  - ❌ **답변 필요**: 전체 흐름을 요약하는 중요한 질문입니다.
  - ✅ **정확한 답변**: "컴파일/어셈블/링크는 '소스를 실행 파일로 변환하는 3단계 과정'입니다."
  - 💡 **보완**: 컴파일(소스→어셈블리), 어셈블(어셈블리→오브젝트), 링크(오브젝트→실행 파일)로 소스 코드를 실행 가능한 파일로 변환하는 과정입니다.

### 📊 전체 평가

**강점:**
- 전체 빌드 과정의 순서를 이해하고 있습니다.
- 각 단계의 기본적인 입력/출력을 알고 있습니다.
- 컴파일, 어셈블, 링크의 기본 개념을 이해하고 있습니다.

**개선 필요:**
- ❌ 링크 단계의 작업 설명 오개념 (makefile, 헤더 파일 관련)
- ❌ 동적 링크의 개념 오개념 (동적 타입 관련)
- ❌ 오브젝트 파일 내용, 심볼 개념 답변 누락
- ❌ 컴파일/어셈블/링크 요약 답변 누락
- ⚠️ 컴파일 단계 작업 설명 부정확 (심볼화는 링크 단계)
- ⚠️ 컴파일 에러 종류 설명 부족 (타입 오류, 의미론 오류 누락)
- ⚠️ 어셈블 단계 출력 표현 부정확 ("기계어 파일" vs "오브젝트 파일")
- ⚠️ 링크 단계 설명 부정확 (라이브러리 연결 누락)
- ⚠️ 링크 에러 종류 설명 부족 (중복 정의, 라이브러리 누락)

**우선순위:**
1. **높음**: 링크 단계 작업 설명 오개념 수정 (makefile, 헤더 파일 관련)
2. **높음**: 동적 링크 개념 오개념 수정 (동적 타입 관련)
3. **높음**: 오브젝트 파일 내용, 심볼 개념 답변 작성
4. **중간**: 컴파일 단계 작업 설명 수정 (심볼화는 링크 단계)
5. **중간**: 컴파일/어셈블/링크 요약 답변 작성
6. **중간**: 링크 에러 종류 보완
7. **낮음**: 표현 정확성 개선 (오브젝트 파일, 실행 파일 등)

**특별 주의사항:**
- 링커는 makefile을 읽지 않습니다. makefile은 빌드 도구(make)가 사용합니다. 링커는 오브젝트 파일과 라이브러리만 다룹니다.
- 헤더 파일은 컴파일 단계에서만 사용됩니다. 링크 단계에서는 사용되지 않습니다.
- 동적 링크는 "동적 타입"과 무관합니다. 런타임에 라이브러리를 로드하는 것을 의미합니다.
- 오브젝트 파일과 심볼의 개념은 링크 단계를 이해하는 데 필수적입니다. 면접에서 자주 나오는 주제입니다.