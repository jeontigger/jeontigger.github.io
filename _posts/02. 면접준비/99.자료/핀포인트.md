1. raii는 결정적 소멸, gc는 비결정적 소멸이다. 결정적 소멸은 소멸의 시점을 직접 제어, 비결정적 소멸은 소멸의 시점이 언제 이뤄질지 모름

2. 얕은 복사와 참조는 전혀 다른개념. 

3. 참조는 무조건 포인터는 아님

4. 참조는 null이 불가능하고 초기화되고나서 다른것으로 변경은 불가능

5. const => 불변성으로 만듬

6. const & => 읽기 전용 접근

7. constexpr => 컴파일 타임 평가 가능 키워드. 템플릿 메타 프로그래밍, 컴파일 타임 계산 최적화 등의 이유로 생김

8. 복사 생성자는 같은 타입의 기존 객체를 이용해 새 객체를 만드는 것

9. move와 static_cast<T&&>와 전혀 다름

10. 임시객체란 해당 표현식에서만 사용 가능한 이름없는 객체

11. 임시객체는 참조와 연결하면 수명이 연장됨

12. vtable은 데이터 영역에 존재. 상속관계에서 생성자 호출시 vptr을 vtable로 순차적으로 갱신

13. 템플릿이란 타입은 다르지만 같은 동작을 수행하는 코드를 하나로 관리하기 위해 만들어진 시스템

14. 템플릿 함수는 특수화가 불가능함(오버로드와 구분이 안돼서 그럼). 그래서 SFINAE랑 concepts가 나옴

```cpp
// SFINAE = Substitution Failure Is Not An Error
// SFINAE
template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type

// concepts
template<std::integral T>
void Print(T value)
{
    std::cout << "Integral: " << value << "\n";
}
```

15. 여러 특수화가 있을 때는 가장 고정이 많이 된 특수화 순서대로 연결

16. STL에서 2배씩 증가하는 이유는 메모리 효율과 성능의 절충안임

17. deque는 청크단위라고 함. 게다가 고정 크기 배열. double ended queue. 앞뒤 확장 가능한 vector를 쓰고 싶었다고 봐야하는듯. 메모리와 성능은 살짝 딸림

18. string은 SSO가 있음

19. multiset에서 erase에 iterator를 넣으면 cnt를 감소시키고, key를 넣으면 모두 삭제함

20. 어댑터 컨테이너는 기본 컨테이너에 기능을 제한한 것

21. stack에 deque를 쓰는 이유는 메모리 재할당을 피하기 위함

22. 이터레이터는 STL에 통일된 방법으로 접근하기 위한 추상화된 포인터 인터페이스

23. 알고리즘에서 [begin, end)를 사용하는 이유는 범위 표현에 좋아서. 빈 컨테이너를 표현하기도, 종료 조건을 명시하기도 좋음

24. std::find는 O(n)이지만 map::find는 O(logn)임

25. shared_ptr의 use_count는 스레드 안정적이지 않기 때문에 로직 판단에 사용해선 안됨

26. 캐시는 메모리를 캐시라인 단위로 가져옴 그래서 false sharing이 발생함

27. 구조체 패딩은 효율적인 메모리 접근을 위해 생기는 것. 가장 큰 타입을 기준으로 정렬됨. 

28. race condition이란 접근하는 순서에 따라 결과가 달라지는 상태를 뜻함

29. 선점형과 비선점형은 CPU 기준에서 말함

30. 