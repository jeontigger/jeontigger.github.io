---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: false
tags:
    [면접준비]
---

# 🧠 C++ Stack vs Heap 면접 질문 리스트

---

## ✅ 기본 개념

1. 스택(Stack) 메모리와 힙(Heap) 메모리의 차이를 설명해보세요.

    - 스택은 LIFO 구조의 메모리 영역으로 함수가 진행되면서 cpu에 의해 늘었다 줄었다 하고, 힙 영역은 프로그래머가 할당과 해제를 관리해야하는 메모리 영역으로 관리를 잘 하지 못했을 경우엔 메모리 문제가 발생할 수 있습니다.

2. 스택과 힙은 각각 어떤 용도로 사용되나요?

    - 스택은 컴파일시간에 계산될 수 있는 크기 이면서, 상대적으로 작은 크기들이 필요할 때 사용됩니다. 힙은 크기가 런타임에 동적으로 변경되어 컴파일 타임에 예측할 수 없거나, 스택의 최대 크기를 넘길 가능성이 있는 상대적으로 큰 크기들의 메모리를 할당하기 위해 사용합니다.

3. 함수 호출 시 스택에는 어떤 정보들이 저장되나요?

    - 함수 내의 지역변수들, 파라미터, 리턴 주소, 스택 프레임 크기 등이 저장됩니다.

4. 힙 메모리는 언제 사용해야 하나요?

    - 동적인 크기가 필요할 때, 그리고 큰 크기들의 메모리가 필요할 때 사용해야 합니다.

5. 스택 메모리는 왜 크기가 제한적인가요?

    - 멀티스레드 환경에서 스레드마다 스택 메모리를 별도로 갖게 되는데, 스레드마다 제한없는 크기를 갖는다면, 스레드에게 할당해주어야 하는 스택 주소 지점 결정이 어렵기 때문입니다.

6. 스택은 왜 LIFO 구조를 가지나요?

    - 함수 스택에 사용될 때 이전 스택의 메모리를 참고하지 못하도록 하는 등의 안정성과 함수 콜스택의 구조와 일치하기 때문에 LIFO구조를 선택했다고 생각합니다.

---

## ✅ 메모리 할당 / 해제

1. 스택 메모리의 할당과 해제는 누가 수행하나요?

    - cpu가 함수를 호출할 때 스택 메모리를 할당하고, 함수가 해제될 때 스택 메모리를 해제합니다.

2. 힙 메모리의 할당과 해제는 누가 책임지나요?

    - 힙 메모리는 프로그래머가 할당과 해제를 책임집니다.

3. C++에서 `new/delete`와 스택 변수의 차이는 무엇인가요?

    - new/delete는 스택 변수와 다르게 힙 영역에 메모리를 할당하는 연산자입니다.

4. 스택 변수와 힙 변수의 생명 주기 차이를 설명해보세요.

    - 스택변수는 함수가 호출될 때 생성되고 함수가 해제될 때 소멸됩니다. 힙 변수는 프로그래머가 할당할 때 생성되고, 프로그래머가 해제하기 전까지 소멸되지 않습니다. 프로그램 종료시 해제되지 않은 힙 메모리 변수들은 전부 해제됩니다.

5. 힙 메모리 사용 시 발생할 수 있는 문제에는 무엇이 있나요?

    - 메모리 누수, 더블 프리, 댕글링 포인터 등이 있습니다.

---

## ✅ 성능 및 구조

1. 스택 메모리가 힙보다 빠른 이유는 무엇인가요?

    - 스택 메모리는 연속된 메모리 구조를 가지고 있기 때문에 할당 가능한 영역을 찾아야하는 힙 메모리 영역보다는 과정이 하나 적고, 캐시 친화적이기 때문에 빠르게 됩니다.

2. 캐시 관점에서 스택과 힙의 차이를 설명해보세요.

    - 스택은 연속된 메모리 구조이고, 힙은 연속하지 않은 덩어리 방식의 메모리 할당 구조이기 때문에 캐시의 공간지역성적으로 스택이 유리합니다.

3. 스택 프레임(Stack Frame)이란 무엇인가요?

    - 스택 프레임이란 함수가 호출되면서 스택 메모리가 할당되는 하나의 덩어리를 이야기합니다. 스택 프레임에는 파라미터, 리턴 주소, 함수 스택 변수 등이 저장됩니다.

4. 함수 호출이 깊어질수록 스택에는 어떤 변화가 생기나요?

    - 스택이 점점 쌓이면서 스택의 제한에 도달한다면 스택 오버플로우 문제가 발생할 수 있습니다.

---

## ✅ 오류 및 문제 상황

1. 스택 오버플로우(Stack Overflow)는 언제 발생하나요?

    - 스택 프레임이 계속해서 쌓이다가 제한된 스택 메모리의 크기보다 많은 양의 메모리를 사용하려고 할 때 스택 오버플로우가 발생합니다.

2. 힙 오버플로우와 스택 오버플로우의 차이는 무엇인가요?

    - 스택 오버플로우는 주로 스택 변수에 큰 크기를 할당 했다거나, 재귀 함수가 계속 호출되는 문제로 발생합니다. 그러나 힙 오버플로우는 가상메모리에서 할당 가능한 메모리를 모두 사용했을 때 발생하게 됩니다.

3. 댕글링 포인터(Dangling Pointer)는 언제 발생하나요?

    - 댕글링 포인터는 포인터가 가리키고 있는 자원이 해제되었지만, 해제된지 모른채 가리키고 있는 포인터를 뜻합니다. 포인터가 가리키고 있는 자원이 해제될 때 nullptr로 초기화를 하지 않았을 때와 또, 같은 자원을 가리키고 있는 또다른 포인터가 해제된 사실을 알지 못할 때 발생합니다.

4. 메모리 누수는 왜 힙에서 주로 발생하나요?

    - 스택 메모리에서는 함수 호출 흐름에 따라서 cpu가 할당과 해제를 하기 때문에 메모리 누수가 발생하지 않습니다. 프로그래머가 할당과 해제를 책임져야하는 힙 메모리 영역에서 해제하지 않았을 경우에 발생합니다.

---

## ✅ C++ 언어 관점

1. 지역 변수는 항상 스택에 할당되나요?

    - 함수 내의 static 변수는 지역변수처럼 생겼지만, data영역에 할당됩니다.

2. 전역 변수와 static 변수는 어디에 할당되나요?

    - data 영역에 할당됩니다. default값이나 초기화되지 않은 전역과 static 변수들은 bss 영역에 할당됩니다.

3. 스마트 포인터는 스택과 힙 중 어디를 사용하나요?

    - 스택을 사용합니다. 스택 변수의 라이프 사이클에 의존하여 자원을 관리하는 기법입니다.

4. RAII 패턴은 스택과 어떤 관련이 있나요?

    - 스택 변수들은 함수가 해제될 때 변수의 생명 주기가 해제됩니다. 이 때 자원의 생명 주기를 스택 변수에게 맡기는 것입니다.

---

## ✅ 멀티스레드 관점

1. 멀티스레드 환경에서 스택과 힙은 어떻게 관리되나요?

    - 멀티스레드에서 스택은 스레드 마다 할당되게 됩니다. 따라서 스레드별 스택은 독립적으로 관리됩니다. 그러나 힙은 모든 스레드가 공유되기 때문에 레이스 컨디션에 유의해야 합니다.

2. 스택 메모리는 스레드 안전한가요?

    - 네

---

## ✅ 실무 판단

1. 객체를 스택에 둘지 힙에 둘지 어떻게 판단하나요?

    - 저는 현재 스택 메모리가 해제되어도 필요하거나, 크기를 예측할 수 없을 때 힙에 두고, 스택 메모리와 함께 생명주기가 일치하다면 스택에 둡니다.

2. 대용량 배열은 왜 힙에 할당해야 하나요?

    - 스택 메모리의 제한이 크지 않기 때문에 대용량 배열은 힙에 할당해야 합니다.

3. 게임/엔진 개발에서 스택과 힙 선택이 중요한 이유는 무엇인가요?

    - 스택은 캐시 친화적이라 빠르고 좋지만 적은 양의 메모리를 사용할 수 있고, 힙은 큰 용량을 사용할 수 있지만 스택에 비해 느리고, 관리에 유의해야하기 때문입니다.

---

## ✅ 함정 질문

1. `std::vector`는 스택에 있나요, 힙에 있나요?

    - vector 자체는 스택에 있습니다. vector가 관리하는 자원은 힙에 있습니다.

2. 스택에 할당된 객체의 주소를 반환하면 어떤 문제가 발생하나요?

    - 주소는 정상적으로 반환되지만, 댕글링 포인터가 됩니다.

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: 스택(Stack) 메모리와 힙(Heap) 메모리의 차이를 설명해보세요.**
- **현재 답변**: "스택은 LIFO 구조의 메모리 영역으로 함수가 진행되면서 cpu에 의해 늘었다 줄었다 하고..."
- **피드백**:
  - ⚠️ **부정확**: "cpu에 의해"라는 표현은 부정확합니다. 스택 메모리는 **컴파일러가 함수 진입/종료 시 자동으로 관리**합니다.
  - ✅ **정확한 답변**: "스택은 자동 관리되는 고정 크기 메모리이고, 힙은 런타임에 동적 할당되는 메모리입니다."
  - 스택은 컴파일러가 함수 호출 시 자동으로 할당/해제하며, 힙은 프로그래머가 명시적으로 관리해야 합니다.

**질문 2: 스택과 힙은 각각 어떤 용도로 사용되나요?**
- **현재 답변**: "스택은 컴파일시간에 계산될 수 있는 크기 이면서, 상대적으로 작은 크기들이 필요할 때 사용됩니다..."
- **피드백**:
  - 💡 **보완**: 답변은 정확하지만 생명 주기 관점을 추가하면 더 좋습니다.
  - ✅ **정확한 답변**: "스택은 짧은 생명 주기의 지역 변수에, 힙은 긴 생명 주기의 동적 객체에 사용됩니다."
  - 크기뿐만 아니라 객체의 생명 주기가 함수 범위를 넘어가는지도 중요한 판단 기준입니다.

**질문 5: 스택 메모리는 왜 크기가 제한적인가요?**
- **현재 답변**: "멀티스레드 환경에서 스레드마다 스택 메모리를 별도로 갖게 되는데, 스레드마다 제한없는 크기를 갖는다면, 스레드에게 할당해주어야 하는 스택 주소 지점 결정이 어렵기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 설명이 약간 부정확합니다. 스택은 스레드 생성 시 **고정 크기로 미리 할당**되기 때문에 제한적입니다.
  - ✅ **정확한 답변**: "스택은 스레드 생성 시 고정 크기로 할당되기 때문입니다."
  - 각 스레드는 생성 시점에 고정된 크기의 스택을 할당받으며, 런타임에 크기를 변경할 수 없습니다.

**질문 6: 스택은 왜 LIFO 구조를 가지나요?**
- **현재 답변**: "함수 스택에 사용될 때 이전 스택의 메모리를 참고하지 못하도록 하는 등의 안정성과 함수 콜스택의 구조와 일치하기 때문에 LIFO구조를 선택했다고 생각합니다."
- **피드백**:
  - 💡 **보완**: "생각합니다"라는 불확실한 표현 대신 명확한 이유를 제시해야 합니다.
  - ✅ **정확한 답변**: "함수 호출과 반환이 중첩 구조이기 때문에 LIFO 구조를 가집니다."
  - 함수는 호출된 순서의 역순으로 반환되므로, 스택의 LIFO 구조가 함수 호출 스택의 특성과 자연스럽게 일치합니다.

### ✅ 메모리 할당 / 해제

**질문 1: 스택 메모리의 할당과 해제는 누가 수행하나요?**
- **현재 답변**: "cpu가 함수를 호출할 때 스택 메모리를 할당하고, 함수가 해제될 때 스택 메모리를 해제합니다."
- **피드백**:
  - ⚠️ **부정확**: "cpu가"라는 표현은 부정확합니다. **컴파일러가 생성한 코드**가 함수 진입/종료 시 자동으로 수행합니다.
  - ✅ **정확한 답변**: "컴파일러가 함수 진입과 종료 시 자동으로 수행합니다."
  - 컴파일러가 함수 프롤로그/에필로그 코드를 생성하여 스택 포인터를 조정합니다.

**질문 3: C++에서 `new/delete`와 스택 변수의 차이는 무엇인가요?**
- **현재 답변**: "new/delete는 스택 변수와 다르게 힙 영역에 메모리를 할당하는 연산자입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 생명 주기 관리 측면을 추가하면 더 좋습니다.
  - ✅ **정확한 답변**: "스택 변수는 자동 소멸되고, `new`로 생성한 객체는 명시적으로 해제해야 합니다."
  - 스택 변수는 스코프 종료 시 자동 소멸되지만, `new`로 생성한 객체는 `delete`로 명시적 해제가 필요합니다.

**질문 5: 힙 메모리 사용 시 발생할 수 있는 문제에는 무엇이 있나요?**
- **현재 답변**: "메모리 누수, 더블 프리, 댕글링 포인터 등이 있습니다."
- **피드백**:
  - ⚠️ **부정확**: "더블 프리"는 영어 용어이며, 한국어로는 "이중 해제"가 더 적절합니다.
  - ✅ **정확한 답변**: "메모리 누수, 댕글링 포인터, 이중 해제, 단편화 문제가 발생할 수 있습니다."
  - 면접에서는 한국어 용어를 사용하거나, 영어 용어를 사용할 경우 정확한 의미를 설명할 수 있어야 합니다.

### ✅ C++ 언어 관점

**질문 3: 스마트 포인터는 스택과 힙 중 어디를 사용하나요?**
- **현재 답변**: "스택을 사용합니다. 스택 변수의 라이프 사이클에 의존하여 자원을 관리하는 기법입니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 불완전합니다. 스마트 포인터 **객체 자체**는 스택에 있지만, **관리하는 대상**은 힙에 있습니다.
  - ✅ **정확한 답변**: "스마트 포인터 객체는 스택에, 관리 대상은 힙에 있습니다."
  - `std::unique_ptr<int> ptr(new int(10));`에서 `ptr` 객체는 스택에, `new int(10)`으로 할당된 메모리는 힙에 있습니다.

**질문 4: RAII 패턴은 스택과 어떤 관련이 있나요?**
- **현재 답변**: "스택 변수들은 함수가 해제될 때 변수의 생명 주기가 해제됩니다. 이 때 자원의 생명 주기를 스택 변수에게 맡기는 것입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 RAII의 핵심 원리를 더 명확히 설명하면 좋습니다.
  - ✅ **정확한 답변**: "스택 객체 소멸 시점에 자원을 자동 해제하도록 합니다."
  - RAII는 스택 객체의 소멸자가 자동 호출되는 특성을 이용하여 자원 관리를 자동화하는 패턴입니다.

### ✅ 멀티스레드 관점

**질문 2: 스택 메모리는 스레드 안전한가요?**
- **현재 답변**: "네"
- **피드백**:
  - ❌ **답변 필요**: 답변이 너무 간단합니다. 면접에서는 이유를 설명할 수 있어야 합니다.
  - ✅ **정확한 답변**: "스레드별로 분리되어 있어 기본적으로 안전합니다."
  - 각 스레드는 독립적인 스택을 가지므로, 서로 다른 스레드의 스택 메모리에 접근할 수 없어 기본적으로 안전합니다. 다만, 같은 스레드 내에서 여러 함수가 같은 스택 프레임에 접근하는 경우는 주의가 필요합니다.

### ✅ 실무 판단

**질문 1: 객체를 스택에 둘지 힙에 둘지 어떻게 판단하나요?**
- **현재 답변**: "저는 현재 스택 메모리가 해제되어도 필요하거나, 크기를 예측할 수 없을 때 힙에 두고, 스택 메모리와 함께 생명주기가 일치하다면 스택에 둡니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 더 체계적인 판단 기준을 제시하면 좋습니다.
  - ✅ **정확한 답변**: "생명 주기, 크기, 공유 여부, 성능 요구사항을 기준으로 판단합니다."
  - 면접에서는 여러 판단 기준을 체계적으로 나열할 수 있어야 합니다.

### 📊 전체 평가

**강점:**
- ✅ 스택과 힙의 기본 개념을 잘 이해하고 있습니다
- ✅ 메모리 할당/해제의 책임 주체를 정확히 알고 있습니다
- ✅ 스택 프레임, 댕글링 포인터 등 핵심 개념을 이해하고 있습니다
- ✅ `std::vector`의 메모리 구조를 정확히 설명하고 있습니다

**개선 필요:**
- ❌ **오개념**: "cpu가 할당/해제한다"는 표현 → 컴파일러가 자동 관리
- ⚠️ **부정확한 부분**: 
  - 스택 크기 제한 이유 설명이 부정확함
  - 스마트 포인터의 메모리 위치 설명이 불완전함
  - "더블 프리" 용어 사용
- 💡 **개선이 필요한 부분**:
  - LIFO 구조 이유 설명이 불확실함 ("생각합니다")
  - RAII 패턴 설명이 핵심 원리를 놓침
  - 실무 판단 기준이 체계적이지 않음
- ❌ **답변 누락**: 스택 메모리 스레드 안전성에 대한 이유 설명 부족

**우선순위:**
1. **높음**: 컴파일러가 스택 메모리를 관리한다는 개념 정확히 이해하기 (면접에서 자주 나오는 질문)
2. **중간**: 스마트 포인터의 메모리 구조 정확히 이해하기 (객체는 스택, 관리 대상은 힙)
3. **낮음**: 용어 사용 개선 (더블 프리 → 이중 해제)

**특별 주의사항:**
- 스택 메모리 관리 주체는 **컴파일러**이며, CPU가 직접 관리하는 것이 아닙니다. 면접에서 자주 나오는 질문입니다.
- 스마트 포인터는 객체 자체와 관리 대상의 메모리 위치를 구분해서 설명할 수 있어야 합니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 🧠 1줄 모범 답변

1. 스택은 자동 관리되는 고정 크기 메모리이고, 힙은 런타임에 동적 할당되는 메모리입니다.
2. 스택은 짧은 생명 주기의 지역 변수에, 힙은 긴 생명 주기의 동적 객체에 사용됩니다.
3. 함수 인자, 지역 변수, 반환 주소, 이전 스택 프레임 정보가 저장됩니다.
4. 객체의 생명 주기가 함수 범위를 넘거나 크기를 런타임에 결정해야 할 때 사용합니다.
5. 스택은 스레드 생성 시 고정 크기로 할당되기 때문입니다.
6. 함수 호출과 반환이 중첩 구조이기 때문에 LIFO 구조를 가집니다.

7. 컴파일러가 함수 진입과 종료 시 자동으로 수행합니다.
8. 프로그래머가 직접 관리하며 C++에서는 `new/delete`로 처리합니다.
9. 스택 변수는 자동 소멸되고, `new`로 생성한 객체는 명시적으로 해제해야 합니다.
10. 스택 변수는 스코프 기반이고, 힙 변수는 해제 시점까지 유지됩니다.
11. 메모리 누수, 댕글링 포인터, 이중 해제, 단편화 문제가 발생할 수 있습니다.

12. 포인터 이동만으로 할당과 해제가 가능해 오버헤드가 적기 때문입니다.
13. 스택은 연속 메모리로 캐시 효율이 높고, 힙은 분산될 수 있습니다.
14. 함수 호출 시 생성되는 실행 단위 메모리 구조입니다.
15. 스택 프레임이 누적되며 과도하면 스택 오버플로우가 발생합니다.

16. 재귀가 깊거나 스택에 큰 객체를 반복 할당할 때 발생합니다.
17. 스택은 스택 크기 초과, 힙은 가용 메모리 부족 상황입니다.
18. 해제된 메모리를 계속 참조할 때 발생합니다.
19. 자동 해제가 되지 않아 해제를 놓치기 쉽기 때문입니다.

20. 대부분 스택이지만 컴파일러 최적화로 달라질 수 있습니다.
21. 데이터 영역(Data Segment)에 할당됩니다.
22. 스마트 포인터 객체는 스택에, 관리 대상은 힙에 있습니다.
23. 스택 객체 소멸 시점에 자원을 자동 해제하도록 합니다.

24. 각 스레드는 독립적인 스택을 가지고 힙은 공유합니다.
25. 스레드별로 분리되어 있어 기본적으로 안전합니다.

26. 생명 주기, 크기, 공유 여부, 성능 요구사항을 기준으로 판단합니다.
27. 스택 크기 제한으로 인한 오버플로우를 방지하기 위함입니다.
28. 프레임 성능과 메모리 안정성에 직접적인 영향을 주기 때문입니다.

29. 컨테이너 객체는 스택에, 내부 데이터는 힙에 존재합니다.
30. 함수 종료 후 메모리가 해제되어 댕글링 포인터가 됩니다.

</div>
</details>