---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: false
tags:
    [면접준비]
---

# 🧠 C++ 생성자 / 소멸자 호출 순서 면접 질문 리스트

## ✅ 기본 개념

1. C++에서 생성자와 소멸자는 언제 호출되나요?

    - 객체가 생성될 때 생성자가 호출되고, 객체가 소멸할 때 소멸자가 호출됩니다. 스택변수는 해당 스택이 할당될 때,생성되고, 스택이 해제될 때 소멸됩니다. 힙 객체라면 new키워드로 할당될 때 생성자가 호출되고, delete 키워드로 해제될 때 소멸자가 호출됩니다.

2. 객체의 생성자와 소멸자 호출 순서는 왜 중요한가요?

    - 다른 객체가 생성되지 않은 객체를 참조한다거나, 해제된 객체를 참조할 수 있기 때문에 순서가 중요합니다.

3. 스코프 종료 시 어떤 순서로 소멸자가 호출되나요?

    - 생성된 순서 반대로 소멸자가 호출됩니다. 생성되는 순서는 선언된 순서에 맞춰 순차적으로 생성됩니다.

## ✅ 단일 객체 / 지역 객체

1. 지역 객체의 생성자와 소멸자 호출 시점을 설명해보세요.

    - 함수 스코프가 할당될 때 생성자가 호출되고, 함수 스코프가 해제될 때 소멸자가 호출됩니다.

2. 블록 스코프 안에서 여러 객체가 선언되었을 때 소멸 순서는 어떻게 되나요?

    - 생성 순서의 역순으로 소멸됩니다. 생성순서는 선언된 순서에 순차적으로 생성됩니다.

## ✅ 클래스 멤버 관련

1. 클래스에 멤버 객체가 있을 때 생성자 호출 순서는 어떻게 되나요?

    - 먼저 선언된 클래스 맴버 객체가 먼저 생성되면서 생성자가 먼저 호출됩니다.

2. 클래스에 멤버 객체가 있을 때 소멸자 호출 순서는 어떻게 되나요?

    - 생성된 순서 역순으로 해제되기 때문에 마지막에 선언된 멤버 객체부터 처음 선언된 멤버 객체 순서로 소멸자가 호출됩니다.

3. 멤버 초기화 리스트의 작성 순서와 실제 초기화 순서의 관계는 무엇인가요?

    - 초기화 리스트의 작성 순서를 실제 초기화 순서대로 작성하는 것이 바람직합니다.

## ✅ 상속 관계

1. 상속 관계에서 생성자 호출 순서는 어떻게 되나요?

    - 상속관계에서는 최상위 기반 클래스부터 생성자가 호출되어 가장 마지막에 파생한 클래스의 생성자 순으로 호출됩니다.

2. 상속 관계에서 소멸자 호출 순서는 어떻게 되나요?

    - 소멸자의 호출 순서는 생성자의 호출 순서와 반대로 이루어지며, 가장 마지막에 파생한 클래스의 소멸자부터 호출되고, 최상위 기반 클래스 순서대로 호출됩니다.

3. 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가요?

    - 객체의 메모리 구조상 기반 클래스의 크기만큼 할당되어야 파생클래스 메모리의 시작지점을 결정지을 수 있기 때문입니다.
    
4. 소멸자는 왜 자식 클래스부터 호출되나요?

    - 기반클래스부터 호출된다면, 파생클래스의 소멸자를 호출할 수 없기 때문에 자식클래스부터 호출됩니다.

## ✅ 정적(static) 객체

1. 전역 객체의 생성자 호출 시점은 언제인가요?

    - 전역 객체는 프로그램이 로드되면서 생성되고 생성자가 호출됩니다. 전역객체끼리는 파일이 다르다면 생성시점을 결정지을 수 없습니다.

2. 전역 객체의 소멸자 호출 시점은 언제인가요?

    - 프로그램이 종료되면서 소멸자가 호출됩니다.

3. 정적 지역 변수의 생성자 호출 시점은 언제인가요?

    - 해당 정적 지역 변수가 존재하는 함수가 처음 호출되는 시점에 생성자가 호출되고, 이후에 다시 호출될 때에는 호출되지 않습니다.

4. 정적 객체 초기화 순서 문제가 무엇인가요?

    - 정적 객체끼리는 파일이 달라지면 생성 시점을 제어할 수 없습니다. 따라서 정적 객체끼리 의존적인 형태를 사용한다면 문제가 발생할 수 있습니다.

## ✅ 가상 소멸자

1. 가상 소멸자란 무엇인가요?

    - virtual 키워드를 소멸자에 붙이는 것입니다. 

2. 상속 관계에서 소멸자를 가상으로 만들어야 하는 이유는 무엇인가요?

    - 가상 소멸자는 기반 클래스 포인터로 객체를 관리하고 있을 때 소멸하면 파생클래스의 소멸자부터 호출되어 정상적인 소멸이 이루어지도록 합니다. 

3. 가상 소멸자가 없을 때 발생할 수 있는 문제는 무엇인가요?

    - 기반클래스로 관리하고 있을 때 소멸하며 소멸자가 호출되면 기반클래스의 소멸자가 호출됩니다. 기반클래스의 소멸자로 기반 클래스의 힙 할당 객체들은 정상적으로 해제되겠지만, 파생 클래스에서 갖고있는 힙 할당 객체들은 파생클래스의 소멸자가 호출되지 않아 해제되지 않는 메모리 누수 문제가 발생할 수 있습니다.

## ✅ 실무 / 함정 질문

1. 생성자에서 가상 함수 호출은 안전한가요?

    - 의도한 동작이 이뤄지지 않습니다. vtable이 완성되지 않은 상태이며, 언어적 차원에서 virtual로 동작하지 않도록 막습니다.

2. 소멸자에서 가상 함수 호출은 어떤 문제가 있나요?

    - 소멸자도 마찬가지라 vtable이 사라지는 상태이기 때문에 언어적 차원에서 가상함수가 아닌 함수로 호출되게 됩니다.

3. 생성자/소멸자 호출 순서를 한 문장으로 요약해보세요.

    - 상속 관계에서 생성자 호출 순서는 기반->파생, 소멸자 호출 순서는 파생->기반 순서로 이루어집니다.

---

## 📝 GPT 피드백

### ✅ 기본 개념

**질문 1: C++에서 생성자와 소멸자는 언제 호출되나요?**
- **현재 답변**: "객체가 생성될 때 생성자가 호출되고, 객체가 소멸할 때 소멸자가 호출됩니다. 스택변수는 해당 스택이 할당될 때,생성되고, 스택이 해제될 때 소멸됩니다. 힙 객체라면 new키워드로 할당될 때 생성자가 호출되고, delete 키워드로 해제될 때 소멸자가 호출됩니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "스코프 종료/삭제 시"라는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "생성자는 객체 생성 시, 소멸자는 객체가 파괴될 때(스코프 종료/삭제 시) 호출됩니다."
  - 소멸자는 객체가 스코프를 벗어날 때(스택 변수) 또는 `delete`로 삭제될 때(힙 객체) 호출됩니다.

**질문 2: 객체의 생성자와 소멸자 호출 순서는 왜 중요한가요?**
- **현재 답변**: "다른 객체가 생성되지 않은 객체를 참조한다거나, 해제된 객체를 참조할 수 있기 때문에 순서가 중요합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "올바른 초기화·자원 관리(RAII)와 예외 안전성"을 명시하면 더 구체적입니다.
  - ✅ **정확한 답변**: "올바른 초기화·자원 관리(RAII)와 예외 안전성을 보장하기 위해 순서가 중요합니다."
  - 순서가 잘못되면 초기화되지 않은 객체를 사용하거나, 이미 해제된 자원에 접근하는 문제가 발생할 수 있습니다.

### ✅ 클래스 멤버 관련

**질문 1: 클래스에 멤버 객체가 있을 때 생성자 호출 순서는 어떻게 되나요?**
- **현재 답변**: "먼저 선언된 클래스 맴버 객체가 먼저 생성되면서 생성자가 먼저 호출됩니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 불완전합니다. 생성 순서는 "부모 → 멤버(선언 순서) → 본문" 순입니다.
  - ✅ **정확한 답변**: "생성 시에는 (부모 →) 멤버(선언 순서) → 본문 순으로 초기화/실행됩니다."
  - 부모 클래스가 있다면 부모 생성자가 먼저 호출되고, 그 다음 멤버 객체가 선언 순서대로 초기화되며, 마지막에 생성자 본문이 실행됩니다.

**질문 3: 멤버 초기화 리스트의 작성 순서와 실제 초기화 순서의 관계는 무엇인가요?**
- **현재 답변**: "초기화 리스트의 작성 순서를 실제 초기화 순서대로 작성하는 것이 바람직합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 잘못되었습니다. 실제 초기화 순서는 **멤버 선언 순서**이며, 초기화 리스트에 적은 순서와는 무관합니다.
  - ✅ **정확한 답변**: "실제 멤버 초기화 순서는 '멤버 선언 순서'이며 초기화 리스트에 적은 순서와 무관합니다."
  - 초기화 리스트의 순서와 실제 초기화 순서가 다르면 혼란을 야기할 수 있으므로, 선언 순서와 일치시키는 것이 좋습니다.

### ✅ 상속 관계

**질문 3: 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가요?**
- **현재 답변**: "객체의 메모리 구조상 기반 클래스의 크기만큼 할당되어야 파생클래스 메모리의 시작지점을 결정지을 수 있기 때문입니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 메모리 구조에 초점을 맞추고 있지만, 핵심은 "기반 클래스의 불변식을 먼저 보장"해야 한다는 점입니다.
  - ✅ **정확한 답변**: "부모 부분이 먼저 초기화되어야 자식이 그 상태에 의존해 안전하게 생성될 수 있습니다."
  - 기반 클래스의 불변식(invariant)을 먼저 보장해야 파생 클래스가 그 상태에 의존하여 안전하게 생성될 수 있습니다.

**질문 4: 소멸자는 왜 자식 클래스부터 호출되나요?**
- **현재 답변**: "기반클래스부터 호출된다면, 파생클래스의 소멸자를 호출할 수 없기 때문에 자식클래스부터 호출됩니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 기술적인 이유만 언급하고 있습니다. 핵심은 "파생 클래스의 자원이 기반 클래스의 상태에 의존적"일 수 있다는 점입니다.
  - ✅ **정확한 답변**: "자식이 보유한 자원을 먼저 정리한 뒤 부모 자원을 정리해야 안전하기 때문입니다."
  - 파생 클래스의 자원이 기반 클래스의 상태에 의존적일 수 있으므로, 파생 클래스의 소멸자를 먼저 호출해야 합니다.

### ✅ 정적(static) 객체

**질문 1: 전역 객체의 생성자 호출 시점은 언제인가요?**
- **현재 답변**: "전역 객체는 프로그램이 로드되면서 생성되고 생성자가 호출됩니다. 전역객체끼리는 파일이 다르다면 생성시점을 결정지을 수 없습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "일반적으로 `main()` 시작 전에 초기화"된다는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "전역/네임스페이스 스코프 객체는 일반적으로 `main()` 시작 전에 초기화됩니다."
  - 전역 객체는 프로그램 시작 시 `main()` 함수가 호출되기 전에 초기화됩니다.

**질문 2: 전역 객체의 소멸자 호출 시점은 언제인가요?**
- **현재 답변**: "프로그램이 종료되면서 소멸자가 호출됩니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "프로그램 종료 과정에서"라는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "전역/네임스페이스 스코프 객체는 프로그램 종료 과정에서 소멸됩니다."
  - 전역 객체의 소멸자는 `main()` 함수가 반환된 후 프로그램 종료 과정에서 호출됩니다.

**질문 3: 정적 지역 변수의 생성자 호출 시점은 언제인가요?**
- **현재 답변**: "해당 정적 지역 변수가 존재하는 함수가 처음 호출되는 시점에 생성자가 호출되고, 이후에 다시 호출될 때에는 호출되지 않습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "최초로 제어 흐름이 도달할 때 1회 초기화"라는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "정적 지역 변수는 '최초로 제어 흐름이 도달할 때' 1회 초기화됩니다."
  - 정적 지역 변수는 함수가 처음 호출될 때 한 번만 초기화되며, 이후 호출에서는 초기화되지 않습니다.

**질문 4: 정적 객체 초기화 순서 문제가 무엇인가요?**
- **현재 답변**: "정적 객체끼리는 파일이 달라지면 생성 시점을 제어할 수 없습니다. 따라서 정적 객체끼리 의존적인 형태를 사용한다면 문제가 발생할 수 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "서로 다른 번역 단위 간"이라는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "서로 다른 번역 단위 간 정적 객체의 초기화 순서가 보장되지 않아 의존성이 깨질 수 있는 문제입니다."
  - 같은 파일 내에서는 선언 순서대로 초기화되지만, 다른 파일(번역 단위) 간의 초기화 순서는 보장되지 않습니다.

### ✅ 가상 소멸자

**질문 1: 가상 소멸자란 무엇인가요?**
- **현재 답변**: "virtual 키워드를 소멸자에 붙이는 것입니다."
- **피드백**:
  - 💡 **보완**: 답변이 너무 간단합니다. 가상 소멸자의 목적을 설명하면 더 좋습니다.
  - ✅ **정확한 답변**: "기반 클래스 포인터로 삭제할 때도 파생 클래스 소멸자가 호출되도록 하는 소멸자입니다."
  - `virtual` 키워드를 소멸자에 붙여서, 기반 클래스 포인터로 객체를 삭제할 때도 파생 클래스의 소멸자가 호출되도록 합니다.

**질문 2: 상속 관계에서 소멸자를 가상으로 만들어야 하는 이유는 무엇인가요?**
- **현재 답변**: "가상 소멸자는 기반 클래스 포인터로 객체를 관리하고 있을 때 소멸하면 파생클래스의 소멸자부터 호출되어 정상적인 소멸이 이루어지도록 합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 구체적인 예시를 추가하면 더 명확합니다.
  - ✅ **정확한 답변**: "`Base* p = new Derived; delete p;` 상황에서 전체 소멸(파생→기반)을 보장하기 위해 필요합니다."
  - 기반 클래스 포인터로 파생 클래스 객체를 가리킬 때, 가상 소멸자가 없으면 파생 클래스의 소멸자가 호출되지 않을 수 있습니다.

**질문 3: 가상 소멸자가 없을 때 발생할 수 있는 문제는 무엇인가요?**
- **현재 답변**: "기반클래스로 관리하고 있을 때 소멸하며 소멸자가 호출되면 기반클래스의 소멸자가 호출됩니다. 기반클래스의 소멸자로 기반 클래스의 힙 할당 객체들은 정상적으로 해제되겠지만, 파생 클래스에서 갖고있는 힙 할당 객체들은 파생클래스의 소멸자가 호출되지 않아 해제되지 않는 메모리 누수 문제가 발생할 수 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "자원 누수/정리 누락(UB 위험)"이라는 표현을 사용하면 더 포괄적입니다.
  - ✅ **정확한 답변**: "파생 소멸자가 호출되지 않아 자원 누수/정리 누락(UB 위험)이 발생할 수 있습니다."
  - 가상 소멸자가 없으면 파생 클래스의 소멸자가 호출되지 않아 메모리 누수뿐만 아니라 다른 자원(파일, 뮤텍스 등)의 정리도 누락될 수 있습니다.

### ✅ 실무 / 함정 질문

**질문 1: 생성자에서 가상 함수 호출은 안전한가요?**
- **현재 답변**: "의도한 동작이 이뤄지지 않습니다. vtable이 완성되지 않은 상태이며, 언어적 차원에서 virtual로 동작하지 않도록 막습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "안전하지 않다"는 결론을 명확히 제시하면 좋습니다.
  - ✅ **정확한 답변**: "안전하지 않습니다(아직 파생 타입으로 완성되기 전이라 동적 디스패치 기대가 깨질 수 있습니다)."
  - 생성자 실행 시점에는 아직 파생 클래스 부분이 초기화되지 않아 가상 함수가 기대대로 동작하지 않습니다.

**질문 2: 소멸자에서 가상 함수 호출은 어떤 문제가 있나요?**
- **현재 답변**: "소멸자도 마찬가지라 vtable이 사라지는 상태이기 때문에 언어적 차원에서 가상함수가 아닌 함수로 호출되게 됩니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "파생 부분이 이미 파괴되어"라는 표현을 사용하면 더 명확합니다.
  - ✅ **정확한 답변**: "소멸 중에는 파생 부분이 이미 파괴되어 가상 호출이 기대와 다르게 동작할 수 있습니다."
  - 소멸자 실행 시점에는 파생 클래스 부분이 이미 파괴되어 가상 함수가 파생 클래스 버전이 아닌 기반 클래스 버전으로 호출됩니다.

**질문 3: 생성자/소멸자 호출 순서를 한 문장으로 요약해보세요.**
- **현재 답변**: "상속 관계에서 생성자 호출 순서는 기반->파생, 소멸자 호출 순서는 파생->기반 순서로 이루어집니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 멤버 객체도 포함하여 더 포괄적으로 설명하면 좋습니다.
  - ✅ **정확한 답변**: "생성은 의존성 순(부모→멤버→자식), 소멸은 그 역순입니다."
  - 생성자는 부모 → 멤버(선언 순서) → 자식 순으로, 소멸자는 그 역순으로 호출됩니다.

### 📊 전체 평가

**강점:**
- ✅ 생성자와 소멸자의 기본 호출 시점을 정확히 이해하고 있습니다
- ✅ 스코프 종료 시 소멸자 호출 순서(LIFO)를 정확히 알고 있습니다
- ✅ 상속 관계에서 생성자/소멸자 호출 순서를 정확히 이해하고 있습니다
- ✅ 가상 소멸자의 필요성을 정확히 파악하고 있습니다
- ✅ 생성자/소멸자에서 가상 함수 호출의 문제를 이해하고 있습니다

**개선 필요:**
- ❌ **오개념**: 
  - 멤버 초기화 리스트의 순서가 실제 초기화 순서를 결정한다고 생각 → 실제로는 멤버 선언 순서가 결정
- ⚠️ **부정확한 부분**: 
  - 클래스 멤버 생성 순서 설명이 불완전함 (부모 → 멤버 → 본문 순서 누락)
  - 부모 생성자가 먼저 호출되는 이유를 메모리 구조로만 설명 → 불변식 보장이 핵심
  - 자식 소멸자가 먼저 호출되는 이유 설명이 불완전함 → 자원 의존성 문제가 핵심
- 💡 **개선이 필요한 부분**:
  - 생성자/소멸자 호출 시점 설명에 "스코프 종료/삭제 시" 표현 추가
  - 정적 객체 초기화 순서 문제 설명에 "번역 단위" 용어 사용
  - 가상 소멸자 정의에 목적 명시

**우선순위:**
1. **높음**: 멤버 초기화 리스트의 순서와 실제 초기화 순서의 관계 정확히 이해하기 (면접에서 자주 나오는 함정 질문)
2. **중간**: 부모 생성자와 자식 소멸자가 먼저 호출되는 이유를 불변식/의존성 관점에서 이해하기
3. **낮음**: 용어 정확성 개선 (번역 단위, 스코프 종료/삭제 시 등)

**특별 주의사항:**
- 멤버 초기화 리스트의 작성 순서는 실제 초기화 순서와 무관하며, 실제 순서는 멤버 선언 순서에 따라 결정됩니다. 면접에서 자주 나오는 함정 질문입니다.
- 부모 생성자가 먼저 호출되는 이유는 기반 클래스의 불변식을 먼저 보장해야 하기 때문입니다.
- 자식 소멸자가 먼저 호출되는 이유는 파생 클래스의 자원이 기반 클래스의 상태에 의존적일 수 있기 때문입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 🧠 1줄 모범 답변

1. 생성자는 객체 생성 시, 소멸자는 객체가 파괴될 때(스코프 종료/삭제 시) 호출됩니다.
2. 올바른 초기화·자원 관리(RAII)와 예외 안전성을 보장하기 위해 순서가 중요합니다.
3. 같은 스코프의 자동 객체는 생성의 역순(LIFO)으로 소멸됩니다.

4. 지역 객체는 선언 지점에서 생성되고 해당 스코프를 벗어날 때 소멸됩니다.
5. 블록 안에서 나중에 생성된 객체부터 먼저 소멸됩니다.

6. 생성 시에는 (부모 →) 멤버(선언 순서) → 본문 순으로 초기화/실행됩니다.
7. 소멸 시에는 본문 → 멤버(선언 역순) → (부모) 순으로 파괴됩니다.
8. 실제 멤버 초기화 순서는 “멤버 선언 순서”이며 초기화 리스트에 적은 순서와 무관합니다.

9. 상속에서 생성은 부모 생성자 → 자식 생성자 순으로 호출됩니다.
10. 상속에서 소멸은 자식 소멸자 → 부모 소멸자 순으로 호출됩니다.
11. 부모 부분이 먼저 초기화되어야 자식이 그 상태에 의존해 안전하게 생성될 수 있습니다.
12. 자식이 보유한 자원을 먼저 정리한 뒤 부모 자원을 정리해야 안전하기 때문입니다.

13. 전역/네임스페이스 스코프 객체는 일반적으로 `main()` 시작 전에 초기화됩니다.
14. 전역/네임스페이스 스코프 객체는 프로그램 종료 과정에서 소멸됩니다.
15. 정적 지역 변수는 “최초로 제어 흐름이 도달할 때” 1회 초기화됩니다.
16. 서로 다른 번역 단위 간 정적 객체의 초기화 순서가 보장되지 않아 의존성이 깨질 수 있는 문제입니다.

17. 기반 클래스 포인터로 삭제할 때도 파생 클래스 소멸자가 호출되도록 하는 소멸자입니다.
18. `Base* p = new Derived; delete p;` 상황에서 전체 소멸(파생→기반)을 보장하기 위해 필요합니다.
19. 파생 소멸자가 호출되지 않아 자원 누수/정리 누락(UB 위험)이 발생할 수 있습니다.

20. 안전하지 않습니다(아직 파생 타입으로 완성되기 전이라 동적 디스패치 기대가 깨질 수 있습니다).
21. 소멸 중에는 파생 부분이 이미 파괴되어 가상 호출이 기대와 다르게 동작할 수 있습니다.
22. “생성은 의존성 순(부모→멤버→자식), 소멸은 그 역순”입니다.

</div>
</details>