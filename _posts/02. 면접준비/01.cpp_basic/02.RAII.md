---
title: 
date: 2026-01-07 22:17:43 +09:00
categories: [면접준비, 01.cpp_basic]
published: false
tags:
    [면접준비]
---

# 🧠 C++ RAII (Resource Acquisition Is Initialization) 면접 질문 리스트

---

## ✅ RAII 기본 개념

1. RAII란 무엇인가요?

    - RAII란 자원의 관리를 객체의 생명주기에 맡기는 것입니다.

2. RAII가 해결하려는 문제는 무엇인가요?

    - 생성 후 초기화나, 해제 전 호출해야 하는 함수들을 실수나 예외에 의해 호출되지 않는 상황을 방지하기 위함입니다.

3. RAII는 C++의 어떤 특징을 기반으로 동작하나요?

    - 객체의 생성자에서 초기화를, 소멸자에서 해제를 하게 됩니다. 

5. RAII는 왜 C++에서 중요한 개념인가요?

    - raw pointer나 mutex등을 자유롭게 제어할 수 있기 때문에 문제들이 발생할 수 있습니다. 이를 방지하기 위한 기법으로 C++에서 중요합니다.

---

## ✅ 생성자 / 소멸자 관점

1. RAII에서 생성자의 역할은 무엇인가요?

    - 자원 획득 및 초기화입니다.

2. RAII에서 소멸자의 역할은 무엇인가요?

    - 해제입니다.

3. 생성자와 소멸자가 호출되는 시점은 언제인가요?

    - 생성자는 RAII로 자원을 관리하는 객체가 생성될 때 호출되고, 관리 객체가 해제될 때 소멸자가 호출됩니다.

4. RAII에서 예외(Exception)는 어떻게 처리되나요?

    - 스택에 생성한 RAII 객체라면 스택 언와인딩이 발생해도 스택이 해제되며 동시에 메모리에서 해제되며 소멸자가 호출됩니다.

---

## ✅ 스택 / 힙과의 관계

1. RAII는 스택과 어떤 관계가 있나요?

    - 스택에 생성하여 스택 객체의 생명주기에 자원을 묶을 수 있습니다.

2. RAII는 힙 메모리와도 함께 사용할 수 있나요?

    - RAII는 힙 메모리에 있는 자원을 관리할수도, RAII 객체 자체가 힙 메모리에 있을수도 있습니다.

3. RAII가 스택 기반 관리라고 불리는 이유는 무엇인가요?

    - RAII를 힙에 할당하는것은 가능은하지만, RAII 객체를 관리하는 또 다른 객체가 필요해지기 때문에 RAII 목적과 다르게 사용되는 것입니다. 따라서 RAII는 보통 스택에 생성하고, 스택 객체의 생명주기에 자원을 바인딩하기 때문에 스택기반관리라고 불리게 됩니다.

---

## ✅ 실무 예제 이해

1. 파일 핸들을 RAII로 관리한다는 것은 무엇을 의미하나요?

    - 파일 오픈 후 파일 포인터의 사용을 마치면 파일을 닫아주어야 하는데, 이를 RAII에 맡겨 소멸자에서 파일을 닫아주는 것을 의미합니다.

2. 뮤텍스(mutex)를 RAII로 관리하면 어떤 장점이 있나요?

    - 대표적으론 lock_gard나 unique_lock이 있습니다. lock을 호출하면 반드시 unlock을 해야 데드락이 발생하지 않는데, unlock을 객체 생명주기의 소멸자에 맞춰 반드시 unlock이 호출되게 됩니다.

3. 스마트 포인터는 RAII 개념을 어떻게 활용하나요?

    - raw pointer의 해제를 소멸자에서 관리합니다. shared_ptr같은 경우 여러 RAII가 가리킬 수 있는데, 내부적으로 카운트를 관리하여 카운트가 0이 될 때 메모리를 해제하는 방식을 사용합니다.

---

## ✅ 복사 / 이동과 RAII

1. RAII 객체를 복사하면 어떤 문제가 발생할 수 있나요?

    - 일반적인 RAII를 복사한다면 가리키고 있는 자원을 관리하는 객체가 2가지가 됩니다. 한 객체가 소멸하며 자원을 해제했을 때 다른 객체는 자원의 해제여부를 모르기때문에 잘못된 접근이 발생할 수 있습니다.

2. 이동 생성자(move constructor)는 RAII에서 왜 중요한가요?

    - 복사가 불가능하기 때문에 자원에 대한 소유권을 이전하는 방식을 사용하게 됩니다. 소유권 이전을 위해 우측값을 받아 넘겨주어야하기 때문에 이동생성자가 필요합니다.

---

## ✅ 오류 및 설계 판단

1. RAII를 사용하지 않으면 어떤 문제가 발생할 수 있나요?

    - 자원에 대한 해제가 안될수도, 해제가 됐는데 접근을 하게될 수도 있습니다.

2. RAII와 `try-catch` 기반 자원 해제 방식의 차이는 무엇인가요?

    - try-catch는 느리고 모든 자원에 대한 대응이 안될 수 있기때문에 RAII를 사용하는 것이 권장됩니다.

3. RAII를 적용할 때 주의해야 할 점은 무엇인가요?

    - 복사 정책에서 메모리 관리를 주의해야 합니다.

---

## ✅ 면접 단골 함정 질문

1. RAII는 GC와 어떤 차이가 있나요?

    - RAII는 하나의 자원에 대해서 관리하는 객체이고, GC는 모든 객체를 추적하며 사용하지 않는다고 생각했을 때 자원을 해제하는 관리객체입니다.

2. RAII 객체를 전역 변수로 두는 것은 괜찮을까요?

    - 관리만 잘 한다면 괜찮겠지만, 관리를 잘 한다는 이상적인 환경에선 RAII조차 필요 없기 때문에, RAII를 사용한다면 전역변수로 두기보다는 스택에 두는 것을 권장합니다.

3. RAII 패턴과 스마트 포인터의 차이는 무엇인가요?

    - 스마트 포인터는 RAII 패턴 중 대표적인 예 라고 할 수 있습니다.

4. RAII는 메모리 관리 기법인가요?

    - 메모리를 자원으로써 관리한다면 메모리 관리 기법이라고 볼 수 있습니다. 그러나 메모리 관리 뿐만 아니라 mutex나 file 포인터를 관리하기도 합니다.

5. RAII를 한 문장으로 요약해보세요.

    - RAII는 자원의 관리를 객체의 생명주기와 연결시키는 패러다임입니다.

---

## 📝 GPT 피드백

### ✅ RAII 기본 개념

**질문 1: RAII란 무엇인가요?**
- **현재 답변**: "RAII란 자원의 관리를 객체의 생명주기에 맡기는 것입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "획득과 해제"를 명시하면 더 정확합니다.
  - ✅ **정확한 답변**: "RAII는 자원의 획득과 해제를 객체의 생명 주기에 묶는 C++ 자원 관리 기법입니다."
  - RAII는 자원을 획득하는 시점(생성자)과 해제하는 시점(소멸자)을 객체의 생명 주기에 연결합니다.

**질문 2: RAII가 해결하려는 문제는 무엇인가요?**
- **현재 답변**: "생성 후 초기화나, 해제 전 호출해야 하는 함수들을 실수나 예외에 의해 호출되지 않는 상황을 방지하기 위함입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "자원 누수"와 "예외 상황에서의 해제 누락"을 명시하면 더 명확합니다.
  - ✅ **정확한 답변**: "자원 누수와 예외 상황에서의 해제 누락 문제를 해결하기 위해 사용됩니다."
  - RAII는 특히 예외가 발생했을 때 자원이 확실히 해제되도록 보장합니다.

**질문 3: RAII는 C++의 어떤 특징을 기반으로 동작하나요?**
- **현재 답변**: "객체의 생성자에서 초기화를, 소멸자에서 해제를 하게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 RAII의 동작 방식을 설명하지만, C++의 어떤 특징을 기반으로 하는지는 명확하지 않습니다.
  - ✅ **정확한 답변**: "객체의 생성자와 소멸자가 자동 호출되는 C++의 스코프 기반 생명 주기를 활용합니다."
  - RAII는 C++의 스코프 기반 생명 주기와 생성자/소멸자의 자동 호출 메커니즘을 활용합니다.

**질문 5: RAII는 왜 C++에서 중요한 개념인가요?**
- **현재 답변**: "raw pointer나 mutex등을 자유롭게 제어할 수 있기 때문에 문제들이 발생할 수 있습니다. 이를 방지하기 위한 기법으로 C++에서 중요합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "예외 안전성"과 "코드 안정성"을 명시하면 더 좋습니다.
  - ✅ **정확한 답변**: "예외 안전성과 코드 안정성을 크게 향상시키기 때문입니다."
  - RAII는 예외가 발생해도 자원이 확실히 해제되도록 보장하여 예외 안전성을 제공합니다.

### ✅ 생성자 / 소멸자 관점

**질문 1: RAII에서 생성자의 역할은 무엇인가요?**
- **현재 답변**: "자원 획득 및 초기화입니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "안전하게" 획득한다는 점을 강조하면 더 좋습니다.
  - ✅ **정확한 답변**: "생성자는 자원을 안전하게 획득하고 초기화하는 역할을 합니다."
  - 생성자에서 자원 획득이 실패하면 예외를 던져 객체 생성 자체가 실패하도록 해야 합니다.

**질문 2: RAII에서 소멸자의 역할은 무엇인가요?**
- **현재 답변**: "해제입니다."
- **피드백**:
  - 💡 **보완**: 답변이 너무 간단합니다. "반드시 해제"한다는 점을 강조하면 좋습니다.
  - ✅ **정확한 답변**: "소멸자는 객체가 스코프를 벗어날 때 자원을 반드시 해제합니다."
  - 소멸자는 예외가 발생해도 호출되므로 자원 해제를 보장합니다.

**질문 3: 생성자와 소멸자가 호출되는 시점은 언제인가요?**
- **현재 답변**: "생성자는 RAII로 자원을 관리하는 객체가 생성될 때 호출되고, 관리 객체가 해제될 때 소멸자가 호출됩니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "스코프 종료 시"라는 표현을 사용하면 더 정확합니다.
  - ✅ **정확한 답변**: "생성자는 객체 생성 시, 소멸자는 스코프 종료 시 자동으로 호출됩니다."
  - 소멸자는 객체가 스코프를 벗어날 때 자동으로 호출되며, 예외가 발생해도 스택 언와인딩 과정에서 호출됩니다.

**질문 4: RAII에서 예외(Exception)는 어떻게 처리되나요?**
- **현재 답변**: "스택에 생성한 RAII 객체라면 스택 언와인딩이 발생해도 스택이 해제되며 동시에 메모리에서 해제되며 소멸자가 호출됩니다."
- **피드백**:
  - ⚠️ **부정확**: "메모리에서 해제되며"라는 표현이 부정확합니다. 스택 언와인딩 시 소멸자가 호출되어 자원이 해제됩니다.
  - ✅ **정확한 답변**: "예외가 발생해도 스택 언와인딩 과정에서 소멸자가 호출되어 자원이 해제됩니다."
  - RAII의 핵심은 예외가 발생해도 소멸자가 호출되어 자원이 확실히 해제된다는 점입니다.

### ✅ 스택 / 힙과의 관계

**질문 2: RAII는 힙 메모리와도 함께 사용할 수 있나요?**
- **현재 답변**: "RAII는 힙 메모리에 있는 자원을 관리할수도, RAII 객체 자체가 힙 메모리에 있을수도 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만, RAII 객체를 힙에 두는 것은 일반적이지 않으며 RAII의 목적과 다릅니다.
  - ✅ **정확한 답변**: "힙 자원도 RAII 객체로 감싸면 안전하게 관리할 수 있습니다."
  - RAII 객체 자체는 보통 스택에 두고, 힙에 할당된 자원을 관리하는 것이 일반적입니다.

**질문 3: RAII가 스택 기반 관리라고 불리는 이유는 무엇인가요?**
- **현재 답변**: "RAII를 힙에 할당하는것은 가능은하지만, RAII 객체를 관리하는 또 다른 객체가 필요해지기 때문에 RAII 목적과 다르게 사용되는 것입니다. 따라서 RAII는 보통 스택에 생성하고, 스택 객체의 생명주기에 자원을 바인딩하기 때문에 스택기반관리라고 불리게 됩니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 핵심은 "스코프 종료 시 자동으로 소멸자가 호출되기 때문"입니다.
  - ✅ **정확한 답변**: "스코프 종료 시 자동으로 소멸자가 호출되기 때문입니다."
  - RAII는 스택 객체의 자동 소멸 특성을 활용하여 자원 관리를 자동화합니다.

### ✅ 실무 예제 이해

**질문 1: 파일 핸들을 RAII로 관리한다는 것은 무엇을 의미하나요?**
- **현재 답변**: "파일 오픈 후 파일 포인터의 사용을 마치면 파일을 닫아주어야 하는데, 이를 RAII에 맡겨 소멸자에서 파일을 닫아주는 것을 의미합니다."
- **피드백**:
  - ⚠️ **부정확**: "파일 포인터"라는 표현이 부정확합니다. 파일 핸들(file handle)을 관리하는 것입니다.
  - ✅ **정확한 답변**: "파일 열기와 닫기를 객체 생성과 소멸에 묶어 관리하는 것입니다."
  - 파일을 열 때 생성자에서 열고, 소멸자에서 닫아 자동으로 관리합니다.

**질문 2: 뮤텍스(mutex)를 RAII로 관리하면 어떤 장점이 있나요?**
- **현재 답변**: "대표적으론 lock_gard나 unique_lock이 있습니다. lock을 호출하면 반드시 unlock을 해야 데드락이 발생하지 않는데, unlock을 객체 생명주기의 소멸자에 맞춰 반드시 unlock이 호출되게 됩니다."
- **피드백**:
  - ⚠️ **부정확**: "lock_gard"는 "lock_guard"의 오타입니다.
  - ✅ **정확한 답변**: "락과 언락이 자동으로 보장되어 데드락과 누락을 방지할 수 있습니다."
  - `std::lock_guard`나 `std::unique_lock`을 사용하면 락 획득과 해제가 자동으로 보장됩니다.

**질문 3: 스마트 포인터는 RAII 개념을 어떻게 활용하나요?**
- **현재 답변**: "raw pointer의 해제를 소멸자에서 관리합니다. shared_ptr같은 경우 여러 RAII가 가리킬 수 있는데, 내부적으로 카운트를 관리하여 카운트가 0이 될 때 메모리를 해제하는 방식을 사용합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "소멸자에서 `delete`를 호출"한다는 점을 명시하면 더 명확합니다.
  - ✅ **정확한 답변**: "스마트 포인터는 소멸자에서 `delete`를 호출해 동적 메모리를 관리합니다."
  - `unique_ptr`은 소멸자에서 직접 `delete`를 호출하고, `shared_ptr`은 참조 카운트를 관리합니다.

### ✅ 복사 / 이동과 RAII

**질문 1: RAII 객체를 복사하면 어떤 문제가 발생할 수 있나요?**
- **현재 답변**: "일반적인 RAII를 복사한다면 가리키고 있는 자원을 관리하는 객체가 2가지가 됩니다. 한 객체가 소멸하며 자원을 해제했을 때 다른 객체는 자원의 해제여부를 모르기때문에 잘못된 접근이 발생할 수 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "중복 해제" 문제를 명시하면 더 명확합니다.
  - ✅ **정확한 답변**: "자원이 중복 해제되는 문제가 발생할 수 있습니다."
  - 같은 자원을 두 객체가 소유하게 되어 한 객체가 해제한 후 다른 객체가 다시 해제하려고 하면 이중 해제(double free) 오류가 발생합니다.

**질문 2: 이동 생성자(move constructor)는 RAII에서 왜 중요한가요?**
- **현재 답변**: "복사가 불가능하기 때문에 자원에 대한 소유권을 이전하는 방식을 사용하게 됩니다. 소유권 이전을 위해 우측값을 받아 넘겨주어야하기 때문에 이동생성자가 필요합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "안전하게 이전"한다는 점을 강조하면 더 좋습니다.
  - ✅ **정확한 답변**: "소유권을 안전하게 이전하기 위해 이동 생성자가 필요합니다."
  - 이동 생성자를 통해 자원의 소유권을 안전하게 이전하면서 복사 문제를 피할 수 있습니다.

### ✅ 오류 및 설계 판단

**질문 1: RAII를 사용하지 않으면 어떤 문제가 발생할 수 있나요?**
- **현재 답변**: "자원에 대한 해제가 안될수도, 해제가 됐는데 접근을 하게될 수도 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "예외 상황에서"라는 맥락을 추가하면 더 명확합니다.
  - ✅ **정확한 답변**: "예외 상황에서 자원 누수와 해제 누락이 발생할 수 있습니다."
  - 특히 예외가 발생했을 때 자원이 해제되지 않아 메모리 누수가 발생할 수 있습니다.

**질문 2: RAII와 `try-catch` 기반 자원 해제 방식의 차이는 무엇인가요?**
- **현재 답변**: "try-catch는 느리고 모든 자원에 대한 대응이 안될 수 있기때문에 RAII를 사용하는 것이 권장됩니다."
- **피드백**:
  - ⚠️ **부정확**: "느리다"는 표현은 부정확합니다. 핵심은 "누락 위험"입니다.
  - ✅ **정확한 답변**: "RAII는 스코프 종료만으로 자원 해제를 보장하지만 try-catch는 누락 위험이 있습니다."
  - try-catch는 모든 경로에서 명시적으로 해제 코드를 작성해야 하므로 누락 위험이 있습니다.

**질문 3: RAII를 적용할 때 주의해야 할 점은 무엇인가요?**
- **현재 답변**: "복사 정책에서 메모리 관리를 주의해야 합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "복사/이동 정책과 소유권"을 명시하면 더 구체적입니다.
  - ✅ **정확한 답변**: "복사/이동 정책과 소유권을 명확히 설계해야 합니다."
  - RAII 객체의 복사/이동 가능 여부와 소유권 정책을 명확히 설계해야 합니다.

### ✅ 면접 단골 함정 질문

**질문 1: RAII는 GC와 어떤 차이가 있나요?**
- **현재 답변**: "RAII는 하나의 자원에 대해서 관리하는 객체이고, GC는 모든 객체를 추적하며 사용하지 않는다고 생각했을 때 자원을 해제하는 관리객체입니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 핵심 차이를 놓치고 있습니다. 가장 중요한 차이는 "결정적 소멸 vs 비결정적 소멸"입니다.
  - ✅ **정확한 답변**: "RAII는 결정적 소멸을 제공하지만 GC는 비결정적입니다."
  - 결정적 소멸: 해제 시점이 확실함 (스코프 종료 시). 비결정적 소멸: 해제가 언제 이뤄지는지 알 수 없음 (GC가 결정).

**질문 2: RAII 객체를 전역 변수로 두는 것은 괜찮을까요?**
- **현재 답변**: "관리만 잘 한다면 괜찮겠지만, 관리를 잘 한다는 이상적인 환경에선 RAII조차 필요 없기 때문에, RAII를 사용한다면 전역변수로 두기보다는 스택에 두는 것을 권장합니다."
- **피드백**:
  - ⚠️ **부정확**: 답변이 핵심 문제를 놓치고 있습니다. 전역 RAII 객체의 문제는 "초기화/종료 순서 문제"입니다.
  - ✅ **정확한 답변**: "전역 RAII 객체는 초기화/종료 순서 문제를 일으킬 수 있습니다."
  - 전역 객체의 초기화 순서는 보장되지 않아 다른 전역 객체와의 의존성 문제가 발생할 수 있습니다.

**질문 3: RAII 패턴과 스마트 포인터의 차이는 무엇인가요?**
- **현재 답변**: "스마트 포인터는 RAII 패턴 중 대표적인 예 라고 할 수 있습니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "RAII는 개념이고 스마트 포인터는 구현"이라는 점을 명시하면 더 명확합니다.
  - ✅ **정확한 답변**: "RAII는 개념이고 스마트 포인터는 이를 구현한 도구 중 하나입니다."
  - RAII는 자원 관리 패러다임이고, 스마트 포인터는 RAII 패턴을 메모리 관리에 적용한 구체적인 구현입니다.

**질문 4: RAII는 메모리 관리 기법인가요?**
- **현재 답변**: "메모리를 자원으로써 관리한다면 메모리 관리 기법이라고 볼 수 있습니다. 그러나 메모리 관리 뿐만 아니라 mutex나 file 포인터를 관리하기도 합니다."
- **피드백**:
  - 💡 **보완**: 답변은 맞지만 "모든 종류의 자원 관리 기법"이라는 표현을 사용하면 더 명확합니다.
  - ✅ **정확한 답변**: "메모리뿐 아니라 모든 종류의 자원 관리 기법입니다."
  - RAII는 메모리뿐만 아니라 파일, 뮤텍스, 네트워크 연결 등 모든 종류의 자원을 관리하는 기법입니다.

### 📊 전체 평가

**강점:**
- ✅ RAII의 기본 개념과 목적을 잘 이해하고 있습니다
- ✅ 생성자와 소멸자의 역할을 정확히 알고 있습니다
- ✅ 스마트 포인터가 RAII의 예시라는 것을 이해하고 있습니다
- ✅ 복사 시 발생하는 문제를 정확히 파악하고 있습니다

**개선 필요:**
- ❌ **오개념**: 
  - RAII와 GC의 차이를 "하나의 자원 vs 모든 객체"로 설명 → 결정적 소멸 vs 비결정적 소멸이 핵심
  - 전역 RAII의 문제를 "관리만 잘 한다면"으로 설명 → 초기화/종료 순서 문제가 핵심
- ⚠️ **부정확한 부분**: 
  - 예외 처리 설명에서 "메모리에서 해제되며"라는 표현 사용
  - 파일 핸들을 "파일 포인터"로 표현
  - "lock_gard" 오타 (lock_guard)
  - try-catch가 "느리다"는 표현 (핵심은 누락 위험)
- 💡 **개선이 필요한 부분**:
  - RAII 정의에 "획득과 해제" 명시 필요
  - C++의 어떤 특징을 기반으로 하는지 명확히 설명 필요
  - 소멸자 역할 설명이 너무 간단함
  - RAII 객체를 힙에 두는 것에 대한 설명 보완 필요

**우선순위:**
1. **높음**: RAII와 GC의 차이를 결정적 소멸 vs 비결정적 소멸로 정확히 이해하기 (면접에서 자주 나오는 질문)
2. **중간**: 전역 RAII 객체의 초기화/종료 순서 문제 이해하기
3. **낮음**: 용어 정확성 개선 (파일 포인터 → 파일 핸들, lock_gard → lock_guard)

**특별 주의사항:**
- RAII와 GC의 차이는 "결정적 소멸 vs 비결정적 소멸"이 핵심입니다. 면접에서 자주 나오는 질문입니다.
- 전역 RAII 객체는 초기화 순서 문제로 인해 피해야 합니다.
- RAII는 메모리뿐만 아니라 모든 종류의 자원 관리 기법입니다.

<details>
<summary>GPT 1줄 답변</summary>
<div markdown="1">

## 🧠 1줄 모범 답변

1. RAII는 자원의 획득과 해제를 객체의 생명 주기에 묶는 C++ 자원 관리 기법입니다.
2. 자원 누수와 예외 상황에서의 해제 누락 문제를 해결하기 위해 사용됩니다.
3. 객체의 생성자와 소멸자가 자동 호출되는 C++의 스코프 기반 생명 주기를 활용합니다.
5. 예외 안전성과 코드 안정성을 크게 향상시키기 때문입니다.

---

1. 생성자는 자원을 안전하게 획득하고 초기화하는 역할을 합니다.
2. 소멸자는 객체가 스코프를 벗어날 때 자원을 반드시 해제합니다.
3. 생성자는 객체 생성 시, 소멸자는 스코프 종료 시 자동으로 호출됩니다.
4. 예외가 발생해도 스택 언와인딩 과정에서 소멸자가 호출되어 자원이 해제됩니다.

---

1. RAII는 스택 객체의 자동 소멸 특성을 기반으로 동작합니다.
2. 힙 자원도 RAII 객체로 감싸면 안전하게 관리할 수 있습니다.
3. 스코프 종료 시 자동으로 소멸자가 호출되기 때문입니다.

---

1. 파일 열기와 닫기를 객체 생성과 소멸에 묶어 관리하는 것입니다.
2. 락과 언락이 자동으로 보장되어 데드락과 누락을 방지할 수 있습니다.
3. 스마트 포인터는 소멸자에서 `delete`를 호출해 동적 메모리를 관리합니다.

---

1. 자원이 중복 해제되는 문제가 발생할 수 있습니다.
2. 소유권을 안전하게 이전하기 위해 이동 생성자가 필요합니다.

---

1. 예외 상황에서 자원 누수와 해제 누락이 발생할 수 있습니다.
2. RAII는 스코프 종료만으로 자원 해제를 보장하지만 try-catch는 누락 위험이 있습니다.
3. 복사/이동 정책과 소유권을 명확히 설계해야 합니다.

---

1. RAII는 결정적 소멸을 제공하지만 GC는 비결정적입니다.
2. 전역 RAII 객체는 초기화/종료 순서 문제를 일으킬 수 있습니다.
3. RAII는 개념이고 스마트 포인터는 이를 구현한 도구 중 하나입니다.
4. 메모리뿐 아니라 모든 종류의 자원 관리 기법입니다.
5. 자원을 객체 생명 주기에 묶어 자동으로 관리하는 패턴입니다.

</div>
</details>