---
title: 
date: 2026-02-13 13:40:55 +09:00
categories: [Unity, Attribute]
published: true
tags:
    [Unity, Attribute]
---

## 1. 개요

Attribute란?

1. 엔진과 스크립트의 상호작용을 정의
2. 에디터 워크플로우를 최적화
3. 데이터 직렬화 제어
4. 코드의 실행되는 생명주기 제어


를 하기 위해 사용됨

[]를 사용하면 .NET의 리플렉션을 트리거 한다고 함

> 리플렉션은 성능적으로 일반 함수 호출보다 100배 이상 느리기 때문에 꼭 필요한 경우에만 사용해야함
{: .prompt-info}

> 코드 스트리핑도 조심해야 한다고 함. IL2CPP 빌드시, 대괄호로만 참조된 코드는 사용되지 않는 것으로 간주되어 삭제될 수 있음. 이 때 [Preserve] 사용해야 강제로 빌드에 포함시킬 수 있음
{: .prompt-warning}

## 2. Serialization

### 1. 캡슐화와 에디터 접근성의 분리

원래는 public과 private등으로만 제어되지만, 유니티 '에디터에서의 수정 가능성'을 제어하기 위함

- [SerializeField] : private 변수도 에디터에서 수정 가능
- [HideInInspector] : public 변수도 에디터에서 숨김 
- [NonSerialized] : public변수지만, 런타임중에 임시로 사용되는 데이터라면 직렬화 및 인스펙터 표시를 막을 수 있음

### 2. 데이터 구조 및 참조 방식의 정의

기본적으로 MonoBehaviour를 상속받지 않는 일반 클래스나 구조체는 직렬화하지 않음. 

- [Serializable] : 일반 클래스나 구조체를 직렬화 가능하게 함
- [SerializeReference] : 기본적으로 유니티는 커스텀 클래스를 값 복사 로 직렬화를 함. 이 속성을 사용하면 참조 형태로 저장할 수 있음. 이를 통해 다형성, null 값 허용, 순환참조 등을 처리할 수 있게 됨

### 3. 성능 최적화 도구로서의 직렬화

- GetComponent vs 직렬화된 참조: GetComponent를 호출하는 것보다, 에디터 타임에 미리 연결된 참조를 사용하는 것이 성능상 훨씬 유리하다고 함. 직렬화된 참조는 GUID를 통해 즉시 매핑되어서 런타임 오버헤드가 제거됨. 런타임 비용이 0에 가까움

> 직렬화 참조는 로드 타임, GetComponent는 런타임에 비용이 발생함
{: .prompt-info}

- 프로퍼티 직렬화: 유니티는 원래 프로퍼티 말고 필드만 직렬화 함. 근데 [field: SerializeField]를 사용하면 오토 프로퍼티의 숨겨진 백킹 필드를 직렬화 해서, 프로퍼티의 편리함과 직렬화의 이점을 동시에 취할 수 있음

> 오토 프로퍼티: 게터와 세터만 있는 프로퍼티. 백킹 필드를 직접 작성할 필요가 없고, 숨겨진 백킹 필드가 자동으로 생성됨
{: .prompt-info}

> 숨겨진 백킹 필드: 오토 프로퍼티의 게터와 세터가 참조하는 변수. 컴파일러가 자동으로 생성함
{: .prompt-info}

### 4. 주의사항 및 한계

- 리플렉션 비용

- 스레드 안정성: 메인 스레드가 아닌 로딩 스레드에서 발생할 수 있음. 생성자나 필드 초기화에서 유니티 API를 호출하면 안됨

### 5. [SerializeField]

데이터를 '직렬화'해서 디스크에 '저장'하는 것

원래 유니티는 씬, 프리팹, 에셋등을 저장할 때 메모리에 있는 객체를 YAML이나 바이너리 형식으로 변환해서 디스크에 기록함

단, 직렬화하려는 필드의 타입 자체가 직렬화 가능해야 함. 기본 타입이나, Serializable이 붙은 커스텀 클래스

### 6. [Serializable]

1. 직렬화가 가능한 상태로 '자격 부여'시킴

2. 인스펙터에 나올 수 있게 함

3. '참조'가 아니라 '값' 중심의 인라인 직렬화를 함

4. 상속되지 않음, 딕셔너리나 다차원 배열은 직렬화 안됨, 정적 클래스나 정적 필드엔 불가함

### 7. [SerializeReference]

유니티는 클래스를 필드 타입으로 사용할 때 슬라이싱이 발생함. 이 때 '참조' 중심으로 직렬화를 해 다형성을 사용할 수 있도록 함

1. '참조' 중심의 직렬화를 함

2. 다형성, null 값 허용, 순환참조 등을 처리할 수 있게 됨

3. 오버헤드가 발생하므로 막 사용하면 문제가 됨.

## 3. 에디터 UI 및 가독성 (Inspector)

복잡한 커스텀 에디터 스크립트 작성 없이도 "선언"만으로도 인스펙터 인터페이스를 커스텀할 수 있음

### 1. 시각적 계층구조 및 가독성

- 그룹화([Header]): 인스펙터에서 굵은 제목을 추가하여 논리적인 카테고리로 묶어줌. 필요한 설정을 빠르게 찾도록 도움

- 여백 제공([Space]): 인스펙터에서 필드 사이에 간격을 추가하여 그룹을 시각적으로 분리함

- 문서화([Tooltip]): 인스펙터에서 필드에 대한 설명을 추가하여 사용자가 설정의 목적을 이해할 수 있도록 도움.

### 2. 입력 제어 및 유효성 검사

- 슬라이더 UI([Range]): min, max로 강제하여 조절 가능한 범위를 시각적으로 제공

- 텍스트 입력 최적화 ([TextArea] vs [Multiline]): 긴 문자열을 입력할 때 Multiline은 단순히 여러줄을 허용, TextArea는 텍스트 입력을 위한 텍스트 에디터를 제공함

- 색상 및 입력 제한([ColorUsage]): 2가지 파라미터로 제어가 가능함.

    1. 투명도 허용 여부 - false하면 알파 채널을 선택할 수 없게 됨.
    2. HDR 모드 - true하면 hdr모드를 사용할 수 있게 됨

### 3. 데이터 가시성과 직렬화의 분리

- [HideInInspector]
- [SerializeField]
- 지연된 입력([Delayed]): 사용자가 Enter키를 누르거나 포커스를 잃을 때까지 값의 변경을 지연시켜서 실시간 연산 부하를 줄이거나 데이터 변경 사이에 발생하는 문제를 방지함

### 4. 워크플로 자동화 및 상호작용

- 기능 실행([ContextMenu]): 컴포넌트의 우클릭 메뉴에서 함수를 실행하는 명령을 추가함. 게임에서 실행하지 않고도 에디터 상태에서 데이터를 초기화하거나 테스트 함수를 호출할 수 있음

- 필드별 동작([ContextMenuItem]): 특정 변수 위에서 우클릭 했을 때 실행할 함수를 연결함. `[ContextMenuItem("인스펙터에 뜰 메뉴 이름", "실행할 함수 이름")]`

### 5. 확장성

이걸로도 부족하면 PropertyDrawer를 사용하면 됨. 현재는 IMGUI에서 UI Toolkit으로 전환되었기 때문에 `CreatePropertyGUI`를 오버라이드 함

## 4. 컴포넌트 및 라이프 사이클

### 1. 실행 생명 주기의 확장

플레이 모드에서만 실행되던 생명주기 함수들이 다른 상황에서도 실행되도록 하는 어트리뷰트들이며 클래스에 붙는 키워드임

- `[ExecuteInEditMode]`: 에디터 모드에서도 컴포넌트의 생명주기 메서드를 실행할 수 있게 함. 게임 실행 없이도 컴포넌트의 동작을 테스트할 수 있음. 프리팹 모드를 지원하지 않는 구식 속성. 프리팹 모드와의 호환이 전혀 안돼서 문제가 있음

- `[ExecuteAlways]`: ExecuteInEditMode의 개선판이며 현재는 이 키워드를 권장함. 플레이모드 뿐만 아니라 에디터 모드와 프리팹 모드에서도 실행하도록 함.

### 2. 초기화 시점 제어

Awake와 Start가 아닌 시점으로 초기화 제어를 하고싶을 때 사용하는 속성.

특정 객체에 붙는 것이 아니라, 클래스에서 사용하는 static을 위한 키워드임.

- 에디터/도메인 로드 시점 ([InitializeOnLoad]): 정적 클래스에만 붙는 키워드. 정적 생성자를 자동으로 호출해줌. 주로 에디터에서 해야하는 것들이 있을 때 사용하게 됨.

> 에디터가 실행되는 시점, 스크립트를 고쳐서 컴파일 되는 순간, 플레이 모드로 전환할 때. 총 3가지 순간에 실행된다고 함. 거의 컴파일 타임에 호출된다고 생각하면 될듯.
{: .prompt-info}

- `[InitializeOnLoadMethod]`: `InitializeOnLoad`와 동일한 시점에 정적 메서드에 붙는 키워드

- 런타임 초기화 시점 ([RuntimeInitializeOnLoadMethod]): 플레이 모드에서 초기화 시점을 제어하는 속성. 
    - `RunTimeInitializeLoadType`으로 초기화 시점을 제어할 수 있음. 
    - `BeforeSceneLoad`: 씬이 로드되기 직전에 실행
    - `AfterSceneLoad`: 씬이 로드된 직후에 실행 - 기본값
    - `BeforeSplashScreen`: 스플래시 화면이 표시되기 직전에 실행
    - `AfterSplashScreen`: 스플래시 화면이 표시된 직후에 실행
    - 사용법 => `[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]`

    > 스플래시 화면이란? 게임을 실행했을 때 처음으로 나오는 화면. 유니티 로고나 게임 로고가 나오는 화면.
    {: .prompt-info}

### 3. 컴포넌트 구조 및 의존성 강제

- 의존성 주입 ([RequireComponent]): 이 컴포넌트를 객체에 추가하는 순간에 특정 컴포넌트가 붙어있지 않으면 자동으로 추가해줌. 필수 컴포넌트를 컴포넌트를 지우려고 시도해도 삭제를 방지해줌. 클래스 선언부에 붙이면 됨. 

```csharp
[RequireComponent(typeof(BoxCollider))]
[RequireComponent(typeof(Rigidbody))]
public class TestScript : MonoBehaviour 
{
    // 스크립트 내용
}
```

- 단일성 보장 ([DisallowMultipleComponent]): 이 컴포넌트를 중복해서 붙일 수 없게 함. 클래스 선언부에 붙이면 됨.

### 4. 빌드 및 코드 스트리핑 방지

- 코드 보존 ([Preserve]): 유니티는 빌드 과정에서 최적화를 진행하여 코드를 삭제하기도 함. 그러나, 리플렉션으로 인해 런타임에 동적으로 호출되는 경우에 사용되는 함수가 사용하지 않는다고 판단되어 삭제될 수 있음. 이를 방지하는 키워드임. 클래스, 메서드, 필드에 붙일 수 있음. cpp의 volatile과 비슷한 느낌이라고 생각하면 될듯.

> 여기서 코드 스트리핑이라는 단어가 자주 등장하는데, 최종 빌드할 때 사용되지 않는다고 판단되는 코드를 컴파일러가 찾아내서 삭제하는 과정을 뜻함.
{: .prompt-info}

> 여기서 IL2CPP라는 것도 자꾸 등장함ㅋㅋㅋ. IL2CPP는 스크립팅 백엔드임. 간단하게만 알아보자면 C#으로 작성된 코드는 중간언어로 변환되는데, IL2CPP가 여기서 중간언어를 C++코드로 다시 바꿔주고, 플랫폼에 맞는 네이티브 바이너리로 사전 컴파일 하는 방식을 사용함. 이게 AOT 방식임. 그래서 dynamic 키워드나 리플렉션이 지원되지 않음.
{: .prompt-info}

> 스크립팅 백엔드는 또 뭐냐? 스크립팅(코드)를 구동하는 프레임워크를 뜻함. .Net이 대표적으로 있고, 옛날 유니티에서는 Mono라는 스크립팅 백엔드를 사용했었음. .Net과 Mono는 JIT(Just-In-Time) 방식을 사용했고, IL2CPP는 AOT(Ahead-Of-Time) 방식을 사용함.
{: .prompt-info}

> JIT 방식은 런타임에 코드를 컴파일하는 방식이고, AOT 방식은 빌드 시점에 코드를 컴파일하는 방식임.
{: .prompt-info}

> dynamic 키워드는 변수의 타입을 컴파일 타임이 아닌, 런타임에 미루는 동적 타입 기능임.
{: .prompt-info}

- 빌드 후 처리 ([PostProcessBuild]): 빌드가 완료된 후 특정 함수를 실행하는 키워드. ios의 경우 xcode 프로젝트 설정이 필요한데, 이를 자동으로 해결할 수 있고, CI/CD 환경에서 유용하게 사용될 수 있음. 정적 함수에 붙여야 함

- 에셋 이벤트 훅 ([OnOpenAsset]): 에셋을 더블클릭해서 열었을 때 특정 함수를 실행하는 키워드. 정적 함수에 붙여야 함

## 5. 에디터 확장 및 메뉴

- 도구 메뉴([MenuItem]): 상단바의 도구 메뉴에 추가할 수 있는 키워드. `상위메뉴/하위메뉴` 형식으로 넣을 수 있음. 주로 어떤 것을 일괄 적용 시키거나, C# 코드를 자동생성 하기도 함

- 컴포넌트 메뉴([AddComponentMenu]): 상단바의 컴포넌트 메뉴에 추가할 수 있는 키워드. 컴포넌트를 카테고리로 깔끔하게 묶고, 빠르게 찾을 수 있도록 함

- 에셋 생성([CreateAssetMenu]): 상단바의 에셋 메뉴에 추가할 수 있는 키워드. ScriptableObject 애셋 파일을 만들 수 있도록 해줌
    - 속성으로 3가지가 있음
    - `fileName`: 파일 이름. 생성했을 때 디폴트로 가질 이름을 지정함
    - `menuName`: 메뉴 이름. 상단바의 `상위메뉴/하위메뉴`처럼 계층구조를 지정할 수 있음
    - `order`: 메뉴 순서. 같은 메뉴에 여러개가 있을 때 순서를 지정함

## 6. 성능 및 배포 이슈

- 리플렉션을 통한 메서드 호출은 100배에서 1000배 이상 느릴 수 있기 때문에 절대로 Update같은 빈번하게 호출되는 메서드에 사용하면 안됨.

- Unity의 스크립팅 백엔드는 리플렉션 객체를 캐시하고 해제하지 않아서 GC 오버헤드가 증가할 수 있음. 초기화 시점에 캐싱해서 사용해야 함

- GetComponent는 `[SerializeField]`보다 몇십배는 느림. 

- IL2CPP 빌드시 코드 스트리핑이 존재할 수 있음. AOT의 제약사항을 알고있어야 함

- ExecuteAlways같은 속성을 잘못사용하면 에디터의 전체 성능이 저하될 수 있음. `Application.IsPlaying`으로 체크해서 런타임에만 실행되도록 해야하는 경우가 있을 수 있음

