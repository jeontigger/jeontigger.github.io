---
title: 
date: 2026-02-04 18:30:41 +09:00
categories: [Git]
published: true
tags:
    [Git]
---


# Git에 대한 고찰

현재는 git을 사용하면서 add, commit, push, pull, fetch 정도만 사용하고 있다. 
rebase나 log등의 사용법 및 더 자세한 사항들을 파악하기 위해 고찰 시작

## 1. Git은 왜 등장했는가?

기존의 CVCS방식은 중앙 서버에 모든 파일이 저장되어 있어, 중앙 서버가 다운되면 모든 작업이 중단되는 단점이 있었다. 리눅스 커널을 개발하던 리누스 토르발스가 리눅스 커널의 소스코드 관리를 위해 리눅스 커널 개발자들과 함께 개발한 분산 버전 관리 시스템이다. 

Git은 DVCS방식으로 중앙 서버가 없어도 작업이 가능하며, 각자 로컬에 전체 히스토리를 저장하기 때문에 속도가 빠르다는 장점이 있다.

### **지금도 SVN을 사용하는 이유?**

Git의 분산 구조가 단점이 되는 영역에서 사용(게임 업계 등)

1. 부분 체크아웃이 가능함. git은 모든 파일을 다운로드 받아야하지만, SVN은 특정 디렉토리만 다운로드 받을 수 있음

2. 부분 권한 제어: 특정 폴더에 대한 접근을 권한에 따라 제어할 수 있음

> 요즘 git에서는 대용량을 다루는 LFS(Large File Storage)를 통해 해결하고 있음. Sparse Checkout을 통해 부분 체크아웃도 지원함
{: .prompt-info}


## 2. Git을 시작하기 위해

### **git init**

맨땅에서 시작하기. 완전 새로운 프로젝트를 시작할 때 사용함.

지정한 디렉터리에 .git 폴더를 생성함. 이 폴더에 git이 관리하는 모든 데이터가 저장됨.

### **config**

사용자를 식별하기 위한 설정이 필요함.

3가지 범위가 존재함

1. System(`--system`, /etc/gitconfig): 시스템의 모든 사용자와 모든 저장소에 적용됨.

    - git 명령으로 에디터가 필요할 때 열리는 에디터 설정
    - 줄바꿈 처리 (CRLF) 방식 통일
    - 인증 보조 도구 등록

2. Global(`--global`, ~/.gitconfig): 현재 사용자의 모든 저장소에 적용됨

    - 내가 한 커밋이 어떤 사람의 커밋인지 식별하기 위한 설정
    - 편의기능(alias): 긴 명령어를 줄일 수 있음 (예. git status -> git st)
    - 기본 에디터 설정

3. Local(`--local`, .git/config): 현재 저장소에만 적용됨

    - Global보다 우선순위가 높음
    - 프로젝트에 다르게 적용되야 하는 규칙들에 대한 설정

### **git clone**

이미 있는 저장소를 복제해올 때 사용함. 

원격 저장소는 `origin`이라는 이름으로 연결됨

**가장 기본적인 형태**

```bash
git clone <원격 저장소 주소>
```

HTTPS 주소: 별도 설정 없이 바로 사용 가능하지만, push할 때마다 아이디/비밀번호(또는 토큰)를 물어볼 수 있음

SSH 주소: SSH 키 설정이 필요하지만, 인증 절차 없이 편리하게 사용할 수 있음



> SSH란 Secure Shell의 약자로, 데이터를 안전하게 주고받기 위한 네트워크 프로토콜 입니다. 
>
> git에서 SSH를 사용하면 비밀번호 없이 인증서를 통해 안전하게 원격 저장소에 편하게 접근할 수 있음
>
> 일반적인 웹 주소(https://...)와 달리 `git@github.com:사용자/저장소.git` 또는 `ssh://user@server/project.git` 형태의 주소를 사용
>
> SSH key를 생성하고 public key를 github에 등록하면 됨.

**원하는 폴더 이름으로 복제하기**

```bash
git clone <원격 저장소 주소> <원하는 폴더 이름>
```

**특정 브랜치만 복제하기**

```bash
git clone -b <브랜치 이름> <원격 저장소 주소>
```

**얕은 복제**

과거 이력은 제외하고 최신 상태만 빠르게 가져옴

```bash
git clone --depth 1 <원격 저장소 주소>
```


## 3. Git의 내부 동작 원리: "Git은 어떻게 데이터를 저장하는가?"

###   **델타 vs 스냅샷**

버전 관리를 하는 방법에 있어서 과거에는 델타 방식(SVN)을 주로 사용했고, 나중에 스냅샷 방식(현재의 git)이 등장한 것으로 보임

델타 방식은 파일의 변경 사항만 기록하게 됨. 예를 들어 1000줄짜리 파일에서 1줄만 변경되었다면, 1줄만 기록하는 방식. 원본 + 델타1 + 델타2 + ... = 현재 파일. 이 되기 때문에 history가 길어질수록 용량이 기하급수적으로 늘어나는 단점이 있음. 변경된 부분만 저장하므로 스냅샷 방식보다 공간효율적일 수 있음.

스냅샷 방식은 파일 전체를 기록하게 됨. 예를 들어 1000줄 짜리 파일에서 1줄만 변경되어도, 1000줄을 모두 기록하는 방식. 원본 -> 변경1 -> 변경2 -> ... -> 현재파일. 이 되기 때문에 용량이 기하급수적으로 늘어나는 단점이 있음. 하지만 변경된 부분만 저장하는 것보다 속도가 빠르고, 변경된 부분을 찾기 쉽다는 장점이 있음.

git에서 스냅샷 방식을 사용하지만, 네트워크로 전달할 때엔 용량 효율적인 델타 방식을 사용하기도 함. 이 경우엔 받은 쪽에서 resolving deltas라는 절차가 필요함.

![alt text](..\..\assets\img\git\image.png)

###   **Git 객체 모델** 

Git은 Blob, Tree, Commit 객체들을 사용함.

**Blob**은 파일 내용 그 자체를 담음. 파일명은 상관없이 파일 내용만 SHA-1 해싱해서 Blob의 해시값을 가지게 됨. 따라서 내용이 같으면 Blob의 해시 값 또한 같게 됨.

**Tree**는 디렉터리 구조를 담음. 파일명과 Blob의 해시값을 매핑함. Tree또한 담고있는 Blob들에 따라 해시값이 결정됨. 

**Commit**은 Tree의 Root와 부모 커밋의 해시값을 담음. 이것을 통해 또 해시값이 결정됨. 종종 리비전이라는 표현은 커밋을 지칭하는 표현으로 사용됨.

이로써 DAG 구조가 만들어짐.

> SHA-1 해싱값을 사용하는 이유는 내용이 변경됐음을 40글자만 알고도 알 수 있기 때문
{: .prompt-info }

> DAG: Directed Acyclic Graph. 방향성이 있는 비순환 그래프. 자식 커밋이 부모 커밋을 가리키는 구조.
{: .prompt-info }

![alt text](..\..\assets\img\git\image_copy.png)

###   **브랜치와 HEAD의 실체**

> 브랜치란? 메인 코드를 보호하고 격리시켜서 다른 개발을 병렬적으로 진행할 수 있도록 하는 시스템
{: .prompt-info }

**브랜치**는 단순히 특정 커밋을 가리키는 '포인터'임. 브랜치 이름은 이 '포인터'의 이름이라고 볼 수 있음. 그래서 내부적으론 40자의 해시값을 가리키고 있는 구조에 불과함. 보통은 해당 브랜치의 마지막 커밋을 가리킴. 커밋을 추가하면 가리키는 커밋이 자동으로 변경됨. 

**HEAD**는 '현재 작업 중인 곳'을 가리키는 특수한 포인터임. HEAD는 보통 커밋을 가리키지 않고 브랜치를 거쳐서 커밋을 가리킴. `HEAD -> main -> 커밋 A`와 같은 식. 과거의 커밋으로 돌아가는 것은 HEAD가 브랜치를 거치지 않고 직접 커밋을 가리키게 됨. `HEAD -> 과거 커밋 A`와 같은 식. 이 상태를 detached HEAD라고 부름.

> Detached HEAD 상태에서 작업(커밋)을 하면 브랜치가 없는 상태이기 때문에 연결고리를 잃고 삭제될 수 있어서. 브랜치를 생성해야 함.
{: .prompt-warning }

## 4. '3가지 트리'와 Reset 완벽 해부
가장 헷갈리는 `reset`을 3가지 트리의 관점에서 명확히 정리합니다.
###   **3가지 트리(영역)** 

3가지 트리는 git에서 파일이 관리되는 단계별 상태를 의미함. 작업 디렉터리, 스테이징 영억, 저장소(HEAD)로 구성됨.

작업 디렉터리는 우리가 실제로 작업하는 공간에 해당됨. 실제 파일들이 들어있는 실제 폴더. 변경된 파일들은 Unstaged 상태라고 할 수 있음.

스테이징 영역은 우리가 add 명령어를 통해 커밋을 준비하는 공간에 해당됨. staged 상태라고 볼 수 있음.

저장소(HEAD)는 커밋들이 저장된 공간(주로 클라우드같은 DB)에 해당됨. HEAD는 가장 최신 커밋을 가리키는 포인터를 이야기함. 

###   **Reset의 3단계** 

git에는 3가지 reset 옵션이 존재함. 파일들의 상태를 어떻게 되돌릴지 결정하는 요소.

`--soft`: HEAD만 이동(커밋 취소, 스테이징 유지)

`--mixed`: HEAD 이동 + 인덱스 초기화(커밋 취소, 스테이징 취소, 작업 내용은 보존)

`--hard`: HEAD 이동 + 인덱스 초기화 + 작업 디렉터리 덮어쓰기(커밋 취소, 스테이징 취소, 작업 내용 삭제)

> `--hard`를 실수로 해서 커밋을 날려버렸을 때, `git reflog`를 통해 복구할 수 있음.
{: .prompt-info }

> `reset`과 `revert`의 차이점으로 `reset`은 주로 로컬에서 진행한 작업들을 흔적을 남기지 않고 되돌릴 때 사용하고, `revert`는 주로 원격 저장소에 push된 커밋을 되돌릴 때 사용하며 기록이 남음.
{: .prompt-danger }

### **깃의 변화 추적 및 가시성**

git log의 다양한 명령어들이 존재하지만, 

우리는 GitLens를 사용하는 것을 권장

## 5. 이력 관리와 협업 전략: Merge vs Rebase

단순히 병합만 하는 것이 아니라, 프로젝트의 커밋 히스토리를 어떻게 관리할 것인가에 대한 전략을 다룹니다.

###   **Merge** 

Merge는 크게 2가지 방식으로 진행됨.

1. **Fast-forward Merge**

- 분기된 브랜치(main)에서 다른 브랜치(feature)로 이동해서 작업을 진행한 경우 분기된 브랜치(main)에서 추가적인 커밋이 없는 경우 발생함.
- main 브랜치의 포인터가 feature 브랜치의 포인터를 가리키게 됨.
- Merge Commit이 생성되지 않음.
- `--no-ff` 옵션을 사용하면 fast-forward merge가 발생하더라도 merge commit을 생성할 수 있음.

> `--no-ff` 옵션은 main 브랜치에 feature 브랜치의 커밋이 포함되어 있다는 사실을 명확하게 기록하기 위해 사용함. revert에도 병합 커밋만 찾아서 revert를 진행하면 되기 때문에 이력이 깔끔하게 남음.
{: .prompt-info }

2. **3-way Merge**

- 분기된 브랜치(main)에서 다른 브랜치(feature)로 이동해서 작업을 진행한 경우 분기된 브랜치(main)에서 추가적인 커밋이 없는 경우 발생함.
- 두 브랜치의 마지막 커밋 + 분기된 시점의 마지막 커밋을 비교하기 때문에 3-way Merge라고 부름.
- Merge Commit이 생성됨.

###   **Rebase**

**Rebase**는 기본적으로 merge와 동일한 결과를 도출하지만, merge commit을 생성하지 않고 이력을 한 줄로 깔끔하게 만드는 장점이 있음.

작동방식: 다른 브랜치(feature)에 있는 커밋들을 임시 공간에 저장, 후 기준 브랜치(main)으로 이동. main의 마지막 커밋에 feature 브랜치의 커밋들을 순차적으로 적용. 그래서 rebase를 하면 feature 브랜치의 커밋들이 main 브랜치의 마지막 커밋에 붙게 됨.

> 황금률: 공유된 브랜치(remote)는 절대 Rebase 하지 않는다.
{: .prompt-danger }

> 대신에, 같은 브랜치 내에서 pull을 받을 때에는 rebase 하는 것이 merge commit도 생기지 않고, history가 깔끔하게 남음.
{: .prompt-info }

### **Cherry-Pick**

체리픽은 브랜치 전체를 병합하지 않고, 특정 커밋만 가져올 때 사용함. 

1. 커밋을 잘못했을 때 사용가능

2. 긴급 기능 끌어오기: 개발 과정에서 특정 기능이 필요한 커밋이 다른 브랜치에 있는 경우, 해당 커밋만 가져올 때 사용함.

3. 작업 복구: detached HEAD 상태에서 잃어버린 커밋을 가져올 때 사용함.

> 새로운 커밋을 만드는 행위라서 남발하면 병합시 문제가 발생할 수 있음
{: .prompt-warning}

### **스쿼시**

브랜치에서 작업한 여러 개의 커밋을 하나로 합치는 기능

1. 깔끔한 히스토리: 자잘한 커밋(오타수정 등)이 많을 때 하나로 합쳐서 히스토리를 깔끔하게 만들 수 있음.

2. 명확한 기능별로 묶기: 여러 기능이 포함된 커밋을 기능별로 묶어서 히스토리를 깔끔하게 만들 수 있음.

3. 간편한 되돌리기 (Revert): 스쿼시된 커밋을 revert하면 하나의 커밋만 되돌리면 되기 때문에 간편함.


###   **Interactive Rebase** 

로컬 커밋 히스토리를 편집기처럼 사용할 수 있는 기능. 원격에 push하기 전에 커밋 히스토리를 정리하기 위해 사용.

1. squash: 여러 커밋을 하나로 합침.

2. reword: 커밋 메시지를 수정함.

3. drop: 커밋을 삭제함.

4. 순서 변경: 커밋의 hisotry 순서 변경

## 6. 고급 복구 기술: "망했을 때 되돌리는 법"

###   **Reflog (Time Machine):** `git reset --hard`로 날려버린 커밋이나 삭제한 브랜치도 `git reflog`에 기록된 HEAD의 이동 경로를 통해 복구할 수 있음을 보여줍니다,.

reflog는 git의 안전장치라고 볼 수 있음. 로컬 저장소에서 HEAD가 가리켰던 모든 변경 이력 등을 기록함.

1. `reset --hard`로 커밋을 날려버렸을 때 

2. `branch -D`로 브랜치를 삭제했을 때

복구 가능함.

> 단, 로컬 저장소의 HEAD를 기록하기 때문에, 원격 저장소에는 존재하지 않음. 보통 90일 쯤까지 보관함
{: .prompt-warning}

###   **Detached HEAD** 

위에서 설명함

###   **Git Restore & Switch:** 헷갈리는 `checkout` 대신, 파일을 복구하는 `restore`와 브랜치를 변경하는 `switch` 명령어의 도입 배경과 사용법을 소개합니다,.

Checkout은 원래 브랜치(및 커밋) 이동, 파일 복구, 브랜치 생성 등 다양한 기능을 수행했음. 그래서 헷갈리기도 하고 모호한 점이 많았음.

그래서 2.23 버전부터 checkout을 분리해서 restore와 switch를 도입함.

switch는 브랜치 변경 및 생성만 담당.

restore는 파일 복구만 담당.

## 7. 브랜치 전략 (Workflow) 가이드

###   **Git Flow** 

main, develop, feature, release, hotfix 브랜치로 구성됨.

장점은 안정적인 버전 관리가 되며, 긴급 수정과 신규 개발을 동시에 진행할 수 있음.

단점은 구조가 복잡하여 작은 규모에선 좀 비효율적일 수 있음.

###   **GitHub Flow** 

main과 feature 브랜치로 구성됨.

PR을 올리고, 리뷰를 거쳐 main에 merge하는 방식.

장점은 구조가 단순하고, 배포가 빠름.

단점은 main 브랜치가 불안정할 수 있음.

###   **Trunk-based Development** 

가장 요즘 트렌드.

main 브랜치만 사용하거나, 매우 짧은 브렌치만 사용.

배포환경에서 개발중인 기능을 제어할 수 있는 환경이 필요함.

엄청 자주 소규모로 병합하기 때문에 conflict가 적게 발생함.
